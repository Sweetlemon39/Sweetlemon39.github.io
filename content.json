{"meta":{"title":"Sweetlemon 的异世界","subtitle":"原来你也在这里啊","description":"","author":"Sweetlemon","url":"https://sweetlemon39.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2023-04-21T07:54:17.296Z","updated":"2023-04-21T07:54:17.296Z","comments":true,"path":"404.html","permalink":"https://sweetlemon39.github.io/404.html","excerpt":"","text":"404很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2023-04-21T07:54:17.300Z","updated":"2023-04-21T07:54:17.300Z","comments":true,"path":"about/index.html","permalink":"https://sweetlemon39.github.io/about/index.html","excerpt":"","text":"Sweetlemon 标签苟延残喘的高二狗不务正业的 OIer杂牌数竞生 碎叶愿你在那个世界安好！我在这里等你。多对这个世界笑笑吧，世界也会对你笑呢~ 关于背景图片背景图片来自网络，本人不享有这些图片的版权。I don’t have copyright of these background images which are from the Internet.详细信息见画廊。The details are in the gallery."},{"title":"所有分类","date":"2023-04-21T07:54:17.300Z","updated":"2023-04-21T07:54:17.300Z","comments":true,"path":"categories/index.html","permalink":"https://sweetlemon39.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-21T07:54:17.300Z","updated":"2023-04-21T07:54:17.300Z","comments":true,"path":"comments/index.html","permalink":"https://sweetlemon39.github.io/comments/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2023-04-21T07:54:17.300Z","updated":"2023-04-21T07:54:17.300Z","comments":true,"path":"friends/index.html","permalink":"https://sweetlemon39.github.io/friends/index.html","excerpt":"朋友们的博客链接。","text":"朋友们的博客链接。"},{"title":"画廊","date":"2020-03-27T00:00:00.000Z","updated":"2020-03-27T00:00:00.000Z","comments":true,"path":"gallery/index.html","permalink":"https://sweetlemon39.github.io/gallery/index.html","excerpt":"","text":"来欣赏本站的背景图片！可以把浏览器全屏再开幻灯片展示开始“屏保”~关于图片图片来自网络，本人不享有这些图片的版权。I don’t have copyright of these images which are from the Internet.图片信息 Images Information文件名 File name链接 Link / 来源 Sourcemiku_289028.jpgKonachan 289028miku_288524.jpgKonachan 288524miku_279631.jpgKonachan 279631miku_262935.jpgKonachan 262935miku_297251.jpgKonachan 297251miku_289023.jpgKonachan 289023miku_55005893.jpgPixiv 55005893miku_56632668.jpgPixiv 56632668voc_261300.jpgKonachan 261300voc_215624.jpgKonachan 215624vc_247324.jpgKonachan 247324vc_184412.jpgKonachan 184412tianyi_229042.jpgKonachan 229042tianyi_221481.jpgKonachan 221481ia_292142.jpgKonachan 292142ia_217561.jpgKonachan 217561your_name_233767.jpgKonachan 233767anohana_172855.jpgKonachan 172855violet_259998.jpgKonachan 259998violet_261791.jpgKonachan 261791kagerou_191672.jpgKonachan 191672kagerou_184531.jpgKonachan 184531kagerou_183538.jpgKonachan 183538sukasuka__01.jpgsukasuka 应援，作者：河野絵美sukasuka__02.jpgsukasuka 应援，作者：上原あかりsukasuka__03.jpgsukasuka 小说插图，作者：uesukasuka__04.jpgsukasuka 动画画面sukasuka__05.jpgPixiv 69545730sukasuka__06.jpgsukasuka 官网图片sukasuka__07.jpgsukasuka 动画画面sukasuka__08.jpgPixiv 47769818sukasuka__09.jpgPixiv 78910596sukasuka__10.jpgPixiv 68527290osu_66184019.jpgPixiv 66184019（有裁剪）osu_80835141.jpgPixiv 80835141osu_80841063.jpgPixiv 80841063"},{"title":"所有标签","date":"2023-04-21T07:54:17.300Z","updated":"2023-04-21T07:54:17.300Z","comments":true,"path":"tags/index.html","permalink":"https://sweetlemon39.github.io/tags/index.html","excerpt":"","text":""},{"title":"常用站导航","date":"2020-03-01T00:00:00.000Z","updated":"2020-03-02T00:00:00.000Z","comments":true,"path":"useful-links/index.html","permalink":"https://sweetlemon39.github.io/useful-links/index.html","excerpt":"","text":"Online Judge洛谷Codeforces（主站）Codeforces（m2）Codeforces（镜像）UOJLOJAtCoderBZOJdarkBZOJVJudge 比赛CCF NOIUSACOCOCI 资料OI Wiki洛谷日报（2018） 洛谷日报（2019） 洛谷日报（2020） 休闲画廊珂研系列：中国珂学院原址备份 / 中国珂学院奈芙莲分站原址备份 / 中国珂学院新址 / 中国珂学院维基 / 中珂院书库"}],"posts":[{"title":"GXOI 2020——走在告别路上","slug":"GXOI-2020","date":"2020-06-26T00:00:00.000Z","updated":"2020-06-26T00:00:00.000Z","comments":true,"path":"GXOI-2020/","link":"","permalink":"https://sweetlemon39.github.io/GXOI-2020/","excerpt":"GXOI 2020——走在告别路上回首一望，我走在 OI 的道路上将有四年；而我的整个 OI 生涯，就将在这四年走满之时落幕。2016, 2017, 2018, 2019, 2020，这一个个数字，都承载着无数的记忆。有懵懂时输出 000 拿分的喜悦，有被“小凯的疑惑”困住的遗憾，有省选时由“不可能”到进入省队的惊喜，有在桂电的班车上感叹的青春美好，有在广州开往南宁的列车上见证的学长的告别。四年里，OI 一直陪伴着我的成长。如今，我第二次参加省选，也是最后一次参加省选。看着将要在两个月内结束的 OI 生涯，我就更想把这次省选记录下来，留作一个宝贵的留念吧。","text":"GXOI 2020——走在告别路上回首一望，我走在 OI 的道路上将有四年；而我的整个 OI 生涯，就将在这四年走满之时落幕。2016, 2017, 2018, 2019, 2020，这一个个数字，都承载着无数的记忆。有懵懂时输出 000 拿分的喜悦，有被“小凯的疑惑”困住的遗憾，有省选时由“不可能”到进入省队的惊喜，有在桂电的班车上感叹的青春美好，有在广州开往南宁的列车上见证的学长的告别。四年里，OI 一直陪伴着我的成长。如今，我第二次参加省选，也是最后一次参加省选。看着将要在两个月内结束的 OI 生涯，我就更想把这次省选记录下来，留作一个宝贵的留念吧。 Day −7-7−7结束了学校的月考，考了一个大体满意的成绩，也算是从奇怪的角度增强了一些信心吧。就这样来到机房，开启了停课时光。在机房停课的时间总是很快乐，与队友讨论奇妙的问题，增长着各个方面的知识，也能看到各种各样的景色。这一周主要以复习为主，不再学习过多的新内容，于是我欢乐地刷起了 Yosupo’s Library Checker，并刷到了（目前的）333333 名。停课期间还总结了一些代码背诵指南， 比如 后缀数组、多项式全家桶（的很少一部分），以后也许我会大力实践“编故事背代码”的方法吧（笑）。离考试还有三四天的时候觉得自己可能有点感冒，仔细思考，认识到了问题的严重性——如果体温不达标，我的 OI 生涯就将在省选前终结！怀着些许恐惧，我采取了能够采取的一切措施：在机房多穿适量的衣物，在宿舍多加适量的被子，疯狂喝水（多 喝 热 水），最后总算是将感冒治愈了。 Day −2-2−2搬运机子把考场布置好，我们当天就在考场进行模拟和压力测试。由于我调试键盘时一不小心按到了键盘上的 POWER 键，机子瞬间关机，从而发现了这种键盘的严重隐患，当天下午我们将全考场的键盘都更换了。换上的键盘回馈更足，打字更舒服。顺便吐槽我原来的键盘，那个键盘的 Z 键坏掉了，然而直到我写到 T3 打不出 size 的时候才发现这个键坏了，之前只是奇怪为什么不能撤销（bushi Day −1-1−1早上重新适应新键盘，又做了一道题。下午是试机时间，见到了来自其他学校的同学。发现了许多使用 vim 或 emacs 的大佬，而我就只会使用 gedit……嘛，也没有只会用 gedit，遇到大样例还是会用 vim 打开的；别说，hjkl, 233G, ggVG, w 这些基础我还是会的（逃 Day 111早上本想睡到 7:15，可生物钟阻止我继续睡下去，7:00 就醒了，不知道有没有打扰宿舍的同学（吃一碗充满酸笋的粉，戴好口罩前往科艺楼。准备好了开宴会的食品，看了一下 Tarjan，就进了考场。坐等了约半个小时，在桌子上打了打 Euphoria 的节奏，等着比赛开场。看到 JasonL 和 hkr04 没有来，还有些担心，好在后来都掐点到了。终于开始了。我看了一眼题目，T1 一看上去就比较简单，T2 情景太简单了一定是原题（搞不好是模板题），T3 看上去不知道怎么做。这么看来，这天的题目难度堪忧啊。 T1这题一看就可以 O(n)\\mathrm{O}(n)O(n) 解决，于是就往 dp 的方向想了想，最后优化成了贪心（bushi稍微写了写，看着挺合理的，就没有对拍。大约 30 min。 T2关于此题题目名，论洛谷和 LOJ 上的题目名称是如何在 5 分钟内双双得到更正的，论如何在洛谷上解决 LOJ 问题。看到这是道多组数据的题目，我立即在代码里写了一段话提醒自己——1234567/*!IMPORTANTIf there are multiple groups of test dataand you forget to do some cleaning,you will get a zeroas well as two rows of tears!*/简而言之，“多测不清空，爆零两行泪”。这么简单的题目情景，肯定有原题。想了想启发式合并、树链剖分等相对好写的算法，都没有结果。有想到用点分治，但一直觉得难写，而且总以为它要 log⁡2n\\log^2nlog2n，就搁置了。最后打了暴力 + k≤20k\\le 20k≤20 的部分，就先去写 T3。后来写完 T3 回来看这题，大约还有 1h 这样吧。打开菠萝包（挺干的，和着牛奶吃下去了），边吃边认真考虑了点分治，发现可做而且复杂度只有 O(nlog⁡n)\\mathrm{O}(n\\log n)O(nlogn)，就下定决心要写点分治。为了克服心中的恐惧，我反复心理暗示，区区点分治，还有 1h，有什么写不出来的？于是不管代码长度，只是写。写完只调了一下就过了样例，可本地测时结果不甚理想，最后掺着数据分治交上去了。 T3仔细思考题目，发现了这题的好几个性质，就有了一些信心。看到 2×1062\\times 10^62×106 这恐怖的数据范围，一度犹豫正解的复杂度到底是多少。最后用树状数组的 find_kth 操作糊出来了一个 O(nlog⁡n)\\mathrm{O}(n\\log n)O(nlogn) 且常数可能不那么大的做法，作差找零点那个处理也算是数学导数题给的启示吧。写数据生成器的时候十分烦躁，最后测时，极限数据运行时间达到了 7s7\\mathrm{s}7s，也只能靠信仰了。顺便吐槽一下，这题输出比输入还大，都是二三十 MB 的大小……写完这个就回去写 T2 了。 Day 222Day 1 晚上回了学校，发现机房电脑竟没有网络，玩了玩扫雷便回去休息了。早上起来仍是吃了一碗粉。第二天，大家进场的速度就比较慢了，所以等的时间就没有昨天这么长。今天一下子发了三张草稿纸，难道是要强行消耗完带来的打印纸吗？那么我们小机房每年的打印纸来源就没了拿到题仍然先扫一遍，把对题目的第一印象写到了 sol.txt\\mathtt{sol.txt}sol.txt 里面。T1 感觉离散化会很毒瘤，T2 数据范围疯狂暗示是状压 dp，T3 仍然不知道怎么做。 T1考虑了一下如何离散化，首先是把不等型条件拆成两个区间，这样所有的条件就都是区间了。当时我认为，只要涵盖所有的区间端点，再加上 000 一点，就一定可以包含答案。接下来如何确定每个点的值呢？区间修改、单点查询，先修改再查询，当然是差分数组啦。可惜“只需要涵盖区间端点”的结论是错误的，因为“异或”不一定对答案有好处，我们也许需要“避开”某个异或，因此还要提供“避开”某一个优惠条件的方法，简而言之就是往区间未覆盖的地方扩展点来离散化。这个问题是可以用对拍发现的，可当时我认为这个东西很优美，就没有怀疑它的正确性，因此今后只要有时间，就要优先对拍预期得分较高的题目。 T2首先可以发现大概是状压 dp。先把边数压到点对上（即记录 i→ji\\to ji→j 一共有多少次传递），再考虑每个点对的贡献。接着考虑“加入一个点时对答案的贡献”，发现贡献可以拆到 i,ji,ji,j 两个端点上分别计算。经过仔细的推导，又发现可以运用各种诡异的 dp 预处理和优化技巧，把预处理和 dp 的计算量都调整到 9×1089\\times 10^89×108 左右（并且还艰辛地压了空间）。好不容易写出来了，居然过不了样例；调试了半天，最后发现是 f[S]f[S]f[S] 转移到 f[S′]f[S&#x27;]f[S′] 时，计算 f[S′]f[S&#x27;]f[S′] 竟没有加上 f[S]f[S]f[S]（只加了转移那部分增加的贡献），真是有些诡异；所以应该如何调整心态以便静态调试查出问题呢……改好之后又是日常的本地超时，这我也没办法了嘛。 T3这道题看着真的没有什么思路，只好写一写状压 dp，预计是可以拿到 m≤15m\\le 15m≤15 的分数的（可不知为何写炸了）。写完暴力后一味地想发现性质，结果什么都没有发现，又赖着不肯走，坚持要写一个 m&gt;15m&gt;15m&gt;15 可用的暴力，最后证明是浪费了时间，不如去对拍 T1 或者静态查状压 dp。因此考场上如果对某道题真的没有思路，就不要死磕，不如去做一些更有意义的事。 总结总的来说，这次的考场上发挥还是不错的，也积累了关于对拍的经验。考完调整了一下心态，重新回归文化课的学习；同时也捡了一下定下的 todo list，争取在剩下的不到两个月里学到更多的东西，走好这最后一公里。最后以 Euphoria 的歌词结尾吧。啊，少年的我们如果热情的日子和约定也消逝的话变成过去的话就设法留下痕迹吧—— Jin Euphoria 友链以发布时间为序。明年五象的希望 wzy dalao：GXOI2020垫底记特别能在代码里玩梗的友校女 OIer：GXOI 2020 游记超强的高一 dalao JasonL：GXOI 2020 省选游记超强的高二 dalao Alear：GXOI 2020 游记希望今年、明年，以及今后的每一年，都能看到大家共创 GXOI 的未来！","categories":[{"name":"总结","slug":"总结","permalink":"https://sweetlemon39.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"GXOI","slug":"GXOI","permalink":"https://sweetlemon39.github.io/tags/GXOI/"}]},{"title":"英语选修八 单词表","slug":"English-8-words","date":"2020-04-10T00:00:00.000Z","updated":"2020-04-21T00:00:00.000Z","comments":true,"path":"English-8-words/","link":"","permalink":"https://sweetlemon39.github.io/English-8-words/","excerpt":"最近学文化课，单词还是背不得，太惨了。","text":"最近学文化课，单词还是背不得，太惨了。更新日志：2020-04-10 记录 Unit 1 单词2020-04-21 记录 Unit 2 单词 Unit 1单词词性释义闲话illustratevt.说明；阐明侧重于举例子、作比较或用图说明，也有“绘图”意（如画师 illustrator）；下面这幅图说明了这个过程（The figure below illustrates this process.）distinctadj.清晰的；明显的；明确的也有“不同”、“独特”的意思（two distinct integers）；和妮戈兰聊天，莫名扯到吃的，珂朵莉有了清晰的偏题感distinctionn.差别；区分；显著抽象问题和具体问题的差别（distinction between abstract and concrete problems）immigrantn.（从外国移入的）移民非法移民（illegal immigrants）live on继续存在；继续生存feed on 是以……为食；珂朵莉和艾瑟雅的那段暖心对话，艾瑟雅问珂朵莉，你肯定还想继续活下去吧straitn.海峡Taiwan Strait 台湾海峡Arcticadj.北极的；北极区的arcsin, arccos, arctan, arctic（大雾）the Arctic北极meansn.手段；方法遗迹兵器是我们唯一对抗兽的手段by means of用……办法；借助……分治求凸包：分成左右两部分计算凸包，再用一种巧妙的办法把左右凸包组合起来prehistoricadj.史前的pre- 这个前缀很常见，prehistoric times 史前时代majorityn.大多数；大半minority 是少数；尼尔斯封印了威廉大部分的记忆ministryn.（政府的）部；（全体）牧师；牧师的职责moe=Ministry of Education=jybCatholicadj. &amp; n.天主教的；天主教徒adventurern.冒险家（500 年前人族的）冒险者就是 adventurermake a life习惯于新的生活方式、工作等这个的例句很少……despiteprep.尽管；不管尽管威廉是 28 号岛本地人，但带珂朵莉散步的时候还得问路；despite all that 尽管如此，珂朵莉学会了战斗，尽管如此，她仍面临着死亡的威胁hardshipn.苦难；困苦“所谓苦难竟能深重如此吗”（灰岩皮拒绝插手政治时语）electvt.选择；决定做某事；选举某人比 select 少一个 sfederaladj.联邦制的；联邦政府的railn.铁路；扶手；（护栏的）横条Ruby on Railspercentagen.百分比percent 加个 ageItalyn.意大利Italiann. &amp; adj.意大利人（的）；意大利语（的）Denmarkn.丹麦keep up坚持；维持；沿袭（风俗、传统等）威廉的身体不能坚持；后两个义项可以算广义上的“坚持”吧boomn.（人口、贸易的）繁荣；处于经济迅速发展时期FJ 的牛奶生意繁荣（The milk business is booming）；这个词也常指爆炸aircraftn.飞行器；航空器Cambodiann.柬埔寨人；柬埔寨语Korean.韩国；朝鲜Koreann. &amp; adj.（韩国/朝鲜）（人/语）（的）Pakistann.巴基斯坦Pakistaniadj. &amp; n.巴基斯坦（人）（的）immigratevi.移入（外国定居）和 immigrant 只差几个字母immigrationn.移民；移居入境这个“移民”指的是移民这一行为，不能指人racialadj.种族的；人种的莲想为珂朵莉找跨种族爱情的书作参考crossingn.横渡；横越；十字路口；人行横道vicen. &amp; adj.代理；副职意思是 in place of; subordinate to，这个古怪的词来自拉丁语；vice versa 的意思是反之亦然（同样来自拉丁语）nephewn.侄子；外甥neph…ren？polen.地极；电极；磁极N 极是 north pole，S 极亦然applicantn.申请人applicate-applicant, participate-participant（applicate 似乎极不常用，通常都是用 apply）customsn.海关；关税；进口税指“税”时是复数，指“海关”时是单数socialistn. &amp; adj.社会主义者（的）socialismn.社会主义occurvi.发生；出现An error occurred: Internal Server Error（注意这个过去式要双写 r）cattlen.牛（总称）妮戈兰对珂朵莉说“要想自由放牧，就必须训练牛天黑时回栏”（所以是把威廉比作牛了是吧）indicatevt.指出；标示；表明；暗示back to back背靠背那张 Chtholly and Tiat back to back 的图好甜啊luggagen.行李类似的词还有 baggage 和 packageshavevt. &amp; vi.(shaved; shaved, shaven) 刮；剃君名里 Sayaka 提醒 Teshi 说要在婚礼前把胡子剃了cablen.缆绳；绳索；电缆很多网线上都标着 cable 的cable car缆车；（美）有轨缆车带网线的车（大雾）tramn.（有轨）电车apparentadj.显而易见的；显然的；表面上的apparentlyadv.显然地；显而易见地这个词是使用极为频繁的、极其恶劣的“显然”braken. &amp; vi. &amp; vt.闸；刹车；制动器踏破（break）汽车刹车（brake）（大雾）conductorn.（公车）售票员；列车员；（乐队）指挥快复习 conduct 去slipvi. &amp; n.滑动；滑行；滑跤威廉认为他谁都没能保护，让一切都从手中滑过了wharfn.码头what, scarf 的合体（大雾）bakeryn.面包房；面包厂菈琪旭在面包房“社会实践”ferryn. &amp; vt.渡船；渡口；摆渡；渡运《摆渡人》这本书就叫 ferrymanteam up with与……合作或一起工作有很多这种 … up with 的搭配hirevt. &amp; n.租用；雇用解雇是 fire（然而如果 f, h 发音分不清，就惨了）fascinatingadj.迷人的；吸引人的mark out用线画出范围；标出……界线mark down 原来是“把价格标下降”的意思（seagulln.海鸥gull 和 seagull 好像都可以指海鸥take in包括；吸收还有“欺骗”的意思，其实都是各种意义上的包括吧a great/good many许多；很多apply for申请；请示得到这个 for 千万不要漏啊nowhereadj.无处；到处都无miserableadj.痛苦的；悲惨的硝子对将也说，他和她在一起的时候会痛苦（这里看着真的痛心）punishmentn.处罚；惩罚justicen.正义；公平Friend to Lover 里面的班主任好像就叫 justice（我暴露了）mournvt. &amp; vi.哀悼；悼念；表示悲痛菈琪旭想让费奥多尔认真看待缇亚忒对他的感情，费奥多尔说难道要让我悼念她吗（唉，后来的事实是相反的）civiladj.公民的；国内的；民间的civil wars 是内战authorityn.权威；权力；(pl.)当局；官方比如公钥管理需要一个可信的权威机构（trusted authority）reformvt. &amp; vi. &amp; n.改革；革新；改造；改良graspvt. &amp; n.抓住；抓紧；掌握；领会珂朵莉生气了，手掌没有找到抓的东西，握成了拳头；不能完全掌握复杂的魔力技巧；威廉无法领会珂朵莉“对我温柔一点”这句话的意思thoughtfuladj.关切的；体贴的；深思的妖精仓库遇到危机，妮戈兰必须找理由把妖精带到 11 号岛；这时候菈琪旭做了梦需调整，妮戈兰激动地夸菈琪旭是“体贴的孩子”（当然，夸得名副其实）thankfuladj.感激的；感谢地insertvt.插入；嵌入list().insert() distinctKutori felt as if the conversation had just changed topics.“Actually, what I really wanted to eat were you guys, but that would kind of be missing the point, right? And what I really really want to eat are humans, but I haven’t gotten his permission yet…”Kutori was beginning to get the distinct impression that what they had been talking about wasn’t related to this at all. “S-seriously, wait a minute.”“…Now that I talk about this, I’m feeling hungry.” live onChtholly: My stupid disintegration never actually stopped, did it?Ithea: So, you still decided to live on, yeah?Ithea: Listen. I’ve got a story for ya, okay?（珂学第 9 讲，00:03:52~00:04:03） meansNaigurato: We call them “dug weapons” now.Naigurato: These instruments are our only means of fighting the 17 beasts.（珂学第 2 讲，00:11:45~00:11:51） by means ofIn the divide-and-conquer method, we divide the set of nnn points in Θ(n)\\mathrm{\\Theta}(n)Θ(n) time into two subsets, one containing the leftmost ⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor⌊2n​⌋ points and one containing the rightmost ⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor⌊2n​⌋ points, recursively compute the convex hulls of the subsets, and then, by means of a clever method, combine the hulls in O(n)\\mathrm{O}(n)O(n) time.（算法导论，第 33 章） majorityThat’s why I used my great skills to directly put a lid on the majority of your memories and seal it in. It was a makeshift emergency treatment, but, being my work and all, it won’t break easily.（珂学必修 5） despiteDespite Willem being a local, they ended up having to ask one of the public golems, automated guards set up in the streets by the government, for directions.（珂学必修 1）Kutori held her arm over her eyes and laughed emptily. Originally, she was meant to die at this battle. To intentionally make her Venom run berserk and burn the enemy to ashes by exploding herself. Because she had a sudden change of heart and didn’t want to accept that fate, she learned the proper way of wielding a Kaliyon from him. She learned how to fight as a Brave.Despite all that, an unexpected death now loomed right in front of her face.（珂学必修 2） hardship“Hardship is more important than all, hm?”（珂学必修 2） keep upHahaha, well, it seems I’ve gotten a lot weaker. I hadn’t held a sword in such a long time, so my body couldn’t keep up.（珂学必修 1） racial&quot;Ahaha, no need to be shy. A lot of fairies don’t even make it to puberty, so you’re lucky you can even experience love, ya know?”&quot;I-It’s not like I was looking at him in that kind of way.”&quot;… I see. I’ll go look for some stories with interracial marriage. They might be useful.”&quot;Ren!? I don’t need those!”（珂学必修 1） cattle“If you want to let your cattle graze freely, you first need to discipline them so that they return to their pens at the end of the day, right?&quot;（珂学必修 3） shaveSayaka: Oh! That reminds me, Teshi.Sayaka: Would ya please shave before the ceremony?Sayaka: I’m going on a diet for it, ya know?Teshi: She says as she’s eating a cake.Sayaka: I’ll get serious tomorrow.（你的名字，01:36:46~01:36:57） slipI never protected anything.I let it all slip through my fingers.（珂学第 12 讲，00:01:07~00:01:11） bakeryFrom what I understand,you’ve been working at that bakery for quite a while.（珂学第 7 讲，00:08:50~00:08:54） miserableShoko said…that I’ll be miserable whenever I’m with her.But I’m the one who made her unhappy.It was me…（声之形，01:31:47~01:31:58） mourn“In other words,” Feodor interrupted, “you want me to be a replacement for that man you speak of so fondly. Do you really believe I’m so easily capable of loving other people or treating them like my own daughter?”“W-well… um…” Lakish stammered weakly. “I’d like… if you could try being like that, I think?”“That girl has decided she wants to die, and even now throws herself fully into making her fate a reality. You propose that I allow the scenario to form where she gives me a tearful farewell on the day of the operation, and then she explodes most fantastically as I mourn her?”“T-that’s…” her voice cracked and broke.（珂学选修 2-1） grasp“I’m sorry,” he said, then pulled his arm back. Kutori’s hand fell away from his sleeve, clawed at the empty air, then, unable to find anything to grasp, curled up into a fist.“… idiot,” she muttered. （珂学必修 2）“Yep. You just happen to fulfill the requirements perfectly. Even though I can’t really grasp the complexities of the technique, as long as I can teach you Venom control and basic sword techniques, you should be able to master it completely.”（珂学选修 1-1）“Hey, I want to ask you something,” Kutori responded, ignoring the question.“What?”“If… this is a hypothetical question, okay? If I were to die in five days, would you be a little nicer to me?”Silence.&quot;… huh?” Willem failed to grasp what she meant.（珂学必修 1） thoughtfulOf course, a full strength embrace would end up snapping Lakish’s body in half, so Naigrat hugged her gently, as if touching a marshmallow, but firmly enough to not let her prey escape. The ultimate hug, a skill which Naigrat had acquired after much blood, sweat, and tears.“Lakish, you really are a thoughtful girl! I love you!”“Eh? Eh? Eh?” Lakish fell into deep confusion.（珂学必修 5） Unit 2单词词性释义闲话differvi.不同；相异exactadj.精确的；准确的cuttingn.剪枝；剪报；剪纸搜索的剪枝似乎不叫 cuttingtwinn. &amp; adj.双胞胎之一；成对的identicaladj.同一的；一模一样的题目里出现得极多，动词是 identifycommercialadj.商业的；贸易的艾尔佩斯是商国（commercial nation）straightforwardadj.简单的；直接的；坦率的简单的方法（straightforward method）；威廉向爱尔梅莉亚介绍珂朵莉的时候说她坦率undertakevt.(undertook; undertaken) 着手；从事；承担不同级别的冒险者承担不同的任务pay off得到好结果；取得成功；偿清一把遗迹兵器的收购价可以还清威廉的债务五十次breakthroughn.突破break through 是一个意思相近的动词短语proceduren.程序；步骤；手续Pascal 里面定义函数就用这个关键字nucleusn.原子核；中心细胞核当然也是这个词somaticadj.躯体的；肉体的；细胞体的植物体细胞杂交（plant somatic hybridization）embryon.胚；胚胎；萌芽时期胚胎工程（embryo engineering）carriern.携带者；搬运工；运输工具castvt.(cast; cast) 扔；投；掷史旺千年都不会抛弃白袍子；尼尔斯减轻了艾陆可施在身上的诅咒cast down使失望；使沮丧菲儿沮丧地垂下了眼altogetheradv.总共；完全地arbitraryadj.任意的词源与 arbiter 有关，意义与 ∀\\forall∀ 有关faten.命运；天命著名游戏系列（correctionn.改正objectvi.反对；不赞成object 当然还有对象的意思，难道这说明对象常常反对（大雾）objectionn.不赞成；反对；异议impactn.撞击；冲击；巨大的影响正碰（direct impact）；珂朵莉准备着与地面撞击（其实是与威廉撞击）；艾瑟雅安慰珂朵莉，魔力中毒不会对她产生不利影响mediumn.(pl media) 媒介；手段；工具medium 同时有“中等的”意；这么变复数的还有 stadium - stadiums / stadia, bacterium - bacteria（都是拉丁语惹的祸）the media大众传播媒体obtainvt.获得；赢得印刷术使书籍更容易获得；和平不是轻易就能获得的attainvt.获得；到达（水平、年龄、状况等）证明你的程序达到了这个时间复杂度；计算这个和式可以得到 Θ(n2)\\Theta(n^2)Θ(n2) 的复杂度；如果相信了“你还不幸福”的话，不管多幸福，都会认为自己还未获得幸福moraladj.道德（上）的；伦理的奈芙莲说精神支柱很重要；moral 还有“寓意”的意思，比如the moral of this storyconservativeadj.保守的；守旧的conservative vector field（保守向量场）forbidvt.(forbade, forbad; forbidden) 禁止；不准403 Forbiddenaccumulatevt. &amp; vi.积累；聚积雪花在地上聚积；瑟尼欧里斯上积了灰；计算误差会积累in favour of赞成；支持支持选择 Java 的主要原因是它的大整数类side road旁路；支线；岔道（&lt;美&gt; sidewalk）constitutionn.宪法；章程浮游大陆群宪章：the Constitution of Regul Airecompulsoryadj.必须做的；义务的；强迫的；强制的operan.歌剧；歌剧团；歌剧院著名浏览器名chorusn.合唱；合唱队loafn.一条（面包）著名的 ves 复数词；将也买面包喂金鱼flourn.面粉威廉做黄油蛋糕当然要买面（main）粉owevt.欠（账、钱、人情等）；归功于大贤者认为他欠黄金妖精们的人情；owing to 相当于 because of（或者是 thanks to）shortlyadv.立刻；不久缇亚忒的调整很快就会结束retirevi.退休；离开bothervt. &amp; vi. &amp; n.打扰；操心；烦扰(be) bound to (do) …一定或注定（做）assumptionn.假定；设想做假设（we make an assumption）regulationn.规则；规章；法规nonsensen.胡说；无稽之谈；废话让黄金妖精不再做无意义的牺牲popularityn.受人喜爱；流行准勇者很受人们欢迎strikevt. &amp; vi. &amp; n.(struck, struck) 打；撞击；罢工彗星将要分裂并撞击丝守镇strike … into one’s heart使……刻骨铭心bisonn.北美或欧洲野牛calfn.小牛；牛犊from time to time不时；偶尔初中这个词组有一个释义叫“间或”（谁读谁知道）bring back to life使复生；使复活initialadj.最初的；开始的初值（initial value）DNA脱氧核糖核酸vainadj.虚荣的；自负的；徒劳的in vain白费力气；枉费心机珂朵莉不愿接受她的前辈们都白白牺牲了resistvt.抵抗；对抗我们无法抵抗好奇心（果然年轻妖精就是有活力）drawbackn.缺点；不利条件莱耶尔市的邮政服务很棒，但不是没有缺点merelyadv.仅；只；不过黄金妖精在文件上只是“物件”restorevt.恢复；使恢复原状；重建恢复到出厂设置（On iPhone, restore content and settings from a backup, or restore iPhone to factory settings.）aurochsn原牛（古代欧洲野牛，已灭绝）decorationn.装饰【cz &amp; kkk &amp; ltt】日常 decorationunableadj.不能的；不会的great aukn.大海雀（已灭绝）feathern.羽毛quaggan.白氏斑马（已灭绝）fairlyadv.公平地；相当地工作得相当好（work fairly well）in good/poor condition状况很好（坏）注意这里零冠词；圣剑的状况很差turkeyn.火鸡土耳其火鸡dyevt. &amp; n.给……染色；染；染色剂现在分词是 dyeing（这个就不能去 e 了）；妮戈兰劝珂朵莉不要把红发染掉；人类用什么染料也不能把头发染成黄金妖精的样子clawn.爪；脚爪adorevt.崇拜；爱慕；喜爱adorable 有可爱的意思；威廉和艾瑟雅的一段对话里有大量的 adore 以不同的形式出现hatchvt. &amp; vi.孵出；孵卵；孵化钡硒提出了一个危险的计划（hatches a risky plan）reasonableadj.合情理的；讲道理的；公道的 straightforward“That’s too far of a jump…” Willem gave Almaria a little poke on the forehead. “It’s someone you don’t know. She’s straightforward and dedicated and kind and spoiled and uncompromising and simple and an idiot and simple and an idiot.” He didn’t think he said too much. He could even add on another set of simple and an idiot.（珂学必修 4） undertakeAt the time he was only level 9, so his guild would’ve placed restrictions on the areas he could venture into or the kind of missions he could undertake, forbidding him from fighting overly powerful monsters.（珂学选修 1-1） pay offEight million. That could pay off Willem’s sizable debt fifty times and still leave some left over.（珂学必修 1） castI would never cast my cape aside, not in a thousand years!（珂学第 6 讲，00:07:03~00:07:06）The guy that sealed my memory said he chipped away a little at the curse cast on Elq’s body.（珂学必修 5） cast down“… I see.” Firu cast her eyes down.（珂学必修 2） impactThe two bodies, one human and one cat, continued their descent. The faint light radiating from the girl futilely danced about in the air before disappearing. She didn’t even have time to scream. The stone pavement, which had seemed so far away a moment ago, grew closer at an alarming rate. She inadvertently tightened her grip on the cat, which let out a shriek. Helpless against the pull of gravity, the girl closed her eyes and braced for impact.A girl fell out of the sky. Judging from her figure, she was probably in her early teens, and also falling pretty fast. At that rate, she would soon have a violent collision with the stone covered streets, leaving a gruesome scene unfit for a peaceful early afternoon.（珂学必修 1）“It’s okay. Even if the encroachment is showing up a little now, your body is still pretty young. As long as ya don’t go too crazy, it shouldn’t progress much further. There won’t be any harmful impact to your everyday life. I know someone who’s suffered from it before quite well, so I can guarantee you that.”（珂学必修 2） obtainIn their current time setting, large printing machines were already being widely used, making books much easier to obtain compared to earlier times when each one needed to be copied by hand.（珂学必修 4）Conflict is the natural fate of all living beings. Peace is unnatural, and thus it is valuable. That which is unnatural cannot be obtained by simply sitting around. Only after expending the necessary effort and paying the necessary sacrifices to suppress instinct and pursue reason can it first be obtained. Precisely because of its difficulty to obtain, peace is seen as such a beautiful thing.（珂学必修 5） attainProve that your algorithm attains this time bound.（算法导论英文版 706 页）When we evaluated this summation, we attained a bound of Θ(n2)\\mathrm{\\Theta}(n^2)Θ(n2) on the worst-case running time of the algorithm.（算法导论英文版 1145 页）“It’s simple. Just tell them ‘You’re unhappy.’” Feodor waved his hands. “I can already hear you trying to make it sound like a good thing, ‘You can be more happy’, or ‘I’ll make you happy’, but they’re all in the same vein. Though that might sound good, you’d just be claiming that all their happiness is fake, and your brand of happiness is the real deal. However happy someone was before, once they’ve believed those words, they’ll start thinking that they might not have attained happiness yet.”（珂学选修 2-2） moral“Is that something to be happy about?” Aiseia asked. “Also, Nephren, you seem to be playing the role of a pet. Is that okay with you?”“Moral support is important.”（珂学必修 3） accumulateLooking down, he noticed for the first time that Nephren was walking alongside him. His inner debate had blinded him that much. He also noticed the snowflakes starting to accumulate on the ground.（珂学必修 4）Of course, there weren’t actually any stains that stood out from the blade’s glinting metal; it had just accumulated a layer of dust thanks to it being stored for a time.（珂学选修 1-1）Strassen’s algorithm is not quite as numerically stable as SQUARE-MATRIX-MULTIPLY. In other words, because of the limited precision of computer arithmetic on noninteger values, larger errors accumulate in Strassen’s algorithm than in SQUARE-MATRIX-MULTIPLY.（算法导论英文版 112 页） in favour ofThe main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger.（Codeforces 66, Codeforces Beta Round #61 (Div. 2), A. Petya and Java） loafHey there, Shoko.So today, I was able to score some really great bread.See! It’s awesome, like you’re awesome.Oh like really great bread is awesome, This loaf here is just like you.（声之形，01:26:30~01:26:45） flourHe departed for town early in the morning to do some ingredient shopping. His loot included a hefty amount of flour, butter, eggs, milk, and sugar. Small quantities of honey, nuts, and dried fruits were also stuffed in the bag.（珂学必修 3） owe“I owe you girls something.” He smiled with just a slight hint of sorrow.（珂学必修 5） shortlyAnyway, Tiat will be done shortly.She’s a sweet, responsible girl.（珂学第 4 讲，00:11:35~00:11:40） nonsenseThere has to be a better way to battle these beasts than what you’ve been doing, hasn’t there?A way with less sacrifice, with less self-destruction nonsense.（珂学第 3 讲，00:06:25~00:06:34） popularityQuasi Braves, second in strength only to the Church appointed Regal Brave, humanity’s greatest warrior, have enormous popularity with the public.（珂学必修 1） strikeThe comet is going to split in two and strike the town?（你的名字，01:08:54~01:08:57） in vainBecause that would mean that the older fairies all died in vain!（珂学第 3 讲，00:16:37~00:16:40） resistYou should have known better. We don’t have the kind of power to resist Curiosity!（珂学第 1 讲，00:17:58~00:18:02） drawbackAlthough the mail golem service was convenient, it was, however, not without drawbacks.（珂学选修 2-2） merelyThe young girls, merely ‘objects’ according to the documents, live out their days with an enthusiasm and energy uncharacteristic of inanimate weapons.（珂学必修 2） in good/poor conditionAs he expected, all of the swords were in poor condition.（珂学必修 1） dyeAnd don’t get any ideas about dyeing your hair.I doubt that it’s gonna bother Willem.（珂学第 7 讲，00:11:12~00:11:16）An Emnetwyte would never have been able to achieve such a naturally vivid color, no matter what dye he used.（珂学必修 1） adoreI didn’t mean to offend, it’s my opinion.I just think girls are cuter.It reflects the way they want to be loved.They adorably wish to be adored.Boys are cute too, just in a smellier way.And adorable applies to us?Come on, as a race, you’re generally all born in this form, right?（珂学第 3 讲，00:14:02~00:14:17） Unit 4单词词性释义闲话adaptationn.适应（性）；改编本“5 Games That Deserve an Anime Adaptation”classicadj. &amp; n.经典的；第一流的；经典著作奈芙莲第一次吃栗子时犯了典型的初学者错误（没等栗子凉了就吃）captionn.（图片上的）说明文字；（电视、电影）字幕；（杂志等文章的）标题；题目“the ﬁgure caption”；Y2b 上的字幕就是 caption；此外 VB 的 Label 控件有 caption 属性plotn.情节；阴谋威廉说他是邪恶的人族，肯定会谋划一些大事（professorn.教授他 apply for professor，好几百个教授一致通过（逃phoneticsn.语音学fong ne tics！coloneln.（陆军）上校fatefuladj.重要的；决定性的；命中注定的莉莉娅想起她第一次遇到威廉的那个重要的冬天（嘲笑他的那个冬天）whistlevi. &amp; n.吹口哨；发出汽笛声；口哨声；汽笛声The one who whistledgarmentn.（一件）衣服（外套、裙、袍等）；(pl) 服装woollenadj.毛纺的；纯毛的（&lt;美&gt; woolen）注意区分 woolen 和 woodenhesitatevi.犹豫；踌躇如果有任何不快，不要犹豫，马上来找我（奈芙莲真的默默在关心身边的朋友）uncomfortableadj.不舒服的；不安的；不自在的uncomfortablyadv.不舒服地；不自在地troublesomeadj.带来麻烦的；使人心烦的在威廉给兰朵露可按摩时，她很“带来麻烦”（笑）walletn.皮夹；钱包Apple Walletoutcomen.结果；效果奈芙莲的魔力过度发挥，等待她的似乎只有“开门”这一结果thiefn.小偷；贼handkerchiefn.手帕；手绢；纸巾费奥多尔让缇亚忒回忆起了往事而落泪，他给缇亚忒递了一只手帕并道歉disguisevt. &amp; n.伪装；假扮；遮掩珂朵莉说她的帽子只是为了在 28 号岛掩盖她的无征种身份in disguise伪装（的）；假扮（的）这是一个伪装的三项级数mistakenadj.（见解或判断上的）错误的；不正确的费奥多尔甚至不愿意说明潘丽宝是错的brilliantadj.光辉灿烂的；杰出的；才华横溢的珂朵莉光辉灿烂的蓝发使她与众不同classifyvt.把……分类；把……归类根据一定的标准对动态规划进行分类remarkn. &amp; vt. &amp; vi.谈论；言论；评述；评论；说起betrayvt.显露出（本来面目）；背叛upperadj.（位置或地位）较高的；级别较高的extraordinaryadj.不同寻常的；非凡的condemnvt.谴责；使……处于不幸（不愉快）的状态guttern.排水沟；阴沟；贫民区properlyadv.适当地；恰当地pass … of as …（把某人）改变或冒充成……duchessn.公爵夫人；女公爵ambassadorn.大使；使节acquaintancen.相识；了解；熟人make one’s acquaintance结识；与……相见handfuln.一把；少量amazementn.惊讶；惊愕in amazement震惊；惊讶fortunen.机会；运气；大笔的钱authenticadj.真实的；真正的；可信的；可靠的generally speaking一般来说statusn.身份；地位；职位superioradj. &amp; n.优秀的；较高的；上级的；上级；长官in terms of …就……来说；从……角度disapprovevt. &amp; vi.不赞成；反对；认为不好robvt.抢劫；盗窃；剥夺antiqueadj. &amp; n.古时的；（因古老、稀少而）珍贵的；文物；古董；古玩musicaladj. &amp; n.音乐的；喜爱音乐的；音乐喜剧stockingn.长袜bellievern.信徒；教徒Buddhismn.佛教Buddhistn. &amp; adj.佛教徒；佛教的Buddhan佛voweln.元音；元音字母cookien.饼干teapotn.茶壶creamn.奶油；面霜nailn.指甲；钉子show … in带或领……进来waxn. &amp; vt.蜡；蜜蜡；上蜡diskn.磁盘wax disk旧式唱片shabbyadj.破旧的；寒酸的curtsyvi. &amp; n.(also curtsey) 行屈膝礼；（女子行的）屈膝礼shillingn.先令（1971 年前的英国货币单位，旧币的 12 便士）refereen.裁判员；仲裁者compromisen. &amp; vi.妥协；折衷horribleadj.可怕的；恐怖的laundryn.洗衣店；洗衣房；（待洗的或洗好的）衣服bathtubn.浴缸；澡盆sobvi. &amp; n.啜泣（声）；抽噎（声）waistn.腰；腰部；腰围vestn.背心；内衣disgustingadj.使人反感的；令人厌恶的once more再一次in need of需要……heartilyadv.尽情地；热心地；痛快地overlookvt.俯视；忽视；不理会alphabetn.字母表effectiveadj.有效的fadevi. &amp; vt.（使）褪色；减弱；逐渐消失fade out（声音、画面）逐渐模糊；渐淡 classicMeanwhile, Nephren, who apparently stuffed her chestnuts into her mouth without waiting for them to cool down first, now had a bright red face and seemed to be in a daze. Lucie had to run off to the nearest public well and get some water for her. Watching Nephren make the classic beginner mistake, Willem recalled fond and nostalgic memories.（珂学必修 4） plotI’m an evil Emnetwyte, after all. If I’m going to plot something, it’s going to be a larger scale crime.（珂学必修 3） fatefulShe recalled that fateful winter when she’d first seen Willem practicing in that forest.（珂学选修 1-1） hesitate“If you ever feel like talking about it, don’t hesitate to come to me. I may not be able to do much, but I can at least stay by your side.”With that, Nephren stopped talking. “Ah… thanks.” First Aiseia, now Nephren. Kutori really did have amazing friends. Forgetting her situation for a moment, she was overcome with a happy feeling.（珂学必修 3） troublesomeLantolq, on the other hand, proved to be troublesome for an entirely different reason. Everytime Willem pressed his fingers into her back, she let out a weirdly suggestive moan. Well, Lantolq did seem very mature for her age, but whenever he heard that voice Willem got the feeling that they were doing something inappropriate and had to pause his work.（珂学必修 3） outcomeNephren’s body was hot as an inferno, yet at the same time cold as ice. Needless to say, she had ignited too much Venom. She had turned her back on life and abused that terrible power, knowing that each step took her closer to death. Now, there was only one possible outcome which awaited her: berserk. The immense, unchecked power emanating from her would blow away everything in the area with enough force to destroy a large Teimerre all at once in an overwhelming manifestation of destruction.（珂学必修 3） handkerchief“…Sorry.” He took out a handkerchief and held it out to her in apology.（珂学选修 2-1） disguise“Your new hat.”The sudden change of topic surprised the lost in thought Kutori, who almost fell out of her chair.“You’re taking pretty good care of it, aren’t ya? You stuffed it in your closet and never used it since, keeping it nice and clean.”“I-It’s not like that means anything! That hat’s only useful as a disguise for when I leave the island… I don’t need it when I’m here! Besides, why are you even bringing that up now?!”（珂学必修 1）So it is really a trinomial coefficient in disguise.（算法导论） mistakenFight on, Lakish, he cheered her on silently. As for Panival – while he wouldn’t go as far as to say she was mistaken, he at least wished she wouldn’t talk about him as if there was something wrong about him as a living being.（珂学选修 2-2） brilliantThe blue haired girl led him around. Getting another chance to look at her up close, Willem readjusted his age estimate to about fifteen, based on human standards. A markless, she had a body and features similar to those of a human. What set her apart was her brilliant blue hair, evocative of a clear spring sky. An Emnetwyte would never have been able to achieve such a naturally vivid color, no matter what dye he used.（珂学必修 1） classifyGalil and Park [125] classify dynamic-programming algorithms according to the size of the table and the number of other table entries each entry depends on.（算法导论）","categories":[{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"英语","slug":"英语","permalink":"https://sweetlemon39.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://sweetlemon39.github.io/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"听说看过这篇文章的人，99 % 都背得了“常见的与对数有关的不等式”！","slug":"how-to-recite-log-inq","date":"2020-04-02T00:00:00.000Z","updated":"2020-04-02T00:00:00.000Z","comments":true,"path":"how-to-recite-log-inq/","link":"","permalink":"https://sweetlemon39.github.io/how-to-recite-log-inq/","excerpt":"听说“常见的与对数有关的不等式”这一页课件很难背？假的！看完这篇文章，你就能背完那一页的不等式！","text":"听说“常见的与对数有关的不等式”这一页课件很难背？假的！看完这篇文章，你就能背完那一页的不等式！先来个列表看看吧：ex≥x+1⇔x≥ln⁡(x+1)⇔x−1≥ln⁡xe^x\\ge x+1\\Leftrightarrow x\\ge \\ln (x+1)\\Leftrightarrow x-1\\ge \\ln xex≥x+1⇔x≥ln(x+1)⇔x−1≥lnx，e1−x≤1x (x&gt;0)e^{1-x}\\le \\cfrac{1}{x}\\ (x&gt;0)e1−x≤x1​ (x&gt;0)x1+x&lt;ln⁡(1+x)&lt;x (x&gt;0) ⇔ x−1x&lt;ln⁡x&lt;x−1 (x&gt;1)\\cfrac{x}{1+x}&lt;\\ln (1+x)&lt;x\\ (x&gt;0)\\ \\Leftrightarrow\\ \\cfrac{x-1}{x}&lt;\\ln x&lt;x-1\\ (x&gt;1)1+xx​&lt;ln(1+x)&lt;x (x&gt;0) ⇔ xx−1​&lt;lnx&lt;x−1 (x&gt;1)2xx+2&lt;ln⁡(x+1)&lt;12(x+xx+1) (x&gt;0)\\cfrac{2x}{x+2}&lt;\\ln (x+1)&lt;\\cfrac{1}{2}\\left(x+\\cfrac{x}{x+1}\\right)\\ (x&gt;0)x+22x​&lt;ln(x+1)&lt;21​(x+x+1x​) (x&gt;0)x−12x2&lt;ln⁡(1+x)&lt;x (x&gt;0)x-\\cfrac{1}{2}x^2&lt;\\ln (1+x)&lt;\\sqrt{x}\\ (x&gt;0)x−21​x2&lt;ln(1+x)&lt;x​ (x&gt;0)∀a&gt;0,b&gt;0,a≠b\\forall a&gt;0,b&gt;0,a\\neq b∀a&gt;0,b&gt;0,a​=b，有 ab&lt;a−bln⁡a−ln⁡b&lt;a+b2\\sqrt{ab}&lt;\\cfrac{a-b}{\\ln a-\\ln b}&lt;\\cfrac{a+b}{2}ab​&lt;lna−lnba−b​&lt;2a+b​2x−1x+1&lt;ln⁡x&lt;12(x−1x) (x&gt;1)2\\cfrac{x-1}{x+1}&lt;\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x}\\right)\\ (x&gt;1)2x+1x−1​&lt;lnx&lt;21​(x−x1​) (x&gt;1)六组不等式，看上去很吓人！怎么才能记住呢？读下去就知道了。提示：点击文中的图片可以查看全图。 指数 泰勒展开系列泰勒（马克劳林）展开 ex=1+x+x22+x36+⋯+xnn!+⋯e^x=1+x+\\cfrac{x^2}{2}+\\cfrac{x^3}{6}+\\cdots+\\cfrac{x^n}{n!}+\\cdotsex=1+x+2x2​+6x3​+⋯+n!xn​+⋯ 的衍生不等式，可以描述“exe^xex 在 x≥0x\\ge 0x≥0 时增长得很快”的特征。高考最常用的是 ex≥x+1e^x\\ge x+1ex≥x+1，当且仅当 x=0x=0x=0 时等号成立。那么如何描述“exe^xex 在 x&lt;0x&lt;0x&lt;0 时缓慢趋于 000”的特征呢？“缓慢趋于 000”的意思就是倒数趋于正无穷，因此上一个式子取倒数就可以得到 e−x≤1x+1 (x&gt;−1)e^{-x}\\le \\cfrac{1}{x+1}\\ (x&gt;-1)e−x≤x+11​ (x&gt;−1)，将 x=x′−1x=x&#x27;-1x=x′−1 代入得 e1−x′≤1x′ (x′&gt;0)e^{1-x&#x27;}\\le \\cfrac{1}{x&#x27;}\\ (x&#x27;&gt;0)e1−x′≤x′1​ (x′&gt;0)。小于另一个缓慢趋于 000 的函数，这就可以刻画这一特征。 切线系列ex≥x+1e^x\\ge x+1ex≥x+1 是在 000 处的切线不等式，有时还会用到在 111 处的切线不等式 ex≥exe^x\\ge exex≥ex，通常在式中明确出现 eee 时使用。如果有十足的把握，也可以尝试在其他地方的切线。 次数系列exe^xex 可以升到任意次，这在取点时比较好用。对一切 x≥0x\\ge 0x≥0，我们有 ex&gt;xe^x&gt;xex&gt;x 和 ex&gt;x2e^x&gt;x^2ex&gt;x2，但是三次以上就不行了；事实上，ex≥xee^x\\ge x^eex≥xe，可以通过取对数进行证明。当然，对任意大的 nnn，总存在充分大的 x0x_0x0​，使得 x&gt;x0x&gt; x_0x&gt;x0​ 时 ex&gt;xne^x&gt;x^nex&gt;xn。证明这一点有一个简单的方法，就是先证 ex&gt;xn+1(n+1)! (x≥0)e^x&gt;\\cfrac{x^{n+1}}{(n+1)!}\\ (x\\ge 0)ex&gt;(n+1)!xn+1​ (x≥0)，然后取 xn+1(n+1)!&gt;xn\\cfrac{x^{n+1}}{(n+1)!}&gt;x^n(n+1)!xn+1​&gt;xn 的点即可。 对数 泰勒展开系列ln⁡(x+1)=x−x22+x33−⋯+(−1)n+1xnn+⋯\\ln (x+1)=x-\\cfrac{x^2}{2}+\\cfrac{x^3}{3}-\\cdots+(-1)^{n+1}\\cfrac{x^n}{n}+\\cdotsln(x+1)=x−2x2​+3x3​−⋯+(−1)n+1nxn​+⋯最常用的还是 ln⁡(x+1)≤x\\ln (x+1)\\le xln(x+1)≤x，当且仅当 x=0x=0x=0 时等号成立；常见的变形是令 x′=x+1x&#x27;=x+1x′=x+1，则 ln⁡x′≤x−1\\ln x&#x27;\\le x-1lnx′≤x−1。当然有时会用到 ln⁡(x+1)&gt;x−x22 (x&gt;0)\\ln (x+1)&gt;x-\\cfrac{x^2}{2}\\ (x&gt;0)ln(x+1)&gt;x−2x2​ (x&gt;0)；这个式子在 −1&lt;x&lt;0-1&lt;x&lt;0−1&lt;x&lt;0 时不等号反向。如果我们需要对数的下界怎么办呢？在 ln⁡x≤x−1\\ln x\\le x-1lnx≤x−1 中，令 t=1xt=\\cfrac{1}{x}t=x1​，那么就有 −ln⁡t≤1t−1-\\ln t\\le \\cfrac{1}{t}-1−lnt≤t1​−1，也就是 ln⁡t≥1−1t\\ln t\\ge 1-\\cfrac{1}{t}lnt≥1−t1​。同理有 ln⁡(t+1)≥tt+1\\ln (t+1)\\ge \\cfrac{t}{t+1}ln(t+1)≥t+1t​。这样我们得到了一组 ln⁡x\\ln xlnx 的上下界：x−1x≤ln⁡x≤x−1\\cfrac{x-1}{x}\\le \\ln x\\le x-1xx−1​≤lnx≤x−1，等号成立当且仅当 x=1x=1x=1。这组上下界的图如下：顺带说一句，这个泰勒展开的收敛半径是 111，也就是至多只能用来暴力加和估算 ln⁡2\\ln 2ln2，但是求起来也很痛苦。下面附上一个巧妙地估算 ln⁡2\\ln 2ln2 的过程。ln⁡2=1−12+13−14+⋯\\ln 2=1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+\\cdotsln2=1−21​+31​−41​+⋯而 1n−1n+1+1n+2−1n+3+⋯=1n(n+1)+1(n+2)(n+3)+⋯&lt;1(n−0.5)(n+1.5)+1(n+1.5)(n+3.5)+⋯=12n−1\\frac{1}{n}-\\frac{1}{n+1}+\\frac{1}{n+2}-\\frac{1}{n+3}+\\cdots=\\frac{1}{n(n+1)}+\\frac{1}{(n+2)(n+3)}+\\cdots&lt;\\frac{1}{(n-0.5)(n+1.5)}+\\frac{1}{(n+1.5)(n+3.5)}+\\cdots=\\frac{1}{2n-1}n1​−n+11​+n+21​−n+31​+⋯=n(n+1)1​+(n+2)(n+3)1​+⋯&lt;(n−0.5)(n+1.5)1​+(n+1.5)(n+3.5)1​+⋯=2n−11​（最后一个等号是裂项）因此 ln⁡2&lt;1−12+13−14+15−16+17−18+117&lt;0.6934\\ln 2&lt;1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+\\frac{1}{5}-\\frac{1}{6}+\\frac{1}{7}-\\frac{1}{8}+\\frac{1}{17}&lt;0.6934ln2&lt;1−21​+31​−41​+51​−61​+71​−81​+171​&lt;0.6934且有 ln⁡2&gt;1−12+13−14+15−111&gt;0.6924\\ln 2&gt;1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+\\frac{1}{5}-\\frac{1}{11}&gt;0.6924ln2&gt;1−21​+31​−41​+51​−111​&gt;0.6924还可以用比较容易收敛的 ln⁡1+x1−x=2x+2x33+2x55+⋯\\ln \\cfrac{1+x}{1-x}=2x+\\cfrac{2x^3}{3}+\\cfrac{2x^5}{5}+\\cdotsln1−x1+x​=2x+32x3​+52x5​+⋯ 来计算（把泰勒展开中的 xxx 换为 −x-x−x，两式相加即得）。 次数系列ln⁡(x)\\ln(x)ln(x) 在渐进意义上小于 xa (a&gt;0)x^a\\ (a&gt;0)xa (a&gt;0)，但能使得 ∀x&gt;0,ln⁡(x+1)≤xa\\forall x&gt;0,\\ln (x+1)\\le x^a∀x&gt;0,ln(x+1)≤xa 的 aaa 的取值范围是什么呢？这个问题好像很难解，分离参数会得到一个诡异的式子，画图可以得到 aaa 的范围大概是 0.3798312149&lt;a≤10.3798312149&lt;a\\le 10.3798312149&lt;a≤1；不过有用的可能只有 a=1a=1a=1 和 a=12a=\\frac{1}{2}a=21​，即 ln⁡(x+1)&lt;x\\ln (x+1)&lt; xln(x+1)&lt;x 和 ln⁡(x+1)&lt;x\\ln (x+1)&lt;\\sqrt{x}ln(x+1)&lt;x​。 对数平均不等式系列我们都知道对数平均不等式，那与它对应的一组 ln⁡x\\ln xlnx 的上下界是什么呢？我们试图从头开始理解这一组上下界。下面，我们采用定积分的方法。我们知道，∫1xdx=ln⁡x+C\\int \\frac{1}{x} \\mathrm{d}x=\\ln x+C∫x1​dx=lnx+C，因此或许可以用 y=1xy=\\frac{1}{x}y=x1​ 的图象下的面积对 ln⁡x\\ln xlnx 进行放缩。对 x&gt;0x&gt;0x&gt;0，我们考虑 ∫xx+11xdx\\int ^{x+1}_{x} \\frac{1}{x} \\mathrm{d}x∫xx+1​x1​dx。首先，这个值当然等于 ln⁡x+1x=ln⁡(1+1x)\\ln \\frac{x+1}{x}=\\ln (1+\\frac{1}{x})lnxx+1​=ln(1+x1​)，如图中的蓝色区域所示。那么蓝色区域的面积显然小于下图中红色矩形的面积 1x\\cfrac{1}{x}x1​，且大于绿色矩形的面积 1x+1\\cfrac{1}{x+1}x+11​（注意这两个矩形的宽都是 111）。根据面积的大小关系，我们就可以得到 1x+1&lt;ln⁡(1+1x)&lt;1x (x&gt;0)\\cfrac{1}{x+1} &lt; \\ln (1+\\cfrac{1}{x})&lt; \\cfrac{1}{x}\\ (x&gt;0)x+11​&lt;ln(1+x1​)&lt;x1​ (x&gt;0)。令 t=1xt=\\cfrac{1}{x}t=x1​，我们就可以得到 tt+1&lt;ln⁡(1+t)&lt;t (t&gt;0)\\cfrac{t}{t+1}&lt; \\ln (1+t)&lt; t\\ (t&gt;0)t+1t​&lt;ln(1+t)&lt;t (t&gt;0)，即 x−1x&lt;ln⁡x&lt;x−1 (x&gt;1)\\cfrac{x-1}{x}&lt; \\ln x&lt; x-1\\ (x&gt;1)xx−1​&lt;lnx&lt;x−1 (x&gt;1)，也就是泰勒展开系列不等式的一部分！如何得到另一部分（0&lt;x&lt;10&lt;x&lt;10&lt;x&lt;1）呢？令 t=1xt=\\cfrac{1}{x}t=x1​（这个 ttt 和上一段的 ttt 不一样，只是用了同一个符号而已），可以得到 1t−11t&lt;−ln⁡t&lt;1t−1 (0&lt;t&lt;1)\\cfrac{\\cfrac{1}{t}-1}{\\cfrac{1}{t}}&lt; -\\ln t&lt; \\cfrac{1}{t}-1\\ (0&lt;t&lt;1)t1​t1​−1​&lt;−lnt&lt;t1​−1 (0&lt;t&lt;1)，调整之后仍然是 t−1t&lt;ln⁡t&lt;t−1 (0&lt;t&lt;1)\\cfrac{t-1}{t}&lt;\\ln t&lt;t-1\\ (0&lt;t&lt;1)tt−1​&lt;lnt&lt;t−1 (0&lt;t&lt;1)，即不等式方向没有改变。再补上 x=1x=1x=1 这一个点。x=1x=1x=1 时这三个式子都是 000，所以取到等号。综上，我们可以根据面积关系，并加以代数变形，证明x−1x≤ln⁡x≤x−1\\cfrac{x-1}{x}\\le \\ln x\\le x-1xx−1​≤lnx≤x−1，等号成立当且仅当 x=1x=1x=1。这种方法能不能“生产”出别的不等式呢？考虑这个问题：这两个矩形的面积和曲边梯形的面积差得比较大，能不能有更精确的呢？首先，我们可以考虑用梯形进行近似。如下图，蓝色区域的面积显然小于橙色梯形的面积 12(1x+1x+1)\\cfrac{1}{2}\\left(\\cfrac{1}{x}+\\cfrac{1}{x+1}\\right)21​(x1​+x+11​)，这和 y=1xy=\\frac{1}{x}y=x1​ 是下凸函数有关。接着，我们还可以取中点进行矩形近似，也就是作以 1x+(x+1)2\\cfrac{1}{\\cfrac{x+(x+1)}{2}}2x+(x+1)​1​ 为高的矩形，如下图中的粉色矩形。这个矩形的面积就是 22x+1\\cfrac{2}{2x+1}2x+12​。粉色区域和蓝色区域的面积大小关系如何呢？设 m=x+12m=x+\\cfrac{1}{2}m=x+21​，那么对于 Δ∈(0,12]\\Delta\\in (0,\\cfrac{1}{2}]Δ∈(0,21​]，有 1m−1m+Δ&lt;1m−Δ−1m\\cfrac{1}{m}-\\cfrac{1}{m+\\Delta}&lt;\\cfrac{1}{m-\\Delta}-\\cfrac{1}{m}m1​−m+Δ1​&lt;m−Δ1​−m1​（同样是由于下凸），也就是与中点距离相同的情况下，右边的小块（QBS\\mathrm{QBS}QBS）的“高度差”比左边小块（QAR\\mathrm{QAR}QAR）的“高度差”小。用类似“祖暅原理”的思想，可以得到右边小块的面积小于左边小块的面积（看图也可以看出来），也就是蓝色区域的面积略大。根据面积关系 粉色&lt;蓝色&lt;橙色\\text{粉色}&lt;\\text{蓝色}&lt;\\text{橙色}粉色&lt;蓝色&lt;橙色，我们可以得到 22x+1&lt;ln⁡(1+1x)&lt;12(1x+1x+1) (x&gt;0)\\cfrac{2}{2x+1}&lt;\\ln(1+\\cfrac{1}{x})&lt;\\cfrac{1}{2}\\left(\\cfrac{1}{x}+\\cfrac{1}{x+1}\\right)\\ (x&gt;0)2x+12​&lt;ln(1+x1​)&lt;21​(x1​+x+11​) (x&gt;0)。像上面一样令 t=1xt=\\cfrac{1}{x}t=x1​，可以得到 2tt+2&lt;ln⁡(1+t)&lt;12(t+t1+t) (t&gt;0)\\cfrac{2t}{t+2}&lt;\\ln (1+t)&lt;\\cfrac{1}{2}(t+\\cfrac{t}{1+t})\\ (t&gt;0)t+22t​&lt;ln(1+t)&lt;21​(t+1+tt​) (t&gt;0)；进一步令 x=t+1x=t+1x=t+1 得到 2x−1x+1&lt;ln⁡x&lt;12(x−1x) (x&gt;1)2\\cfrac{x-1}{x+1}&lt;\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x} \\right)\\ (x&gt;1)2x+1x−1​&lt;lnx&lt;21​(x−x1​) (x&gt;1)。能不能补上 0&lt;x&lt;10&lt;x&lt;10&lt;x&lt;1 时的情形呢？令 t=1xt=\\cfrac{1}{x}t=x1​（这个 ttt 和上一段的 ttt 也不一样），得到 2t−1t+1&gt;ln⁡t&gt;12(t−1t) (0&lt;t&lt;1)2\\cfrac{t-1}{t+1}&gt;\\ln t&gt;\\cfrac{1}{2}\\left(t-\\cfrac{1}{t}\\right)\\ (0&lt;t&lt;1)2t+1t−1​&gt;lnt&gt;21​(t−t1​) (0&lt;t&lt;1)，不等号方向恰好反了过来。x=1x=1x=1 时三个式子都为 000，在这时取等号。所以 2x−1x+1&lt;ln⁡x&lt;12(x−1x) (x&gt;1)2\\cfrac{x-1}{x+1}&lt;\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x} \\right)\\ (x&gt;1)2x+1x−1​&lt;lnx&lt;21​(x−x1​) (x&gt;1)，x=1x=1x=1 时取等号，0&lt;x&lt;10&lt;x&lt;10&lt;x&lt;1 时不等号反向。这组上下界的图如下，特别注意粉色曲线、橙色曲线的相对位置改变（对应了不等号反向）。还有一个对比图，可以看出这一组上下界比上一组上下界更紧。大小顺序：0&lt;x&lt;1, 绿&lt;橙&lt;蓝&lt;粉&lt;红0&lt;x&lt;1,\\ \\text{绿}&lt;\\text{橙}&lt;\\textbf{蓝}&lt;\\text{粉}&lt;\\text{红}0&lt;x&lt;1, 绿&lt;橙&lt;蓝&lt;粉&lt;红；x&gt;1, 绿&lt;粉&lt;蓝&lt;橙&lt;红x&gt;1,\\ \\text{绿}&lt;\\text{粉}&lt;\\textbf{蓝}&lt;\\text{橙}&lt;\\text{红}x&gt;1, 绿&lt;粉&lt;蓝&lt;橙&lt;红。事实上，橙/粉 这一组上下界也可以直接通过代数推导（定积分）得到。当 x&gt;1x&gt;1x&gt;1 时，由 ∀t&gt;1, 1−1t&lt;ln⁡t&lt;t−1\\forall t&gt;1,\\ 1-\\cfrac{1}{t}&lt;\\ln t&lt;t-1∀t&gt;1, 1−t1​&lt;lnt&lt;t−1 知，∫1x(1−1t)dt&lt;∫1xln⁡tdt&lt;∫1x(t−1)dt\\int_{1}^{x}\\left(1-\\cfrac{1}{t}\\right)\\mathrm{d}t&lt;\\int_{1}^{x}\\ln t\\mathrm{d}t&lt;\\int_{1}^{x}(t-1)\\mathrm{d}t∫1x​(1−t1​)dt&lt;∫1x​lntdt&lt;∫1x​(t−1)dt。第一个式子，不定积分的结果是 t−ln⁡t+Ct-\\ln t+Ct−lnt+C，代入得到定积分的结果是 x−1−ln⁡xx-1-\\ln xx−1−lnx。第三个式子，不定积分的结果是 12t2−t+C\\cfrac{1}{2}t^2-t+C21​t2−t+C，代入得到定积分的结果是 12x2−x+12\\cfrac{1}{2}x^2-x+\\cfrac{1}{2}21​x2−x+21​。第二个式子的不定积分需要用到分部积分法，结果是 tln⁡t−t+Ct\\ln t-t+Ctlnt−t+C（这个结果可以通过求导验证）。代入得到定积分的结果是 xln⁡x−x+1x\\ln x-x+1xlnx−x+1。代回不等式中，得到 x−1−ln⁡x&lt;xln⁡x−x+1&lt;12x2−x+12 (x&gt;1)x-1-\\ln x&lt;x\\ln x-x+1&lt;\\cfrac{1}{2}x^2-x+\\cfrac{1}{2}\\ (x&gt;1)x−1−lnx&lt;xlnx−x+1&lt;21​x2−x+21​ (x&gt;1)。把这个式子拆成两个不等式分别进行化简，就可以得到 2x−1x+1&lt;ln⁡x&lt;12(x−1x) (x&gt;1)2\\cfrac{x-1}{x+1}&lt;\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x} \\right)\\ (x&gt;1)2x+1x−1​&lt;lnx&lt;21​(x−x1​) (x&gt;1) 了。根据这个式子，就可以得出对数平均不等式了。给定 0&lt;b&lt;a0&lt;b&lt;a0&lt;b&lt;a，我们来证明 ab&lt;a−bln⁡a−ln⁡b&lt;a+b2\\sqrt{ab}&lt;\\cfrac{a-b}{\\ln a-\\ln b}&lt;\\cfrac{a+b}{2}ab​&lt;lna−lnba−b​&lt;2a+b​。对 ln⁡x&gt;2x−1x+1\\ln x&gt;2\\cfrac{x-1}{x+1}lnx&gt;2x+1x−1​，令 x=abx=\\cfrac{a}{b}x=ba​，化简可以得到 a−bln⁡a−ln⁡b&lt;a+b2\\cfrac{a-b}{\\ln a-\\ln b}&lt;\\cfrac{a+b}{2}lna−lnba−b​&lt;2a+b​；对 ln⁡x&lt;12(x−1x)\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x}\\right)lnx&lt;21​(x−x1​)，令 x=abx=\\sqrt{\\cfrac{a}{b}}x=ba​​，化简可以得到 ab&lt;a−bln⁡a−ln⁡b\\sqrt{ab}&lt;\\cfrac{a-b}{\\ln a-\\ln b}ab​&lt;lna−lnba−b​。连起来就可以得到对数平均不等式了。能不能从对数平均不等式出发，得到 橙/粉 上下界呢？在 a−bln⁡a−ln⁡b&lt;a+b2\\cfrac{a-b}{\\ln a-\\ln b}&lt;\\cfrac{a+b}{2}lna−lnba−b​&lt;2a+b​ 中，令 a=x(x&gt;1),b=1a=x(x&gt;1),b=1a=x(x&gt;1),b=1，得到 ln⁡x&gt;2x−1x+1\\ln x&gt;2\\cfrac{x-1}{x+1}lnx&gt;2x+1x−1​；在 ab&lt;a−bln⁡a−ln⁡b\\sqrt{ab}&lt;\\cfrac{a-b}{\\ln a-\\ln b}ab​&lt;lna−lnba−b​ 中，令 a=x2,b=1a=x^2,b=1a=x2,b=1，得到 ln⁡x&lt;12(x−1x)\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x}\\right)lnx&lt;21​(x−x1​)。在这个推导过程中，如果比较细心，可以发现，如果 0&lt;x&lt;10&lt;x&lt;10&lt;x&lt;1，会出现一次不等号反转。看来对数平均不等式和这组上下界可以互推，也就是说，它们是等价的。于是我们可以把这组上下界叫做“对数平均不等式系列”。既然这组上下界和一个特定的不等式相联系，那么 x−1x&lt;ln⁡x&lt;x−1 (x&gt;1)\\cfrac{x-1}{x}&lt;\\ln x&lt;x-1\\ (x&gt;1)xx−1​&lt;lnx&lt;x−1 (x&gt;1) 是否也和一个不等式有联系呢？我们把 ln⁡x\\ln xlnx 写成 ln⁡x−ln⁡1\\ln x-\\ln 1lnx−ln1，三个式子同时除以 x−1x-1x−1 得到 1x&lt;ln⁡x−ln⁡1x−1&lt;1\\cfrac{1}{x}&lt;\\cfrac{\\ln x-\\ln 1}{x-1}&lt;1x1​&lt;x−1lnx−ln1​&lt;1。由于 1x\\cfrac{1}{x}x1​ 是 ln⁡x\\ln xlnx 的导数，因此令 f(x)=ln⁡xf(x)=\\ln xf(x)=lnx，这个式子就可以写成 f′(x)&lt;f(x)−f(1)x−1&lt;f′(1)f&#x27;(x)&lt;\\cfrac{f(x)-f(1)}{x-1}&lt;f&#x27;(1)f′(x)&lt;x−1f(x)−f(1)​&lt;f′(1)，再结合 f′(x)f&#x27;(x)f′(x) 单调减，这不就是拉格朗日中值定理吗？当然，中值定理和泰勒展开还是有很大的联系的（还记得那个 费马引理 - 泰勒展开 - 拉格朗日中值定理 - 洛必达法则 的图么）。说了这么多废话，都是希望能借助不等式的背景，更好地记住这些不等式，同时能够更灵活地运用。 泰勒展开与不等式我们不难得出一些简单函数的泰勒展开，那么能不能借助泰勒展开得到不等式进行放缩呢？首先考虑一种平凡的情形。如果 ∀x≥x0,f(x)≥f(x0)\\forall x\\ge x_0,f(x)\\ge f(x_0)∀x≥x0​,f(x)≥f(x0​)，那么可以得到 ∀x≥x0,f(x)≥f(x0)\\forall x\\ge x_0,f(x)\\ge f(x_0)∀x≥x0​,f(x)≥f(x0​)。这不是废话嘛，条件和结论完全一样——啊，这就是“平凡”这个词的意思了，放心，后面的会有用的。接着考虑一种简单的情形。如果 ∀x≥x0,f′(x)≥f′(x0)\\forall x\\ge x_0,f&#x27;(x)\\ge f&#x27;(x_0)∀x≥x0​,f′(x)≥f′(x0​)，那么是否可以得到 ∀x≥x0,f(x)≥f′(x0)(x−x0)+f(x0)\\forall x\\ge x_0,f(x)\\ge f&#x27;(x_0)(x-x_0)+f(x_0)∀x≥x0​,f(x)≥f′(x0​)(x−x0​)+f(x0​)，也就是函数图象在切线的上方呢？答案是肯定的，令 g(x)=f(x)−f′(x0)(x−x0)−f(x0)g(x)=f(x)-f&#x27;(x_0)(x-x_0)-f(x_0)g(x)=f(x)−f′(x0​)(x−x0​)−f(x0​)，那么 g(x0)=0g(x_0)=0g(x0​)=0。g′(x)=f′(x)−f′(x0)≥0g&#x27;(x)=f&#x27;(x)-f&#x27;(x_0)\\ge 0g′(x)=f′(x)−f′(x0​)≥0，得到 g(x)g(x)g(x) 增，于是命题得证。再考虑一种稍复杂的情形。如果 ∀x≥x0,f′′(x)≥f′′(x0)\\forall x\\ge x_0,f&#x27;&#x27;(x)\\ge f&#x27;&#x27;(x_0)∀x≥x0​,f′′(x)≥f′′(x0​)，那么是否可以得到 ∀x≥x0,f(x)≥12f′′(x0)(x−x0)2+f′(x0)(x−x0)+f(x0)\\forall x\\ge x_0,f(x)\\ge \\cfrac{1}{2}f&#x27;&#x27;(x_0)(x-x_0)^2+f&#x27;(x_0)(x-x_0)+f(x_0)∀x≥x0​,f(x)≥21​f′′(x0​)(x−x0​)2+f′(x0​)(x−x0​)+f(x0​) 呢？答案也是肯定的。令 h(x)=f(x)−12f′′(x0)(x−x0)2−f′(x0)(x−x0)−f(x0)h(x)=f(x)-\\cfrac{1}{2}f&#x27;&#x27;(x_0)(x-x_0)^2-f&#x27;(x_0)(x-x_0)-f(x_0)h(x)=f(x)−21​f′′(x0​)(x−x0​)2−f′(x0​)(x−x0​)−f(x0​)，那么 h(x0)=0h(x_0)=0h(x0​)=0。h′(x)=f′(x)−f′′(x0)(x−x0)−f′(x0)h&#x27;(x)=f&#x27;(x)-f&#x27;&#x27;(x_0)(x-x_0)-f&#x27;(x_0)h′(x)=f′(x)−f′′(x0​)(x−x0​)−f′(x0​)。这里再求导就可以得到答案（这也是考试中的写法），但是我们可以取个巧！在上一段的结论中，令 f上一段(x)=f这一段′(x)f_{\\text{上一段}}(x)=f_{这一段}&#x27;(x)f上一段​(x)=f这一段′​(x)，就是把 f′(x)f&#x27;(x)f′(x) 当做主函数代入到上一段的结论中，就可以得到 f′(x)≥f′′(x0)(x−x0)+f′(x0)f&#x27;(x)\\ge f&#x27;&#x27;(x_0)(x-x_0)+f&#x27;(x_0)f′(x)≥f′′(x0​)(x−x0​)+f′(x0​)，也就是 h′(x)≥0h&#x27;(x)\\ge 0h′(x)≥0 了！那么得到 h(x)h(x)h(x) 增，命题又可以得证了。当然，如果不理解“取巧”的方法，这里给出再求一次导的方法（本质是一样的）。h′(x0)=0h&#x27;(x_0)=0h′(x0​)=0。h′′(x)=f′′(x)−f′′(x0)≥0h&#x27;&#x27;(x)=f&#x27;&#x27;(x)-f&#x27;&#x27;(x_0)\\ge 0h′′(x)=f′′(x)−f′′(x0​)≥0，得到 h′(x)h&#x27;(x)h′(x) 增，于是 h′(x)≥h′(x0)=0h&#x27;(x)\\ge h&#x27;(x_0)=0h′(x)≥h′(x0​)=0。根据这三个式子，我们可以总结出：如果 ∀x≥x0,f(n)(x)≥f(n)(x0)\\forall x\\ge x_0, f^{(n)}(x)\\ge f^{(n)}(x_0)∀x≥x0​,f(n)(x)≥f(n)(x0​)，那么就有 ∀x≥x0,f(x)≥Tn=f(x0)+f′(x0)1!(x−x0)+f′′(x0)2!(x−x0)2+⋯+f(n)(x0)n!(x−x0)n\\forall x\\ge x_0,f(x)\\ge T_n=f(x_0)+\\cfrac{f&#x27;(x_0)}{1!}(x-x_0)+\\cfrac{f&#x27;&#x27;(x_0)}{2!}(x-x_0)^2+\\cdots +\\cfrac{f^{(n)}(x_0)}{n!}(x-x_0)^n∀x≥x0​,f(x)≥Tn​=f(x0​)+1!f′(x0​)​(x−x0​)+2!f′′(x0​)​(x−x0​)2+⋯+n!f(n)(x0​)​(x−x0​)n。事实上，很多含参不等式恒成立问题都是这么改造来的（这就是我们很熟悉这个过程的原因）。我们也可以用这个方法构造出一些不等式用于放缩，但是很有可能不起作用；通常做题时还是以题目提示为主。 总结先总结一下这六个系列的不等式。指数的泰勒展开系列，主要是在 x=0x=0x=0 处的展开 ex≥x+1e^x\\ge x+1ex≥x+1；这个式子衍生出了很多带有 exe^xex 的不等式；取倒数可以得到一个 exe^xex 小于等于多少的式子。指数的切线系列，可以尝试在任意地方的切线，典型的有 ex≥exe^x\\ge exex≥ex。指数的次数系列，放到多少次都行。对数的泰勒展开系列，最常用的还是 ln⁡x≤x−1\\ln x\\le x-1lnx≤x−1，令 t=1xt=\\cfrac{1}{x}t=x1​ 可以得到 ln⁡t\\ln tlnt 的下界。这组不等式还可以用拉格朗日中值定理（区间端点取 111 和 xxx）记忆。注意，对数的不等式通常有 ln⁡x\\ln xlnx 和 ln⁡(x+1)\\ln(x+1)ln(x+1) 两种版本，只需要记一种，用到的时候换元就可以了。对数的次数系列，常用的有 ln⁡(1+x)≤x, ln⁡(1+x)&lt;x\\ln (1+x)\\le x,\\ \\ln (1+x)&lt;\\sqrt{x}ln(1+x)≤x, ln(1+x)&lt;x​。对数平均不等式系列，包括对数平均不等式本身和一组上下界 2x−1x+1&lt;ln⁡x&lt;12(x−1x) (x&gt;1)2\\cfrac{x-1}{x+1}&lt;\\ln x&lt;\\cfrac{1}{2}\\left(x-\\cfrac{1}{x} \\right)\\ (x&gt;1)2x+1x−1​&lt;lnx&lt;21​(x−x1​) (x&gt;1)。对数平均不等式比较好记，如果记不清那一组上下界可以用对数平均不等式代入 (x,1)(x,1)(x,1) 和 (x2,1)(x^2,1)(x2,1) 得到。答题的时候则是用这组上下界构造函数来证明对数平均值不等式。这六个系列的不等式是不是很好记？那么是时候兑现我们的诺言了，如何记住那六组不等式呢？仔细观察可以发现，第一组不等式包括了指数泰勒展开系列和对数泰勒展开系列；第二组不等式是对数的泰勒展开系列；第三组、第五组和第六组说的都是对数平均不等式系列；第四组不等式说的是对数的次数系列。你看，这不就记住了吗？所以，数学学习可以不死记硬背，而是通过加强理解和了解背景，更好地掌握知识。 参考资料如果想进一步加深理解，可以读一下这两篇文章。【导数压轴题】所谓“放缩”——简单函数不等式【导数压轴题】再谈“放缩”——几个进阶不等式","categories":[{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"函数","slug":"函数","permalink":"https://sweetlemon39.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"英语选修七 单词表","slug":"English-7-words","date":"2020-03-06T00:00:00.000Z","updated":"2020-04-08T00:00:00.000Z","comments":true,"path":"English-7-words/","link":"","permalink":"https://sweetlemon39.github.io/English-7-words/","excerpt":"最近学文化课，单词背不得，太惨了。","text":"最近学文化课，单词背不得，太惨了。更新日志：2020-03-06 记录 Unit 2 单词2020-03-15 记录 Unit 3 单词，新增来自 ACGN &amp; OI 语料库中的语境2020-03-20 记录 Unit 1 单词2020-03-31 记录 Unit 4 单词2020-04-08 记录 Unit 5 单词，更新完毕 Unit 1单词词性释义闲话disabilityn.伤残；无能disabledadj.伤残的hearingn.听力；听觉eyesightn.视力syndromen.综合病征总觉得这个词和 chrome 有相同后缀，但是查了词源发现完全不同。不过记单词还是可以 syn+drome（大雾）infantile paralysis小儿麻痹lapn.跑道的一圈；重叠部分；（人坐着时）大腿的上方秒表上就有 lap，此外“大腿”的意思也派生出了 laptop；奈芙莲在威廉的腿上睡着了ambitionn.雄心；野心威廉总认为自己看上去没有野心ambitiousadj.有雄心的；有野心的大贤者想要夺回地面，这是一个有雄心的计划dictationn.口授；听写（的文字）不知道和 dictionary 有没有关系，至少长得有点像noisyadj.吵闹的；嘈杂的嘈杂的嘈是平舌音suitableadj.适合的；适宜的entryn.项目；进入；入口entry 作“项目”大概是 an item in a list 的意思，在线性代数里还可以表示矩阵的一个元素。（The entry in the second row and first column of this matrix is 6.）beneficialadj.有益的；受益的in other words换句话说非常高频的词组，意思可能就像“即得”（大雾）；换句话说，你现在已经不是黄金妖精了clumsyadj.笨拙的莉莉娅认为威廉的动作很笨拙bumpvi.碰撞；撞击大部分生物（不包括妮戈兰）撞到马车上都会出事（事实上妮戈兰撞到马车也会出事，但出事的是将反向弹回的马车）outgoingadj.外向的；友好的；外出的；离开的adaptvt.使适应；改编adapt 和 adopt 很像，网上有一句把它们区分的话—— I am adept at making an adopted child adapt to his new home by psychotherapy.（我擅长通过心理治疗使领养的孩子适应他们的新家）adapt to适合上面的句子里面就有 adapt to 了benchn.长凳浪漫的地方（大雾）；威廉在长凳上坐下，坐在珂朵莉身旁cut out切去；省略；停止（做某事）意思还挺多的，分别是物理切去、语言切去、精神切去；珂学课本没有 cut out，只有 cut out for（适合）microscopen.显微镜微小的作用域，简称微域（大雾）out of breath上气不接下气absencen.缺席；不在某处fellowadj. &amp; n.同伴的；同类的；同伴莉莉娅想着她的勇者伙伴们在做什么annoyvt.使……不悦；惹恼annoyedadj.颇为生气的annoyancen.烦恼缇亚忒看到费奥多尔，脸上写满了不悦（好假）all in all总而言之firmn. &amp; adj.公司；坚固的；坚定的firm 作“公司”还是需要注意的softwaren.软件sit around闲坐着威廉认为，如果什么事都不做就无法离开梦境世界as well as和；也这东西现在还是新词？parrotn.鹦鹉carrot 是胡萝卜tankn.大容器；缸；大桶另外的意思大家都懂；费奥多尔把缇亚忒从水池里捞了出来tortoisen.陆龟；龟和 turtle 有点像，都是两个 tin many ways在很多方面psychologyn.心理（学）很长也很难记……psy 发 sci 的音还是有点意思psychologicallyadv.心理（学）地；精神上地make fun of取笑encouragementn.鼓励；奖励conductn. &amp; vt.行为；品行；指挥；管理；主持意思真够多的；费奥多尔的品行（表面上）无可挑剔；艾尔佩斯主持了对兽的研究mainstreamn.主流；主要倾向fulfillingadj.令人满意的；令人愉快的如果威廉不成为勇者，他可能过着更愉快的生活never mind不必担心politicsn.政治（学）abolishvt.废除；废止找不到什么例子，课本给的是废止贩卖奴隶（Finally the slave trade was abolished in 1807.）abolitionn.废除；废止resignvi. &amp; vt.辞职辞职只是最常用的一种意思，这个词还有（不情愿地）放弃或屈服的意思；resigned 有“无奈”的意思；resignation 还有类似“认命”的意思（根据珂学课本的中英对照得出）。其实这几个词可以连成意思串——无奈地辞职认命slaveryn.奴隶制literaturen.文学（作品）；著作；文献论文里有个叫文献综述（literature review）的东西（回顾这个话题的文献）；威廉很厉害，可以读五百年前的文学作品（这算什么，中国高中生还能读千年前的古文呢）companionn.同伴；伙伴（悲伤的例子）珂朵莉已经失去了关于仓库里一半伙伴的记忆assistancen.协助；援助congratulatevt.祝贺；庆贺congratulationn.祝贺；贺词以前我曾经被这个长单词吓怕过bowlingn.保龄球保龄球=爆零球（大雾）；我也不知道这个词和 bowl 有什么关系graduationn.毕业（典礼）certificaten.证书数字证书（digital certificate）是 HTTPS 安全的重要保障all the best（祝你）一切顺利architectn.建筑师软件架构师是程序设计专家才能胜任的adequateadj.足够的；充分的现有的系统不足以应对这种情况（威廉和妮戈兰、灰岩皮讨论珂朵莉的未来）accessn.（接近的）方法；通路；可接近性看某 OJ 的比赛有时会显示 Access Denied（拒绝访问）；Access 本身还是 Office 套装里的数据库软件的名字accessibleadj.可接近的；可进入的；可使用的这里有一个鲜活的例子：D:\\ is not accessible. Access is denied（这种情况好像要 chkdsk 一下）wheelchairn.轮椅handyadj.方便的；好用的珂学课本里出现了几次 come in handy，比如，威廉没有威慑力的面孔只在面对小孩的时候才派上用场earphonen.耳机impairvt.削弱；损伤把眼睛“黏在”屏幕上导致视力削弱rown. &amp; vi. &amp; vt.一行；划（船）OIer 一定知道“行”的意思，但是“划船”的意思，呃，据说有首儿歌叫 Row, Row, Row Your Boat；顺便说一句，“行”和”列“的概念大陆和港台是相反的（basementn.地下室Codeforces 有一道“地下室里的机器人”的题目（Robot in Basement, Yandex.Algorithm 2011: Finals D）outwardsadv.向外exitn.出口；离开；退场Python 有 exit() 和 quit() 两个退出函数，但是 exit 和 quit 的意思有点不同（meet with遇到；经历；会晤费奥多尔定期和玛尔戈会晤，啊不是，是碰面（明明只是约会嘛）approvaln.赞成；认可dignityn.尊严；高贵的品质艾瑟雅有一种独特的成熟的魅力（当然是在 5 年后）profitn.收益；利润；盈利italicsn. (pl)斜体（字）Ctrl-I 的 I 就是这么来的，\\mathit 也是这么来的 italics\\mathit{italics}italicscommunityn.社区；团体；社会github 是世界上最大的开源社区（这么宣传可是违反广告法的（大雾）） lapWhat was my reason for doing unfamiliar work to the point of completely exhausting myself and falling asleep in his lap - and why did I feel comfortable all the while?（珂学选修 1-1） ambitionA black haired man stared back at him with black eyes that seemed void of any ambition.（珂学必修 1） ambitiousThat’s a pretty ambitious plan.（珂学必修 2） in other words“Yes. Of course, I have no idea why, but just going by the results that’s the only plausible conclusion.&quot; Naigrat lightly shook the test tube in her hand. The silver contents shook about. “As you know, Leprechauns are a type of Ghost. So when I mixed your blood with this silver, it should have turned black immediately. The lack of a reaction can only mean one thing.&quot;Naigrat’s logic was simple, which meant there was no room for counterargument.“In other words, you are no longer a Leprechaun.&quot;（珂学必修 3） clumsyShe recalled that fateful winter when she’d first seen Willem practicing in that forest. Looking at his clumsy, unpolished movements, Leila had felt incensed.（珂学选修 1-1） bumpIn addition, most living beings, not only Leprechauns, probably wouldn’t be fine after bumping into a carriage. Well, of course, Naigrat didn’t belong in ‘most living beings’.（珂学必修 5） bench“Hey,” Willem said as they sat down next to each other on a bench.（珂学必修 3） fellowWhat are all my fellow Braves doing right now?（珂学选修 1-1） annoyance“Why are you here?” Tiat asked, annoyance written all over her face.（珂学选修 2-1） sit around“Do we need to strike back?” Nephren asked.“Of course. If we just sit around we’ll never get out of here.” tank“That’s why I said it was dangerous,” Feodor grumbled, pulling the dripping girl out of the tank.（珂学选修 2-1） conductFeodor wasn’t sure why he was being summoned. As Fourth Officer, he had irreproachable conduct and was an exemplary soldier.（珂学选修 2-1）The Elpis Trading Federation city-state, who existed on the 13th Island at the time, had conducted research on Beasts and, for the purposes of political maneuvering, brought them up from the surface.（珂学选修 2-1） fulfillingMaybe if he had given up on his impossible dream right away and spent his free time like a normal teenage boy, he would’ve gotten to experience more things and lived a more fulfilling life.（珂学必修 4） resignShe took a breath, then continued. “There aren’t many soldiers who’d be glad to go and babysit children like us. Everyone else immediately resigned and left. Willem was sent to our warehouse like the other soldiers, five years ago. He was an incredibly admirable Technical Officer… and… he was… like a father to all of us.”（珂学选修 2-1）其他军方管理员都很快辞职离开了。&quot;Whatever just hurry up and let go of me… this is really getting embarrassing!”After looking around and grasping the situation, he mumbled “my bad”, then loosened his arms. Kutori, who had silently slipped out of his embrace and backed up a few steps, stared at Willem with a bright red face.“A real mess, huh?” Aiseia laughed teasingly,“Mm,” Nephren gave a resigned nod,And Willem’s sobs rang out loud and clear. （珂学必修 2）奈芙莲无奈地点了点头（出自威廉紧紧抱住珂朵莉的那一幕）“Resignation and determination are essentially the same thing. They both refer to a decision to sacrifice something important in order to achieve a goal.”（珂学必修 1）灰岩皮解释“战士心中的风”（决心或认命） literature“Eh? You’re a technician, aren’t you? Aren’t you supposed to be smart?”“Oh, I’m super smart. If you have any ancient literature from 500 years ago, I can read it no problem!”（珂学必修 1） companionAlready, she had forgotten almost half of the names of her companions in the fairy warehouse. Even if she tried hard to study and relearn their names, her memories of them refused to return.（珂学必修 3） adequate“Can we change the entire system somehow? It’s obviously not adequate enough to cover the current situation,” Willem asked.“It’ll take a long time to get such a change to go through. It could be years. And if she gets an order to go to battle during that time, it’ll all be for nothing.”“I can do something about the orders to a certain extent,” Limeskin remarked.（珂学必修 3） architectA software architect is a software developer expert who makes high-level design choices and tries to enforce technical standards, including software coding standards, tools, and platforms.（Wikipedia Software architect） handyBut as soon as Willem showed them that smile of his, they relaxed. These kind of moments were the only times when that face of his, which lacked any solemnity whatsoever, came in handy.（珂学必修 4） impairAs you spend lots of time “glued to the screen”, your vision is impaired.（Codeforces Round #159 C） meet withAfter this, the boy and the girl occasionally received a chance to meet with each other.Every time they met, the girl would press him for new stories. In order to meet her expectations, he was forced into increasingly diligent studies.Of course, that didn’t bother him – though the actions of her family created more than enough irritation regardless.（珂学选修 2-1） dignity“Nah, not quite.” Nax scratched his cheek. “She’s got that sorta… widow’s allure, ain’t she?”A burst of air came from underneath Tiat’s mask. “Wi-Widow?!” she spluttered.“Er, not something to be sayin’ in front of her family, eh? Sorry.”“Uh, um, wait, no, that’s not why…”What do I do? Somehow she was in agreement. These past few years, Aiseia Myse Valgalis had begun to exhibit a mysterious dignity, born from some unique condition or another. Nax’s suggestion seemed somehow fitting - very fitting indeed.（珂学选修 2-2） communityGitHub is home to the world’s largest community of developers and their projects…（github 主页） Unit 2单词词性释义闲话householdadj. &amp; n.家庭（的）fictionn.小说function fiction 函数的小说？desiren. &amp; vt.渴望；欲望；想要satisfactionn.满足；令人满足之物test out考验出；检验完./test.outbonusn.额外津贴；奖金；红利bonus failed（东方）alarmvt. &amp; n.使警觉；使惊恐；惊动；警报闹钟是这个吧alarmedadj.担心的；害怕的apronn.围裙a po*nsympathyn.同情（心）我为不知道 Sympy 的人感到同情（overweightadj.超重的超重，失重？（elegantadj.优雅地；讲究的好像在 lib 的介绍很常见favourn. &amp; vt.喜爱；恩惠；偏袒pilen. &amp; vi. &amp; vt.堆；堆积不是 heapscanvt.细看；粗看；扫描扫描线 scanningfingernailn.手指甲absurdadj.荒谬的；可笑的haircutn.发型；理发makeupn.化妆品编造的化妆品（accompanyvt.陪伴；伴奏和你一起 AC 整个公司的题目cushionn.软垫beddingn.寝具；铺盖necklacen.项链clerkn.售货员；职员；旅馆接待员countern.柜台；计数器OIer 应该不知道柜台计数器ring up给……打电话turn around转身；翻转awfuladj.极坏的；极讨厌的；可怕的affairn.事务；事情；暧昧关系armchairn.扶手椅declarevt.宣布；声明；表明；宣称cuisinen.烹饪（风味）；菜肴cui sine（弦），又脆又鲜envyvt.忌妒；羡慕leave … alone不管；别惹；让…一个人呆着；和…单独在一起digitaladj.数字的；手指的；脚趾的digit 都懂mailboxn.邮筒；信箱asideadv.在一边；向一边set aside将……放在一边；为……节省或保留（钱或时间）grandadj.大的；豪华的；雄伟的grandma 大妈（逃alphabeticaln.字母（表）的；按字母顺序的这个词来自 alpha, beta, …receivern.收件人；接收机；电话听筒in all一共affectionn.喜爱；爱；感情boundadj.一定的；密切相关的lower_bound 与 STL 密切相关（be bound to一定做……biographyn.（他人撰写的）传记生物图谱？（holyadj.神的；圣洁的holy s**t 到底是怎么来的……imaginationn.想象（力）；创造力；幻想物transfusionn.输血part-timeadj.兼职的master’s degree硕士学位大师度（staffn.全体员工；手杖navyn.海军（部队）junioradj. &amp; n.较年幼的（人）；地位较低的（人）要是和 senior 混，想一想瑟尼欧里斯是高级的剑PhD = Doctor of Philosophy（哲学）博士学位pH 医生（biochemistryn.生物化学talentn.天才chaptern.章empiren.帝国theoreticaladj.理论（上）的；假设的frameworkn.框架；结构.net frameworkthinkingn.思想；思考divorcen. &amp; vt.（与……）离婚；断绝关系；与……脱离obeyvt. &amp; vi.服从disobeyvt. &amp; vi.不服从assessmentn.评价；评定 Unit 3单词词性释义闲话snorkelvi. &amp; n.戴潜水通气管潜泳；通气管aquariumn.水族馆；水族箱aqueous, 水溶液；aqours!, 水团anecdoten.轶事；奇闻baleenn.鲸须baleen whale须鲸annualadj. &amp; n.每年的；年刊；年鉴必修 4 里威廉每年都有烤栗子吃migrationn.迁徙；移居migrate v. 迁移；immigrate v. 移民witnessvt. &amp; n.目击；目击者；证据没有妖精看到过珂朵莉吃甜食accommodationn.住所；住宿CF467A George and Accommodationshoren.岸；海滨offshoreadv. &amp; adj.近海（的）；离岸（的）oppositeprep. &amp; adj.在……对面；相对的yellvi. &amp; n.大叫；叫声想象一个人喊着“要！”pausevi. &amp; n.暂停cmd 有个 pause 命令oarn.桨；橹telescopen.望远镜scope 有作用域的意思teamworkn.协作；配合Teamwork 本身是一款软件的名字blow-holen.（鲸鱼的）鼻孔；（隧道的）通风口吹气孔（divevi. &amp; n.跳水；潜水；俯冲这个词的运用很活，总之就是很快地陷入之类的意思fleevi. &amp; vt.逃避；逃跑；逃离不及物动词的时候过去式和过去分词是 fled；珂朵莉想要从目光中逃脱harpoonn.（捕鲸用的）鱼叉dragvt.拖；拉；扯github: Drag files here to add them to your repository.depthn.深（度）；深处写树题的时候打了不下几百次meantimeadv.其间；同时FJ 想要同时关闭农场in the meantime在此期间；与此同时lipn.一片嘴唇；（容器或洞的）边，口用唇部动作交流overboardadv.越过船舷进入水中urgevt.催促；极力主张；驱策虚拟语气小组成员；有趣的是这个词在珂学课本中基本都以名词 urge to do 出现abandonvt.放弃；遗弃；抛弃据说是考四六级背单词背到的第一个；威廉显然不会抛弃妖精仓库的孩子们sharkn.鲨鱼help (…) out帮助（某人）摆脱困境或危难珂朵莉想让莲和艾瑟雅帮助她一下relationshipn.关系；血缘关系；交往实在是高频词了conservationn.保存；保护第一眼看成 conversation，就像 reserve 和 reverse 会搞混……历史建筑保护icebergn.冰山jogvi. &amp; vt.慢跑；轻推；轻撞珂朵莉轻轻地跑了seasiden. &amp; adj.海边（的）netn.网targetn.目标；靶；受批评的对象tiden.潮（汐）；潮流driftnetn.流网drift 是流的意思（这个词其实挺多意思的）dimensionn.维（数）；方面；侧面就是“次元”啦~ 方面还可以理解为位面么（reflectvi. &amp; vt.思考；映射；反射威廉思考他的身体到底变得多脆弱；珂朵莉看着镜子里映射出的像；瑟尼欧里斯反射的光pureadj.纯的；纯粹的；纯洁的“100% 纯”celln.细胞；（蜂房的）巢室三大顶刊（CNS）之一awareadj.意识到的；知道的be/become aware of对……知道、明白珂朵莉意识到她恋爱了vividadj.生动的；鲜明的；鲜艳的黄金妖精鲜艳的发色；绯红色是 vivid scarlet（艾陆可的发色）neatadj.&lt;口&gt;好的；整齐的；匀称的CF1145F Neat Words（一道曾是黑题的水题）seaweedn.海草；海藻weed 是杂草narrowadj.狭窄的；有限的；狭隘的flashlightn.闪光灯；手电筒手机的那个（upside down上下翻转即使世界天翻地覆威廉也不会说出求婚的话（真香）suckvt. &amp; vi.吮吸口语有糟糕的意思；技官回来了见不到我会很麻烦sea-slugn.海蛞蝓中文我都不会读turtlen.（海）龟；甲鱼著名编程入门eeln.鳗；鳝sharpadj.锐利的；敏捷的tastyadj.好吃的我不能忍受那些肌肉看上去不好吃的人（可怕的妮戈兰）giantadj. &amp; n.巨人（的）；伟大（的人）拔山盖世 / 北上广深（BSGS, Baby Step Giant Step）算法clamn.蛤Clam talked to Wallace calmly.（好暴力）greyadj. &amp; n.灰色（的)我在珂学课本里搜 grey 竟搜不到，结果发现里面用的是 grayscarevt. &amp; vi.恐吓；受惊吓(be) scared to death吓死了shallowadj.浅的；肤浅的；浅显的他们的暗恋不过是肤浅的尊敬；你真是太好懂了steepadj.陡峭的陡峭的斜坡，steep slopeboundaryn.界限；分界线Beyond the Boundary，境界的彼方Antarcticadj.南极的the Antarctic南极洲awesomeadj.使人敬畏的；令人畏惧的口语上也就是“很好”的意思而已啦leapvi. &amp; n. &amp; vt.跳；跳跃；跳过（障碍）过去式和过去分词可以是 leapt 或 leaped；珂朵莉向前一跳sealn.海豹；封条；印章在珂学课本里更多是“封印”的意思，封条+印章=封印，是不是很形象？refundvt. &amp; n.退还；偿还；退款pensionn.养老金pensionern.领取养老金者 annualEvery autumn, similar stalls popped up all around town, spreading their delicious aroma throughout the streets. They mostly went away by wintertime, but a few always remained. They occasionally appeared out of nowhere and triggered your appetite, like what just happened to Willem. To residents of the town, roasted chestnuts were an annual happening, and Willem hadn’t tasted them in two whole years. （珂学必修 4） witnessNo other fairy had ever witnessed Kutori eat a sweet treat before.（珂学必修 3） diveAt an unprecedented speed, I will dive right into you. （你的名字，Sparkle）A strong sense of deja vu overcame him, and his mind started to dive back into the past. The scenery around him, the warehouse on the 68th Island, twisted into the image of an old orphanage. Sights of the place where he once lived then evoked memories of him, the oldest of the children being raised there, taking care of the young ones.（珂学必修 1）If I were to die in five days, would you be a little nicer to me?“Ahhh why did I say that!?”Kutori did a backwards dive back into the bed she just got out of and flailed about violently, ignoring the resultant loud creaking noises.… if I asked for a kiss or something. What would you do?（珂学必修 1） flee“A-Alright, I’ll go away soon, so don’t worry…”The girl stood up and attempted to flee from the stares, but found that she couldn’t move an inch. Willem, still lying on the ground, had latched onto the girl’s wrist.“You forgot something.” He held out his other hand and dropped a small brooch into the girl’s palm.（珂学必修 1） meantimeFarmer John and his cows are planning to leave town for a long vacation, and so FJ wants to temporarily close down his farm to save money in the meantime.（P6121 [USACO16OPEN] Closing the Farm） lipWithout a sound, one of the invaders signaled to his comrades using lip movements and hand signs.（珂学必修 4） urgeLooks like my inner Beast is pissed off, Willem thought. Destroy erase return send them home crumble — an intense urge to destroy welled up from within, along with an endless flurry of words.（珂学必修 5） abandonAnd even if he had someone like that in the, let’s say 28th Island, would he decide to abandon his beloved daughters to see them?（珂学选修 1-1） help (…) outRen, Aiseia. I need you to help me out a little.（珂学必修 2） conservationAs a young city with little cultural heritage to speak of, conservation of historical buildings was unneeded.（珂学选修 1-1，描述帝都） jogKutori gave him a light pat on the back before starting off down the hallway in a light jog.（珂学必修 3，威廉和奈芙莲一起休息后珂朵莉“生气”地离开） dimensionThe 5th dimension keeps on teasing me, but I will keep on looking at you dear.（你的名字，Dream Lantern） reflectWhile checking around his body to see if he missed any mud or if any pain still lingered, Willem reflected on how pitifully weak he had become.（珂学必修 1）Kutori sensed something strange in the image reflected in the mirror: red. Her hair was red.（珂学必修 3）The flickering candlelight danced and threw off shadows. Leaned against a wall beneath them, Seniolis reflected a slight flash of light, its gleam appearing almost to be a smile.（珂学选修 1-1） be/become aware ofIf one were to ask her when it started, she wouldn’t be able to answer. By the time she’d become aware of it, it was already this way.（珂学选修 1-1，意识到的内容是 Kutori Nota Seniolis was in love.） vividThe only difference is the vivid color often present in their hair and eyes.（珂学必修 2）As he stared in shock at Kutori, the remaining blue in her hair rapidly transformed into the exact same vivid scarlet that they saw in the ice. upside downA proposal? Even if the world was turned upside down, those words would never come out of Willem’s mouth. It just seemed too unrealistic.（珂学必修 3） suck“Besides, it would suck if I left then he came back, right? I want to see him as soon as possible, so I need to wait at home like he said.” （珂学必修 2） tasty“Oh?” Naigrat glanced at the beast men — then, for the first time during their talk, smiled. “My apologies. I can’t stand people whose flesh don’t look very tasty.”（珂学必修 5） shallowTheir crushes were no more than shallow admiration.（珂学必修 4）“You’re so shallow.”（珂学选修 1-1，描述莉莉娅） steepBefore the battle started, the steep yet beautiful slopes of mountains and a sparse forest of conifers had decorated the area.（珂学必修 4） leap“Gotcha!” The girl took a big leap forward, not wanting to miss this unexpected opportunity.（珂学必修 1，珂朵莉追猫） sealI can only stop in a world and use my power as a Visitor six times, and I used the last one to seal your memories.（珂学必修 5） Unit 4单词词性释义闲话airmailn.航空邮件航空邮件=hkyj=black-rimmed glasses（逃fortnightn.两星期词源相当于 fourteen nights，也是隔离期的长度（大雾）hear from接到……的信(be) dying to渴望死都要做某事，果然渴望roofn.屋顶；车顶屋顶很危险，不要上屋顶！珂朵莉以侵蚀为代价救了阿尔米塔后的告诫。（选修 2-6 末尾那段真的很感人）muddyadj.泥泞的；泥土般的玛尔戈拉了拉费奥多尔沾满泥的袖子textbookn.教科书conceptn.观念；概念新概念英语（New Concept English），说实话这三个词里面最难的就是这个概念了bucketn.水桶桶排序（bucket sort）的桶；bitbucket 也是一个版本控制平台the other day不久前的一天a few days ago，一般过去时weeklyadj. &amp; adv.每周（的）weekly test（哭）bubblevi.起泡；沸腾；汨汨地流动冒泡排序（bubble sort）的泡relevantadj.有关的；切题的每一行输出与之相关的（对应的）那一组数据的答案；（必修 1 威廉在丛林中）更相关的（迫切的）问题是被野生动物吃而不是被妖精捉弄（然后就被妖精捉弄了，再后来既有被妖精捉弄的风险又有被食人鬼吃的风险）remoteadj.遥远的；偏僻的远程服务器解析变化ridgen.山脊；屋脊钡硒（BaSe）逃跑了，藏在长着高高的草的山脊上weedn. &amp; vt. &amp; vi.杂草；除杂草Unit 3 有个 seaweedhutn.棚屋；小屋必胜客是 pizza hutrectanglen.矩形这个词太常见了……词源类似 right angle（直角）rectangularadj.矩形的同上，rectangular area 不知道出现了多少次adjustvt. &amp; vi.调整platformn.平台；讲台；月台既包括具体的平台，又包括抽象的平台（Linux platform 等）broomn.扫帚broom 常和 magic 联系在一起（大雾）tinn.锡无锡=no tin=not in=∉\\not\\in​∈（大雾）jarn.罐；广口瓶jar（Java ARchive）这个扩展名起得很形象，像罐头食品一样开罐即用sniffvt. &amp; vi.嗅；用鼻子吸威廉能嗅出敌人的味道（这句话其实是威廉在和珂朵莉解释他和奈芙莲睡一起的事情的时候说的）participatevi.参与谷歌搜索 how to participate in IOI（大雾）interpretern.作口译的人Python interpreter（Python 解释器）其实很形象，口译的过程和计算机语言解释的过程类似grilln. &amp; vt.烤架；大平底锅；烧烤；炙烤这个词怎么看都有妮戈兰的感觉，不过其实是在威廉在地面的时候出现的：铁架子只有一颗螺丝，看上去摇摇欲坠dry out（使浸水等之物）完全变干是人为地使它变干leftovern. &amp; adj.剩余物；剩饭；剩余的剩余的魔力让珂朵莉的肌肉僵硬（于是就有了威廉的玄学按摩）eviladj. &amp; n.邪恶的；邪恶著名论断：eval is evil，当然有些人提出了反对意见dry up（河流、井等）干涸注意和上面的 dry out 区分；想到又有孩子要上战场，妮戈兰的感情干涸了otherwiseconj. &amp; adv.否则；用别的方法；其他方面否则就是其他情况，因此这个词就是其他某某的意思（另外说一句，这个词很高频）privilegen.特权；特别优待找不到莉艾尔的时候，妮戈兰说“过度保护是监护人的特权”（后来莉艾尔被威廉过度保护了）paperworkn.文书工作arrangementn.安排；排列OI 题目里面好多 arrangement 的，比如 UVA1638 杆子的排列 Pole Arrangementtoastvt. &amp; n.烤（面包等）；敬酒；烤面包片；干杯那个 Chinese New Year 的视频里面像 tour 一样的词原来是 toast……另外，吐司就是音译combn. &amp; vi.梳子；梳（发）这个词头，再加 ine 就是 combine 了呀；费奥多尔的银发很难梳astronautn.宇航员还有个中英合成词 taikonaut（anglen.角；角度太常用啦~cataloguen.目录catalogue 是目录，category 是分类donaten.捐赠要钱要钱（voluntaryadj.自愿的；无偿的上面那只不要脸，这里不要钱in need在困难中；在危急中可是我急需钱，不得不要钱啊purchasevt. &amp; n.购买我要钱买东西啊anniversaryn.周年纪念（日）买周年纪念日礼物啊；It’s Codeforces’ 10 years anniversary, let’s purchase a souvenir to donate.seedn.种子；萌芽srand！seedlingn.秧苗；树苗这个 l 就很灵性vaccinationn.接种疫苗vaccination 指动作，vaccine 指疫苗本身loann.贷款sewvi. &amp; vt.缝；缝制；缝合fandom wiki 上，珂朵莉的 hobbies 是 sewing, knittingsewing machine缝纫机珂朵莉不需要 sewing machine！她太强了！supplementn.增补的事物；补充；附录；增刊其实还可以作动词，比如 supplement that table（填表，出自具体数学）；词源是拉丁语一个与“that which is added to supply a shortage”有关的单词oxn.（pl oxen）公牛这个诡异的中古英语复数，是从 oxe 变为 oxenploughvi.犁（地）；耕（地）trunkn.树干；躯干；大衣箱交换机有 trunk 端口（不过这种树状结构的设备，有也很正常）trunk library箱式（柜式）图书馆tractorn.拖拉机；牵引机Farmer John 不耕地，但是他常用 tractor！Codeforces 甚至有一道叫 Tractor College 的题目，这所大学学习 the Art of Operating a Tractor（拖拉机操作艺术）Kenyan.肯尼亚clickvi. &amp; vt. &amp; n.（使）发出咔嗒声；咔嗒声吐槽这个释义，只看中文释义完全不知道这为什么是重点词……难道不能加一个“点击”的意思吗？tailorn. &amp; vt.裁缝；剪裁缝制（衣服）economicadj.经济（学）的politicaladj.政治的；政党的distributevt.分配；分发先“贡献”（contribute），再“分配”（distribute）；珂朵莉要合理分配精力很困难distributionn.分配；分发；分布状态概率分布是 probability distribution，包括 uniform distribution（均匀分布）, geometric distribution（几何分布）, binomial distribution（二项分布）, Poisson distribution（泊松分布）, normal distribution（正太 正态分布）等（基本上就考这些）financialadj.财务的；金融的；财政的有一种输出格式叫 financial formatsecurityn.安全；保护；保障github 上，通常一个项目的顶部有 Code, Issues, Pull requests, Actions, Projects, Wiki, Security, Insights, Settings 这九个标签operatevi. &amp; vt.工作；运转；操作bool operator&lt; 这个还记得吧（想当年我是把 operator 这个词一个一个字母地记下来的）clinicn.门诊部；小诊所妖精仓库的医务室也是 clinic；在菈琪旭劝她不要对威廉下狠手之后，珂朵莉笑着离开了医务室（这里好喜感） roof“It’s okay! I caught her!’’ she yelled up, and Tiat’s mood improved immediately. “But it’s still dangerous, so no going on the roof for a while! Lead the other kids downstairs!’’（珂学必修 3） muddy“Um…” The girl, looking apologetic, was pulling on the muddy sleeve of his suit. Did I let my irritation show? “I… have to go home now.”（珂学选修 2-1） relevantYour output should contain K lines, one for each test case. On each line, output the two numbers X and Y for the relevant test case, separated by a space.（USACO 2015 January Contest, Bronze, Problem 3, It’s All About the Base）Between being kidnapped by fairies and being eaten by wild animals, the latter seemed to be the more relevant issue at the moment.（珂学必修 1） remoteremote: Resolving deltas: 100% (4/4), completed with 4 local objects.（git push 的信息） ridgeBessie the cow has escaped and is hiding on a ridge covered with tall grass.（USACO 2012 November Contest, Bronze, Problem 1, Find the Cow!） sniffI can sniff out enemies.（珂学必修 3） grillThe iron grill covering the ventilation duct (通风管) only had one screw (螺丝) left to fasten it on; just a little shake would probably bring it down.（珂学必修 3） leftover“Ow! It hurts there!”“It’s because the leftover Venom is making your muscles all stiff. If I can undo it, you’ll feel better.” （珂学必修 1） dry up“Why… why… “The surge of emotions began to dry up, and her screams turned into quiet sobs. Large teardrops flooded her eyes before dropping down to her knees, staining her skirt.（珂学必修 1） privilege“Being overprotective is the special privilege of a guardian!” Naigrat said with almost a shout, then dashed out of the reference room. combHis wavy and dull silver colored hair was difficult to comb.（珂学选修 2-1） distributeIt was hard to master the right time to breathe, to maintain her fluidity, to distribute her focus.（珂学选修 1-1） clinic“I remembered something I have to do, so I’m going to head out. Thanks for checking on me. As you can see, I’m all better now, so don’t worry.”“Ah, okay. But…” Lakish cautiously looked up at Kutori. “Don’t be too harsh… okay?”“What are you talking about?”（珂学必修 1）Kutori laughed and exited the clinic. Unit 5单词词性释义闲话adjust to适应威廉刚开始不适应妖精仓库悠闲的生活keep it up保持优秀成绩；继续干下去事实上这个短语还有一个一言难尽的意思，与人体某器官的生理特性有关（逃fit in相适应；相融和因为结果可能不适合 32 位整数，所以输出结果模 109+710^9+7109+7 的值motherlandn.祖国visan.签证还是一种信用卡的名字queuen. &amp; v.队列；排队queue, stackcafeterian.自助食堂；自助餐厅妖精仓库食堂的菜单底部，加上了新的“今日甜点”，后来又划掉了（真的很悲伤）lecturen. &amp; vi.演讲；讲课lecture notes 讲课笔记qualificationn.资格；资历Qualification Round 资格赛preparationn.准备recommendvt.推荐；建议自己一个人哭只适合有经验的知道什么时候停下来的大师，我不推荐初学者这么做（威廉你原来是这么安慰珂朵莉的吗）shopkeepern.店主店主原本是程序员，因为赚不到钱所以改行了（真实？）idiomn.习语；成语idiomatic 有习语化的意思（话说这个中文有出乎意料的意思啊）comfortn. &amp; vt.舒适；安慰substituten. &amp; vt.代替者；代用品；用……代替……substitute A for B = substitute B with A = B-&gt;A，如“用 nnn 替代 m+1m+1m+1”academicadj.学校的；学术的.ac 域名就是这么来的requirementn.需要；要求essayn.文章；散文tutorn.导师；助教；家庭教师revisevt.复查；修正；复习revisionn.复查；修正；复习有个叫 trinomial revision（中文翻译直接叫“三项式版恒等式”了）的东西，被列在“最重要的十个二项式系数恒等式”中，是 CrmCmk=CrkCr−km−k\\mathrm{C}^{m}_{r}\\mathrm{C}^k_m=\\mathrm{C}^{k}_{r}\\mathrm{C}^{m-k}_{r-k}Crm​Cmk​=Crk​Cr−km−k​draftn. &amp; vt.草稿；草案；草拟；起草Save draft 保存草稿numbadj.麻木的；失去知觉的珂朵莉十分伤心，喝了加辣椒粉的红茶，喝得腿都麻了（威廉你关心一下她啊）acknowledgevt.承认；确认；感谢论文的致谢是 Acknowledgement；珂朵莉一开始拒绝承认威廉为她创造的未来as far as one is concerned就……而言五百多年前威廉石化时，就他而言，他认为他已经死了contradictvt.反驳；驳斥contradictory 有矛盾的意思，contradict 也有矛盾的意思（这个意思也很常用）；这个词的词源与拉丁语中表示“I speak against”的词有关autonomousadj.自主的；自治的；独立的和 automatic（自动的）有意思上的区别，要多加注意occupyvt.占用；占领；占据这个词可以是 fill in time/space；数据保证没有两个国王占据同一个格子（it is guaranteed that no two kings occupy the same cell）be occupied with忙着做……店员忙于某件物品（the checkout assistant is occupied with some item）enterprisen.事业；事业心apologyn.道歉；谢罪你这样可是要向全国人民 apology 的seminarn.（专题）研讨会videophonen.可视电话“视频电话会议”Rugbyn.（英式）橄榄球bachelorn.获学士学位的人；未婚男子原来学士都是未婚男子（歧视警告）；某大学的准学士被要求写关于基因组的论文bachelor’s degree学士学位routinen. &amp; adj.常规；日常事务；通常的；例行的珂朵莉根据这几天威廉一般穿常服的日常判断，威廉要出事（出工）了minibusn.小型公共汽车optionaladj.可选择的；随意的“可选”选项标的就是 optionalday in and day out日复一日日子进入（滑动窗口），又离开（滑动窗口）cagen.鸟笼；兽槛barkvi. &amp; n.（指狗等）吠叫；咆哮；犬吠声；树皮有一个有趣的短语“barking up the wrong tree”，表示完全找错了原因或事物；比如泷在寻找三叶时曾认为他完全找错了地方batteryn.电池（组）；电瓶；炮台原电池（primary battery），然而干电池、蓄电池、电解池用的都是 cellsiten.地方；地点；现场website 是网站drillvi. &amp; vt. &amp; n.钻（孔）；钻机有意思的是，应急演练是 emergency drill，比如，（后来的报道认为，）彗星分裂那天丝守镇正在举行应急演练oilfieldn.油田事实上上面的 drill 就是用来开发 oilfield 的Lian.莉亚（女名）这篇文章中唯一收录的人名，当然是因为 Lia 是 IA 的 CV 啦agentn.代理人；经纪人User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36（无奖竞猜：这是什么浏览器呢？）travel agentn.旅行代办人geographicaladj.地理（学）的有个 geographically speaking 的说法（有点意思）paralleladj.平行的；相同的；类似的实在是太高频了，不背得都不好意思做题了abundantadj.丰富的；充裕的兰朵露可被科里拿第尔契市丰富的“剧目”所吸引governvt. &amp; vi.统治；支配；管理onwardsadv.向前地；前进地destinationn.目的地火车和地铁的显示屏上常显示的词innn.客栈各种酒店的名字里都有，此外威廉在必修五中也住在旅馆里out of the question不可能的；不值得讨论的特别注意 out of the question（不可能, not remotely possible） 与 out of question (without question, certainly) 的区别；让奈芙莲在地下偷袭第六兽是不可能的hikevi. &amp; n.远足；徒步旅行tombn.坟墓tombstone 是墓碑settle in（迁入新居、更换工作后）安顿下来 adjust toBut he had a difficult time adjusting to his new situation of not having various tasks looming over him 24/7.（珂学必修 1） fit inSince the result may not fit in a 32-bit integer number, print it modulo 1000000007 (109+710^9+7109+7).（Codeforces 241, Bayan 2012-2013 Elimination Round, B, Friends） cafeteriaAt the bottom of the cafeteria’s menu, a new 'Today’s Dessert’ item had been added, then crossed out.（珂学必修 4） recommend“Also, if you’re going to cry, let it all out while someone’s beside you. Crying by yourself is only for experienced masters that can tell when they’re going to stop crying. I can’t recommend it for beginners.”（珂学必修 1） shopkeeperWhen Ali entered a shop, he saw that the shopkeeper was a programmer and since there is no money in programming he had changed his career.（Codeforces 72, Unknown Language Round #2, E, Ali goes shopping） substituteThis can be rewritten as a binomial convolution, if we substitute nnn for m+1m + 1m+1 and add the term BnB_nBn​ to both sides.（具体数学英文版 365 页） numbNow wasn’t the time to lazily say I still can’t move my body. Kutori forced her numb and crackling limbs to move, jumping up on the spot.（珂学选修 1-1） acknowledgeHowever, Kutori refused to acknowledge other things. She could not reject the way of fighting with Dug Weapons used by the fairies that she had clung to for so long. Right now, her body moved with more ease than normal.（珂学必修 1） as far as one is concerned“Well anyways, it was a lot of trouble. Before I actually did it, I never heard of anyone waking up after being turned to stone. As far as I was concerned, I was basically dead. Since I had a load ofcurses on me in addition to being petrified, it took a lot of time and money to get me back in working condition. Thanks to that, ever since I awoke I’ve just been paying off debt.”（珂学必修 2） bachelorSome dwarves that are finishing the StUDY (State University for Dwarven Youngsters) Bachelor courses, have been told “no genome, no degree”. That means that all dwarves should write a thesis on genome.（Codeforces 186, Codeforces Round #118 (Div. 2), A, Comparing Strings） routine“…Huh?” A peculiar sensation gripped her heart. Something’s not right.It was almost time for their daily swordfighting practice. Judging by the routine of the last two days, Willem wore plain clothes when training.（珂学选修 1-1） barkOkudera: Wait, Taki, you sure about that?Taki: Yeah. I kinda feel like maybe I’ve been barking up the wrong tree this whole time.(shopkeeper): Hey. That’s a sketch of Itomori, isn’t it?（你的名字，00:48:48~00:49:04） drillA fragment of the comet destroyed a town in that disaster. But miraculously, most of the people living in the town were unhurt. The town happened to be holding an emergency drill that day, and most of its residents were outside the impact zone.（你的名字，01:35:25~01:35:40） abundantWhether it be a famous building, a curious little alley, or a seemingly random bronze statue right in the middle of the road, she never ceased to be amazed at the city’s abundant repertoire. Being by herself, she couldn’t help but stop every time she saw something.（珂学必修 5） out of the questionShould Nephren and the others perform a surprise attack on the nest now while we have the chance? No, that was also out of the question. Fighting underground would mean completely abandoning one of the fairies’ most important advantages: wings.（珂学必修 5）","categories":[{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"文化课","slug":"文化课","permalink":"https://sweetlemon39.github.io/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"英语","slug":"英语","permalink":"https://sweetlemon39.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://sweetlemon39.github.io/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"THUWC 2020 游记","slug":"THUWC-2020","date":"2019-12-25T00:00:00.000Z","updated":"2019-12-25T00:00:00.000Z","comments":true,"path":"THUWC-2020/","link":"","permalink":"https://sweetlemon39.github.io/THUWC-2020/","excerpt":"THUWC 2020 (2019?) 游记","text":"THUWC 2020 (2019?) 游记 Day −?-?−?THUWC 恰好在学考后一周，因此考完学考就进入了紧张的准备摸鱼中。停了两天课，还错过了学校里 IMO 二度金牌爷的讲座。停课前打 USACO，在一道区间 dp 上卡了 3 h，最后交了一个假做法强行把那道题过了，剩下的就没有时间写了；后来发现 T2 是一道还比较可做的树上问题，没写有点亏了。停课的时候打了 Codeforces 的一场 Virtual Contest，感受了很神奇的暴力；又做了 COCI 的 Contest 3，感觉比去年的 COCI Open 难多了，竟出现了代码极长的淀粉质，直接放弃实现了。感觉写的题目还是不够多，似乎本来可以写更多的题的。 Day −1-1−1为了机票便宜先到 TJ 中转。零下的温度感觉确实比较冷，但是也没有预想中那么冷？需要穿的衣服居然没有超过 333 件。飞机上凭印象写了 NTT，居然默写正确了。总感觉休息不足，非常困的样子。 Day 111Day 1 要从 TJ 出发，体验了一下复兴号的城际列车，确实比 D 字头的车快了不少。接着乘地铁去报到，发了一个有花纹的布制品，本以为是格子衫，仔细一看，“精品围巾”。嗯，说实话出于某种原因我还是比较想要红色的围巾（bushi。报到完就试机，这回是在系里的实验室考，电脑的系统似乎是 XUbuntu，不支持 Ctrl-Alt-T 打开终端似乎有些不习惯。看了看电脑里奇怪的软件，似乎只有 GIMP, Golden Dict 这两个，考虑到去年刚考图像，难道这回要考嘤语？桌面上还有 en.cppreference，难道要考毒瘤语言特性？反正根据这些信息，暂时猜不到 Day 3 考什么。注：题意简述可以在 ouuan 的博客 找到。 试机试机 T0 是 A+B，打了快读把它过了。T1 是一个有点奇怪的题目，大概是说有 nnn 个 A 类物品，权值分别为 a1,a2,⋯ ,an(ai∈Z)a_1,a_2,\\cdots,a_n(a_i\\in \\mathbb{Z})a1​,a2​,⋯,an​(ai​∈Z)；有 mmm 个 B 类物品，权值分别为 b1,b2,⋯ ,bm(bj∈Z)b_1,b_2,\\cdots,b_m(b_j\\in \\mathbb{Z})b1​,b2​,⋯,bm​(bj​∈Z)。现在请你把这些物品从左到右排列成一排，计算总权值如下：对于每一个物品，如果它左边的物品与它同类，那么它对总权值的贡献即为 aia_iai​ 或 bjb_jbj​；否则它对总权值没有贡献。特别地，最左边的物品对总权值没有贡献。要求总权值的最大值。似乎是一个奇怪的贪心，花了一些时间想，最后玄学地通过了。T2 好像是一道奇怪的树上计数题，模数是 998244353998244353998244353，而且旁边的选手还嚷嚷着让他的同学帮他调 NTT……看来这题不可做，直接跳了吧。T3 是一道字符串，给一个字符串 AAA 和 qqq 个字符串 BiB_iBi​，要把 BBB 插入到 AAA 的某一个地方（比如 A=abc,B=deA=abc,B=deA=abc,B=de，那么可以得到 deabc,adebc,abdec,abcdedeabc,adebc,abdec,abcdedeabc,adebc,abdec,abcde 这些），求插入到哪里时得到的字符串字典序最小。照例是不会做，所以直接用 string 打了暴力，居然拿了 404040 分？虽然试机有好多不会，但是反正也不太在意吧，所以也没有影响心态。中午急忙吃完饭，就回去合影和开幕式了。合影意外地没有拖太久，开幕式也进行得极快，“讲 888 点”值得好评。于是就到考场就位，略作等待之后，Day 1 就正式开始了。 Day 1 T1一道很有意思的题目。首先写了暴力，交上去拿点分爽一爽。因为觉得题目情景不复杂，所以便思考正解。我思考的点是“预处理当前工资计划是 iii 时，最终的工资计划应该是什么”，由于 kkk 很小，因此对每一个员工弄了一个单调队列，在单调队列上二分。后来发现这样确实可以通过，而且预处理时怎么做，查询时也相应地怎么做。于是花了约 1h1 \\mathrm{h}1h 愉快地通过了。 Day 1 T2一道比较恶心的题目。首先把比较容易的分数写了，接下来的却没有可以快速实现的思路了，于是决定去写 T3。 Day 1 T3首先把送的 888 分拿到了，接着又陷入了长时间而无效的思考中……据说北方冬天开了暖气的室内比较催眠，这是真的。再加上昨天晚上不适应这里的环境没有睡好，所以真的是越想越想睡。强行去洗了洗脸，好不容易清醒了。回来看看还剩下的许多时间，决定回去写 T2。T2 有一个“树”的 131313 分，似乎可以用树剖暴力地解决掉。再看一眼时间，写吧。于是开始写树剖、线段树。时间过得很快也很慢，我不停地写啊写啊，简直都不知道自己在写什么。dfs1, dfs2, build_tree, pushdown, … 终于似乎是写完了，我甚至都不想再看代码，直接跑样例。修改了一点小的错误后，过了样例。直接交！猛按几下 F5 过后，那个测试点旁边显示出了 Accepted 的文字。什么？我默写的树剖就这么通过了？我不放心地再浏览了一遍代码，找不出明显的问题，才终于判定——树剖应该是写完了。这是我 OI 生涯中至今考场上写的最长的代码了吧，总长度近 400400400 行，大小近 10KB10 \\mathrm{KB}10KB，可惜不能带回去纪念。还剩大约半个小时，剩下的点似乎怎么也过不了，T3 也毫无思路。最后在玄学修改程序中度过消磨了最后半个小时。 Day 1 总结Day 1 的话题目确实超出了我的水平范围吧，不过好在我在 2.5h2.5\\mathrm{h}2.5h 时放弃 T3，并决定去写树剖，否则后半段真的要一无所获了。 Day 2早上早起到西郊宾馆吃了早餐，种类还算比较丰富，大吃一顿后上了大巴。大巴上照例听了 Euphoria。同样稍作准备后就开考了。 Day 2 T1一道比较神奇的题目。有 n(1≤n≤15)n(1\\le n\\le 15)n(1≤n≤15) 个函数 f1,f2,⋯ ,fnf_1,f_2,\\cdots,f_nf1​,f2​,⋯,fn​，每个函数形如 fi(x)=ai∣x∣+bix+cif_i(x)=a_i\\vert x \\vert+b_ix+c_ifi​(x)=ai​∣x∣+bi​x+ci​，给定初始值 xxx，你需要安排函数复合的顺序，使得最终函数值最大；也就是你需要给出 1⋯n1\\cdots n1⋯n 的一个排列 p1,p2,⋯ ,pnp_1,p_2,\\cdots,p_np1​,p2​,⋯,pn​，使得 fpn(fpn−1(fpn−2(⋯(fp1(x)))))f_{p_n}(f_{p_{n-1}}(f_{p_{n-2}}(\\cdots(f_{p_1}(x)))))fpn​​(fpn−1​​(fpn−2​​(⋯(fp1​​(x))))) 最大。x,ai,bi,ci∈[−15,15]x,a_i,b_i,c_i\\in [-15,15]x,ai​,bi​,ci​∈[−15,15]，允许使用 __int128。首先还是写了 n≤10n\\le 10n≤10 的枚举暴力。接着注意到 nnn 很小，回想到我在 THUSC 2019 吃的亏，考虑状压 dp。状压 dp 要满足子问题最优特性，为了满足这一点，我在草稿纸上画了一下函数的图象，发现 fif_ifi​ 一定是拐点在 yyy 轴上的一条折线，在 yyy 轴两侧都是单调的。因此，使得 f(x)f(x)f(x) 最大的 xxx 只有四种可能：最大的正数、最小的负数、最大的负数、最小的正数，也就是 ±∞\\pm \\infty±∞ 的极限和 000 的左右极限。因此就有了一个很诡异的方法：把状态记为已经复合的函数的集合，也即 p1,p2,⋯ ,pkp_1,p_2,\\cdots,p_kp1​,p2​,⋯,pk​ 的集合；对每一个状态维护可能达到的“最大的正数、最小的负数、最大的负数、最小的正数”这四个值，转移的时候把前驱状态的所有结果塞到函数里，排个序，再把最小值、最大值、000 的前驱和后继全部塞到新状态的 vector 里面就好了。没想到这种看上去十分暴力的解法居然过了，不过其实它的复杂度似乎是正规的 O(2n⋅nlog⁡n)O(2^n\\cdot n\\log n)O(2n⋅nlogn)。 Day 2 T2还是照例先写暴力，接着总觉得“部分分好像都可做”，然后去打部分分。首先是把 a=1a=1a=1 的 Subtask 4 写了，然后发现自己欠考虑了，连稍大的样例都没过。接着就强行打补丁，把漏考虑的情况写了写，终于过了这个 Subtask。其他的 Subtask 好像也有些可做，我甚至还写了 Subtask 3 的程序，可惜是个假做法。想要打补丁，可越想情况越复杂，但写了代码又舍不得放弃，况且 T3 的劝退模数又让我不禁接着想 T2……换题的时间到了，我最终还是放弃了其他 Subtask，把过了 Subtask 1,4 的代码重新交了上去。 Day 2 T3写了暴力，结果暴力超时了，只拿到送的 111 分……实在是太自闭了，在本地一看，n=10n=10n=10 的预处理就要跑好久好久……根本过不了啊。看来纯暴力是不行了。我再想了想，可以不用处理 A101+A102+⋯+A1010A_{10}^1+A_{10}^2+\\cdots+A_{10}^{10}A101​+A102​+⋯+A1010​ 种排列，只需要处理 1!+2!+⋯+10!1!+2!+\\cdots+10!1!+2!+⋯+10! 种，最终把诸如 3,9,13,9,13,9,1 这样的排列映射（离散化）成 2,3,12,3,12,3,1 就好了。加了这个小优化，尽管本地跑得还是很慢，但是交上去居然过了？旁边的同学其实给我一定压力，他不停地（真的是不停）大声（真的很大声）击打（真的是击打）键盘，嗯……在想到“排列映射”的时候，我有了一个偷懒的想法：会不会“满足某种特征”的排列，它们的答案是一样的呢？如果找到这种“特征”，那我就不用写映射了。事实上，只要找到了“特征”，再加以打表，就可以告别暴力了！于是我走上了漫长的打表之路。首先根据冒泡排序的特征，第 kkk 轮后，第 k,k+1,⋯ ,nk,k+1,\\cdots,nk,k+1,⋯,n 大值一定是已经归位的；因此如果没有归位，答案一定是 000。接着，我观察到，顺序排列 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 的值很有特点；而其他排列就是在部分重复顺序排列的答案！只是重复的不太一样，有的重复的是 n−1n-1n−1 的，有的重复的是 n−2n-2n−2 的。是什么决定了它重复的是哪里的呢？我首先试了逆序数，因为题面里提示了“逆序数不断减少”，但是并不对；我又尝试了“n−1n-1n−1 的位置”、“111 的位置”等奇奇怪怪的指标，发现都不对。还剩一个小时，真是自闭啊。更神奇的是，旁边的同学还小声喊了一句，“我找到了”（之类的话）……最终鬼使神差，我找到了规律——把这个排列做一轮冒泡排序（只做一轮！），这一轮中交换了 kkk 次，那重复的就是 n−kn-kn−k 的顺序排列的前几个答案。真是……神奇啊。然后就是写咯，知道规律了就能多拿好些分，但是更复杂的 Subtask 由于我不知道如何维护信息所以也写不了，最后还有约二十分钟的时候算是结束了所有可得分代码的书写。 Day 2 总结Day 2 的启示主要就是要放弃吧，要是我不停地肝 T2 那恐怕是什么结果也没有。然后就是要坚持打表，即使一时找不出规律也要硬着头皮找（大雾）。 Day 3 (Day 2+)Day 2 考完回去好好睡一觉，其实没有睡多长时间，就到 THU 的食堂体验了一下。THU 的食堂真的非常超值，444 元的排骨简直有 nnsz 两倍的量，这也许就是我们在那里买饭卡只能使用 70% 金额（充 20 可用 14）的原因吧，专项补贴挺多的。由于 THU 的食堂太超值了，所以我吃不完，在还有不到半小时开考的时候骑车赶去考场。到了考场发现笔不见了，我只有一支笔啊啊啊，这还是学习题，要做笔记的啊啊啊……最后强行镇定下来，决定用 gedit 做笔记。进场拿密码条，看到了“简单 Cache 系统实现”的标题，然后就在脑内回想，“关于 Cache 你有什么印象”，答案是什么印象都没有（雾），只知道这个东西和卡常数有关。然后开考了。开考发现学习手册不知道在哪里，以为是我没找到，结果大家都没有。监考说“大家先看题吧”，结果这题没有学习手册根本看不懂，什么“Cache 一致性协议”，“MESI”？但是我“因祸得福”地看到了 T2 的一句话“这些算法的实现难度不一，请选手自行选择”，就明白了一定要做好放弃的准备。终于发学习手册了，并且考试结束时间延迟 5min5\\mathrm{min}5min。后来发现这 5min5\\mathrm{min}5min 可能让我多拿了几十分。先花了约半个小时看了学习手册，并且认真地用 gedit 做了提纲（没有 Typora，不能写 Markdown，不能看着左边的“大纲”，真不爽）。看学习手册的时候有意识地跳过了“伪最近最少使用”和某名字特别复杂需要参考论文的算法。可是看到最后的“Cache 一致性协议”就非常难受，不停地有“看不懂”的感觉，不过还是硬着头皮扫了扫，发现后来都是技术性内容，所以就跳过了。看第一题，就是 Cache 一致性协议。而且就是要实现那些技术性内容。好吧好吧，我写我写。把状态编了数字编码，然后照着状态转移的表格写了下去，由于以为后面的题目还要用到这个程序，我稍微注意了一下接口的实现（虽然还是一个很丑陋的过程式接口，没有 OOP）。写完照着样例调了调，发现出入还挺大，最终发现是我把不需要打印的 Flush 事件也打了出来。调整之后，就通过了。第一题就把学习手册最后的内容给写了，那后来岂不是要很难？结果看了第二题，发现考的是前面的“Cache 替换算法”。呃，这个不是很简单的数据结构的应用么——除了被我放弃的“伪最近最少使用”部分（这个比较难写的部分拥有其他部分两倍的分数）。再看一眼范围，n≤16n\\le 16n≤16，本来都把堆的头文件引入了，干脆暴力了吧。暴力写完调一调，发现过不了样例？最终发现是自己被 T1 惯坏了，没有理解好“块”的概念，于是又重读 Cache 映射方式一节。经过几次尝试终于把“块”处理好了，这段处理“块”的代码也在之后的几道题一直沿用。接着看 T3，只读 Cache 实现？充分利用 T2 的代码，似乎不难写好。原来 T1 那些复杂的东西在后面的题目都没有用啊。还有一点时间，写一写 T4——读写 Cache 实现？似乎也不难吧，不就是要处理一下“脏”数据（没有与主存同步的数据）嘛。认真思考了一下，一个数据只有在写 Cache 的时候才有可能被标记为脏，只有在从 Cache 写入内存的时候才能消除脏标记，因此在这些时候对应维护好脏标记就行了。写完发现不对，检查了输入数据的部分，发现脏数据部分要先读后写。改成先读后写之后还是错了，还剩几分钟，确实有些紧张，想着“也许这个调不出来了”。后来重新审读了那一段代码，发现问题是，改成“先读”之后读的数据把原来的脏数据覆盖了，“再写”的时候写的就不是那份脏数据了。于是把脏数据用临时变量存一下，就解决了。交上去发现“000”和“111”的部分过了，“0,10,10,1”混合的部分却没过。仔细想了想，大概是因为“伪最近最少使用”出现了的缘故吧。T5 是“某算法”实现？看上去完全不可做，但是它的题目和 T4 基本相同？想着出题人可能会放一点水，我把 T4 的程序交了上去，结果过了好几个 Pretest，也许白得了几十分啊。最后还剩不到一分钟，就把我写的大纲交到 T6 “期待你的声音”上面去了。比赛结束后看了看“伪最近最少使用”，其实也不是特别难写，但是要是我真的写了这种算法怕是要少几十分。又看了一眼“某算法”的论文，十几页英文论文。。比学习手册还长不少。我知道 Golden Dict 是什么用的了。虽说我那几天停课也曾看过几眼嘤文论文，是一篇“O(n)O(n)O(n) 点分治”的（把树分成 O(nlog⁡n)O(\\frac{n}{\\log n})O(lognn​) 块之类的，一看就觉得常数很大）；但是这么长的，实在是…… Day 3 总结感觉这场发挥非常好，应该是我目前学习题的极限了吧。做大纲这一点应该挺好的，这样我对整个学习手册的内容就有一个把握；另外“想好什么东西在什么时候会改变”应该也挺重要。还有就是调试要有一定的信心，不要总想着自己会写错很多地方。此外要学会放弃！停课那几天写了 CyaRon 语言（虽然是用 Python + regex 水过去的）、时间复杂度、LOGO 语言这些题目，也算是增加了学习题的信心吧。今后还可以把宝牌一大堆给补了。 面试与宣讲考完机试还挺有信心，觉得这回应该能进面试了吧。结果从 7:50 等到 8:10，一直没有电话。8:10 我去吃饭，在西郊宾馆餐厅等到 8:40，还是没有电话……心里想着“我哪里写炸了呢”，然后又考虑早上去哪里玩。结果 9 点左右突然接到我妈电话，说我爸刚刚接到电话。不是说好的 7:50~8:40 通知面试吗？然后我问“什么时候要去？”——“现在。”还好我早餐吃得差不多了——要是我决定去北京三环内玩，那我岂不是已经赶不回来了？整理了一下仪容仪表——在此特别感谢我爸出发前帮我剪的头发——就去会议室报到了。之前有看 ouuan 的博客了解到大概的注意事项，所以就在等候的时候写自我介绍。在手机上写了 900 多字，又请我妈提意见，删到了 700 多字，于是就被叫到门外等候了。等候的时候把稿子读了两遍多，就进场了。没想到的是自我介绍只有 1∼2min1\\sim 2\\mathrm{ min}1∼2min，我只好在说的时候自动删除内容。自我介绍的时候我还有一些紧张，不过强行调整过来了。自我介绍完毕是面试官就自我介绍中的内容进行提问，居然问了“文化课成绩如何”、“你们学校多少人”、“每年多少个清华北大”之类的问题，之后就问了“你的嘤语怎么样”，自然过渡到嘤语阅读了？而且还要求出声朗读，感觉自己哑巴嘤语被发现了。文章里面大量出现 LBS(Location Based Services)，还有 privacy，根据嘤语老师教授的嘤语阅读技巧——画框架，我算是大概理解了文章的 structure。之后面试官问我“What’s the passage mainly about”（事实上，是用中文问的），我就抓住了这两个词。似乎面试官还比较满意？此后就问我开发的小程序的主要架构啊，还有我无意提到的 FFT 的原理啊什么的，感觉我回答得自己还算满意。接着计时器“嘀嘀嘀嘀”地响了，就顺势结束了。感觉表现得还算满意吧，估计也是了解了大概流程的原因吧。下午的宣讲居然没有讲题，差评。一开始的关于 THU 科研生活的宣讲还比较有收获，再次说明了我和强省学生在综合能力上的差距。后面的宣讲就显得主题不突出，十分催眠了。据说今年发的纸非常多，那想必也是没有什么用的。 休闲娱乐和后续晚上去了一趟国图，TP 的书真的非常多（比数理化加起来的两倍还多），可能是因为这个阅览室是面向大众的吧。然后各种大学教材特别多，不禁让人怀疑是否应该留更多的空间给专著，毕竟各种教材的内容都基本相近嘛。第二天没做什么，下午就回校了。早上还有幸看到了一次小雪，不过雪粒就像碎屑一样小，也没有特别壮观……一上文化课才知道，化学已经上到了“不认真学就会导致选修 4 完蛋”的化学平衡了，看来选 4 要完蛋了～（逃 致谢这次首先要感谢父母的陪伴，让我在 BJ 都方便了很多。接着要感谢老师同学们的鼓励，让我更有信心。最后还是给 Hanakiko~希望这篇流水帐一样的游记也能给今后去 THUWC/THUSC 的同学一点帮助吧。","categories":[{"name":"总结","slug":"总结","permalink":"https://sweetlemon39.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"THUWC","slug":"THUWC","permalink":"https://sweetlemon39.github.io/tags/THUWC/"}]},{"title":"CSP 2019 集训 数学","slug":"CSP2019-math","date":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-math/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-math/","excerpt":"数学","text":"数学 gcd 定义与证明定义：gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 定义为最大的 ddd，使得 d∣a,d∣bd\\mid a,d\\mid bd∣a,d∣b。gcd⁡(a,b)=gcd⁡(b,a%b)\\gcd(a,b)=\\gcd ( b,a \\% b )gcd(a,b)=gcd(b,a%b) 的证明：设 a=bq+ra=bq+ra=bq+r。假设 d∣bd\\mid bd∣b，则可以由上式证明 d∣ad\\mid ad∣a 等价于 d∣rd\\mid rd∣r。证毕。 CQOI 2014 数三角形用（简单）容斥原理，用三点组的个数减三点共线情况的个数。如何计算三点共线情况的个数呢？回忆这个定理：定理 2.332.332.33 设 A(0,0),B(n,m)(n,m∈N+)A(0,0),B(n,m)(n,m\\in \\mathbb{N}_{+})A(0,0),B(n,m)(n,m∈N+​)，那么线段 ABABAB 上整点的个数即为gcd⁡(n,m)+1\\gcd(n,m)+1gcd(n,m)+1。（——能量采集）只要暴力找出所有直线即可。 exgcd 算法证明根据数论基础知识，ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)（a,ba,ba,b 是给定正整数，x,y∈Zx,y\\in Zx,y∈Z）有无数组解。并且，如果我们可以在欧几里得算法的过程中维护这个方程的解，那么就能在计算出 gcd⁡\\gcdgcd 的同时把解也算出来。首先，当 b=0b=0b=0 时，这个方程的解就是 (x,y)=(1,0)(x,y)=(1,0)(x,y)=(1,0)。接着，假设 a=bq+ra=bq+ra=bq+r，设 bx′+ry′=gbx&#x27;+ry&#x27;=gbx′+ry′=g，我们需要找出一组使得 ax+by=gax+by=gax+by=g 的 (x,y)(x,y)(x,y)。把 a=bq+ra=bq+ra=bq+r 代入上面的式子得 bqx+rx+by=gbqx+rx+by=gbqx+rx+by=g，也就是 b(qx+y)+rx=gb(qx+y)+rx=gb(qx+y)+rx=g。把这个式子与 bx′+ry′=gbx&#x27;+ry&#x27;=gbx′+ry′=g 比对即得 qx+y=x′,x=y′qx+y=x&#x27;,x=y&#x27;qx+y=x′,x=y′，也就是 (x,y)=(y′,x′−qy′)(x,y)=(y&#x27;,x&#x27;-qy&#x27;)(x,y)=(y′,x′−qy′)。 青蛙的约会随便推一下式子就可以得到 t(n−m)+sL=x−yt(n-m)+sL=x-yt(n−m)+sL=x−y，其中只有 s,ts,ts,t 是整未知数。先把两边都除以 gcd⁡(n−m,L)\\gcd(n-m,L)gcd(n−m,L)，标准化之后用 exgcd\\mathrm{exgcd}exgcd 求解就行了。 小凯的遗憾 疑惑证明起来似乎挺长的，还是要注重打表找规律。 快速幂 (kasumi) 与费马-欧拉定理 费马小定理费马小定理：ppp 是质数，那么 ∀a∈[1,p),ap−1≡1(modp)\\forall a\\in [1,p),a^{p-1}\\equiv 1\\pmod{p}∀a∈[1,p),ap−1≡1(modp)。当然可以用“元素的阶整除群的阶”证明。这里提供一个使用二项式定理的证明方法。(a+1)p=ap+Cp1ap−1+Cp2ap−2+⋯+Cpp−1a+1(a+1)^p=a^p+\\mathrm{C}^1_pa^{p-1}+\\mathrm{C}^2_pa^{p-2}+\\cdots+\\mathrm{C}^{p-1}_pa+1(a+1)p=ap+Cp1​ap−1+Cp2​ap−2+⋯+Cpp−1​a+1。由于 ppp 是质数，因此 Cp1,Cp2,⋯ ,Cpp−1\\mathrm{C}^1_p,\\mathrm{C}^2_p,\\cdots,\\mathrm{C}^{p-1}_{p}Cp1​,Cp2​,⋯,Cpp−1​ 的分母都没有 ppp 因子，分子有 ppp 因子，因此这些数都是 ppp 的倍数。因此 (a+1)p≡ap+1(a+1)^p\\equiv a^p+1(a+1)p≡ap+1，从 0p≡00^p\\equiv 00p≡0 即可归纳出 ap≡aa^p\\equiv aap≡a。移项得 a(ap−1−1)≡0a(a^{p-1}-1)\\equiv 0a(ap−1−1)≡0。由于 a∈[1,p)a\\in [1,p)a∈[1,p)，因此两边除以 aaa（乘以 aaa 的逆元）即得 ap−1≡1a^{p-1}\\equiv 1ap−1≡1。 逆元如何求逆元呢？可以用 kasumi\\mathrm{kasumi}kasumi 配合费马-欧拉定理，也可以用扩展欧几里得。这里提供两种 O(n)O(n)O(n) 线性推逆元的方法。第一种是经典方法。设 p=aq+r (0&lt;r&lt;a)p=aq+r\\ (0&lt;r&lt;a)p=aq+r (0&lt;r&lt;a)，那么 aq≡−raq\\equiv -raq≡−r，a−1≡−qr−1a^{-1}\\equiv -qr^{-1}a−1≡−qr−1。这种方法仅适用于 ppp 是质数的情况。第二种利用了阶乘。我们可以在 O(n)O(n)O(n) 时间内计算出 1!,2!,⋯ ,n!1!,2!,\\cdots,n!1!,2!,⋯,n!。接着我们用某一种方法计算出 (n!)−1(n!)^{-1}(n!)−1，并递推 ((n−1)!)−1≡n×(n!)−1((n-1)!)^{-1}\\equiv n\\times (n!)^{-1}((n−1)!)−1≡n×(n!)−1。于是 x−1≡(x−1)!×(x!)−1x^{-1}\\equiv (x-1)!\\times (x!)^{-1}x−1≡(x−1)!×(x!)−1。这个方法也许比经典方法快，而且适用于 ppp 不是质数的情况（但是 nnn 必须小于 ppp 的最小质因子）。而且由 (n!)−1(n!)^{-1}(n!)−1 递推 ((n−1)!)−1((n-1)!)^{-1}((n−1)!)−1 的方法也可以用于分段打表计算阶乘的逆元。 计算系数 组合数问题这两道题都涉及 C\\mathrm{C}C 的计算。可以灵活地运用定义式和杨辉三角递推式，在合适的场景使用合适的式子简化计算。也就是，如果 nnn 只有 200020002000，那么使用杨辉三角就足够了。 中国剩余定理如果 p1,p2,⋯ ,pnp_1,p_2,\\cdots,p_np1​,p2​,⋯,pn​ 互质，那么下面方程组{x≡a1(modp1)x≡a2(modp2)x≡a3(modp3)⋮x≡an(modpn)\\begin{cases}x \\equiv a_1\\pmod{p_1}\\\\\\\\ x\\equiv a_2\\pmod{p_2}\\\\\\\\ x\\equiv a_3\\pmod{p_3}\\\\\\\\ \\vdots\\\\\\\\ x \\equiv a_n \\pmod{p_n}\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​x≡a1​(modp1​)x≡a2​(modp2​)x≡a3​(modp3​)⋮x≡an​(modpn​)​在 mod p1p2⋯pn\\mod{p_1 p_2 \\cdots p_n}modp1​p2​⋯pn​ 意义下有唯一解。如何求这一组解呢？这里有一个神奇构造。令 M=ΠpM=\\Pi pM=Πp，则 Mi=Πj=1i−1pj×Πj=i+1npjM_i=\\Pi^{i-1}_{j=1} p_j \\times \\Pi^{n}_{j=i+1} p_jMi​=Πj=1i−1​pj​×Πj=i+1n​pj​，于是 tit_iti​ 是 MiM_iMi​ 在 mod pi\\mod{p_i}modpi​ 意义下的逆元。那么令 x=∑i=1naiMitix=\\sum_{i=1}^n a_iM_it_ix=∑i=1n​ai​Mi​ti​ 即可。如果考场上不记得神奇构造了，那就可以用 exCRT\\mathrm{exCRT}exCRT。主要应用还是合并同余方程。 各种筛 Violet 5 樱花求不定方程 1x+1y=1n!\\frac{1}{x}+\\frac{1}{y}=\\frac{1}{n!}x1​+y1​=n!1​ 的正整数解数量。令 m=n!m=n!m=n!。由于每一个 xxx 唯一对应一个 yyy，因此我们可以把 yyy 用 xxx 表示，得到 y=xmx−my=\\frac{xm}{x-m}y=x−mxm​。接着用分母换元法，令 x−m=tx-m=tx−m=t，y=(m+t)mt=m2t+my=\\frac{(m+t)m}{t}=\\frac{m^2}{t}+my=t(m+t)m​=tm2​+m。于是 yyy 为整数的充要条件为 t∣m2t\\mid m^2t∣m2。同时，对 m2m^2m2 的每一个因子 ttt，都可以唯一确定一组 (x,y)(x,y)(x,y)。因此只需要求 m2m^2m2 的因子数，这只需要把 n!n!n! 质因数分解就可以了。因此对于这样的题目，进行必要的数论变换是非常重要的。 高精度不要写错。 LLH邀请赛 大数计算器求 Cnr\\mathrm{C}^r_nCnr​ 的前 333 位和去除所有末尾 000 后的后 999 位。后 999 位相当于模 10910^9109，直接用 泳装 一题的方法，把因子 222 和因子 555 分开处理即可。前 333 位怎么做呢？long double 信仰过？太大了，连 long double 都会爆啊。取一个 ln⁡\\lnln 然后相加减，最后 exp⁡\\expexp 吧。在对精度要求不高的时候，取对数也是不错的方法。 解方程枚举是不是解的时候在模意义下进行，判断是不是真的解的时候用高精。当然也可以凭信仰，选取几个模数，把所有系数也取模，在这几个模意义下都进行运算，如果都满足方程就“认为”这个数真的是解了。 容斥原理（经典型） Cirno 的完美算数教室暴力容斥，暴力出奇迹，记得加剪枝。 HAOI 2008 硬币购物这个背包很有特点，物品种类很少，但是背包容量和物品数量很大，肯定不能 dp\\mathrm{dp}dp 或搜索。那么我们就用数学方法。设第 iii 种硬币用了 xix_ixi​ 枚，那么 c1x1+c2x2+c3x3+c4x4=sc_1x_1+c_2x_2+c_3x_3+c_4x_4=sc1​x1​+c2​x2​+c3​x3​+c4​x4​=s，限制是 0≤xi≤di0\\le x_i\\le d_i0≤xi​≤di​。假如没有限制，那么这题就是一个简单的隔板法，把定义域下界上调到 111 就行了。那么现在有了限制，就计算出各种“不符合限制”的情况，用容斥原理计算就行了。具体地，用“总方案数”减去“至少某一种硬币不符合限制”的方案数，加上“至少某两种硬币不符合限制”的方案数，减去“至少某三种硬币不符合限制”的方案数，最后加上“四种硬币都不符合限制”的情况。 博弈论 取石子游戏 1 ——理解必胜和必败态只有一堆石子，每次拿 [1,k][1,k][1,k] 个，不能拿的输。画状态图可以发现 0,k+1,2(k+1),⋯0,k+1,2(k+1),\\cdots0,k+1,2(k+1),⋯ 都是先手必败，其余都是先手必胜。接下来归纳证明即可。 取石子游戏 2 ——组合游戏和 SG 函数有 nnn 堆石子，每次可以在一堆石子中拿任意多个，不能拿的输。这个东西不用 SG 做实在不太行啊。关于组合游戏和 SG 函数、SG 定理的理解，详见在学军的笔记。Nim 是经典模型，SG(x)=x\\mathrm{SG}(x)=xSG(x)=x。如果针对 Nim 游戏，那么可以比较简单地对“异或方法”的可行性进行证明。取异或值的最高位。由于这一位是最高位，因此一定存在一堆石子，它的石子数这一位为 111。令这一堆留下来的石子数恰好使得异或值为 000，那么留下来的石子数在那一位是 000，于是留下的石子数少于原来的石子数，也就是这种取的方案是一定可行的。这样异或值非零一定能转移到异或值为零的状态。而异或值为零的状态只能转为异或值非零的状态，且终态异或值为零。于是证毕。 取石子游戏 3 ——游戏 1 和游戏 2 的结合有 nnn 堆石子，每次可以在 [1,k][1,k][1,k] 堆石子中拿任意多个，不能拿的输。考虑 k=1k=1k=1，那么就是游戏 2；若 ai=1a_i=1ai​=1，那么就是游戏 1。因此这一个游戏是这两个游戏的结合。又来一个神奇操作。把每一堆都用二进制表示，计算每一个二进制位","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"CSP 2019 集训 搜索和数据结构","slug":"CSP2019-search-and-ds","date":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-search-and-ds/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-search-and-ds/","excerpt":"解题技巧","text":"解题技巧 打表 完美数输出区间完美数数量。判断一个数是不是完美数是容易的。要求区间完美数数量，其实就是要快速算出前缀和。前缀和……是不是类似于阶乘？分段打表！打表间隔 10610^6106 就可以了。 搜索 剪枝 虫食算从低位向高位搜索，因为低位没有未确定的进位。确定了一列的值之后马上验证。枚举整数的顺序的话……比较玄学地从大到小？另外据说这题的正解是高斯消元？ 整数分解重点是“不同正整数”。被分解的数一定是 nnn 的约数，先把约数数组 O(n)O(\\sqrt{n})O(n​) 搞出来。接着从小到大枚举约数，dfs(tn,tk,tp) 表示剩余的数是 tn\\mathrm{tn}tn，还需要分解成 tk\\mathrm{tk}tk 个数，当前已经在约数表中使用了前 tp\\mathrm{tp}tp 个数。剪枝是如果可选的最小的 tk\\mathrm{tk}tk 个数都超过 tn\\mathrm{tn}tn 就剪掉。 综合深搜技巧 骑士精神不超过 151515 层，还是有迭代加深的道理的。另外使用一个简单的乐观估价函数进行剪枝。另外既然已经有乐观估价函数了，也可以 A*。 （类似送礼物的）背包问题背包，物品数 ≤40\\le 40≤40，体积 ≤109\\le 10^9≤109。404040 这个数字太敏感了，马上 Meet in the Middle。 集合划分“相等”的限制条件让我们想到，枚举两个集合 A,BA,BA,B，若 A∪B=∅A\\cup B=\\varnothingA∪B=∅ 且 ∑A=∑B\\sum A=\\sum B∑A=∑B，则 A,BA,BA,B 为一组合法划分方案。由于 A∪B=∅A\\cup B=\\varnothingA∪B=∅，因此上面的方法比较冗余——会产生大量的重复集合。我们有更好的避免重复的方案：令 CCC 是前 n2\\frac{n}{2}2n​ 个数组成的集合的划分方案（决定每个数在 AAA 中、在 BBB 中、都不在）， DDD 是后 n2\\frac{n}{2}2n​ 个数组成的集合的划分方案，这样 A∪B=∅A\\cup B=\\varnothingA∪B=∅ 就自然成立了。C,DC,DC,D 各有 3n23^{\\frac{n}{2}}32n​ 种。并且，设一种划分方案的权值是 ∑A−∑B\\sum A-\\sum B∑A−∑B，那么两种权值互为相反数的方案合起来可以构成一种合法方案。但是注意！题目求的不是合法的划分方式数量，而且合法的能被划分的集合数量；也就是 A∪BA\\cup BA∪B 的数量。因此，我们还要记录 C,DC,DC,D 中 A∪BA\\cup BA∪B 的值，设为属性 sss。下面我们的任务就是，对右半的所有 (w,sr)(w,s_r)(w,sr​) 对，找出左半中所有的 (−w,sl)(-w,s_l)(−w,sl​) 对，并标记 visited[sl∪sr]\\mathrm{visited}[s_l \\cup s_r]visited[sl​∪sr​]。我们可以想到一个简单的做法：把左半按 www 排序，接着对于右半里的每一种划分，二分找出左半中所有的 (−w,sl)(-w,s_l)(−w,sl​) 对，一一标记即可。还有一个小优化，左右半都可以排序后 unique 一下，即 www 和 sss 都相等的对，只保留一个。这样做的复杂度怎么分析呢？对于每一个 srs_rsr​，它的所有不同的 www 的总扫描长度（即扫描左半数组的长度）不会超过 3n23^{\\frac{n}{2}}32n​，也就是最多把左半数组扫完；二分查找复杂度 O(log⁡3n2)O(\\log {3^{\\frac{n}{2}}})O(log32n​)，因此总计算量大概是 O(2n2×3n2+3n2×log⁡3n2)≈O(6n2)≈6×107O(2^{\\frac{n}{2}}\\times 3^{\\frac{n}{2}}+3^{\\frac{n}{2}}\\times \\log 3^{\\frac{n}{2}})\\approx O(6^{\\frac{n}{2}})\\approx 6\\times 10^{7}O(22n​×32n​+32n​×log32n​)≈O(62n​)≈6×107。当然还有一个不需要二分查找的方法。把右半以 sss 为第一关键字、www 为第二关键字排序，再按 sss 分成小块，每个小块内 www 是单调的，这样就可以在左半用双指针单调移动，去除掉这个 log⁡\\loglog。当然，扫描的复杂度可能也不小，因此这个优化可能差异不大。总之，当 nnn 比较小，你的算法没有很好地利用限制（“相等、不等、不交”）时，可以考虑 Meet in the Middle，从而更好地利用限制。 nnn 皇后用二进制优化哪些地方可选即可加快速度。 广搜 八数码有明确的目标局面，可以使用双向广搜。有简单的估价函数，可以使用 A*。也可以写 IDA*。我原先写的 fake A* 不知道怎么过去的。 华容道考虑搜索的状态是 (sx,sy,bx,by)(s_x,s_y,b_x,b_y)(sx​,sy​,bx​,by​)，分别表示目标棋子的位置和空白的位置。空白的位置这个状态很浪费啊——空白只有在目标棋子的四连块处，目标棋子才能移动。因此移动可以分为两类：目标棋子的移动——与目标棋子的起点和终点有关空白格的移动，即非目标棋子的移动——与空白格的位置、目标棋子的位置和空白格在目标棋子的方向有关。这种移动的目的是，把空白格移到目标棋子四连块的某一位置，从而使目标棋子移动。这两类的变量不太一样，我们考虑分开处理。由于第二类与输入关系较小，因此先预处理第二类移动情况。设 g[sx][sy][bx][by][d]g[s_x][s_y][b_x][b_y][d]g[sx​][sy​][bx​][by​][d] 表示把 (bx,by)(b_x,b_y)(bx​,by​) 处的空白格移动到 (sx,sy)(s_x,s_y)(sx​,sy​) 处的目标棋子的 ddd 方向的最短距离，移动的过程中目标棋子不能动。在计算 ggg 的过程中，我们只需要把目标棋子临时标记为不可动，状态只记空白格子的位置即可。预处理了第二类的移动情况，实际上总的移动就变成了：空白格移动到目标棋子四连块——目标棋子移动——空白格移动——目标棋子移动——空白格移动……不妨枚举最开始时空白格在目标棋子的哪一个方向，再把状态记为 (sx,sy,d)(s_x,s_y,d)(sx​,sy​,d)，表示目标棋子的位置和空白格的方向。这样……就是一个图了！图上的边有两类——当然是空白格移动（边权根据 ggg 可得）和目标棋子移动（边权为 111）啦。最后就是一个图上最短路问题了，点数 4n2=36004n^2=36004n2=3600，边数上界 4n2+3×4n2=13n2=117004n^2+3\\times 4n^2=13n^2=117004n2+3×4n2=13n2=11700，用 SPFA 就可以满足需要。 指数计算数组里初始时只有 111，每次可以从数组中取出两个（可以相同的）数，把它们的和或差加入数组（但是要求差必须为正），求最少需要操作多少次才能得到 nnn。最少需要操作多少次？直接 IDA* 解决吧。乐观估价函数设为 log⁡(n−x)\\log (n-x)log(n−x)，其中 xxx 是数组中最大的数。还有一个玄学的搜索顺序优化，优先选大的进行扩展。 ABCDEF这个式子很奇怪，进行一些移项后两边每一边都是三个数。这样就可以 Meet in the Middle 了。说实话这道题时间限制很危险，似乎要用哈希表才能过得去。 测试 1 帽子谜题奇妙的“数学”题。考虑实际上有多少种颜色的帽子，设这个数为 xxx。那么戴着独特帽子（只有他一人戴着这种颜色的帽子）的人的 aia_iai​ 就是 x−1x-1x−1，戴着不独特帽子的人的 aia_iai​ 就是 xxx。因此 aia_iai​ 最大值和最小值的差不大于 111，并且最大值不大于 n−1n-1n−1。下面分两种情况讨论。一是所有人帽子颜色不同，那么 ∀1≤i≤n,ai=n−1\\forall 1\\le i\\le n,a_i=n-1∀1≤i≤n,ai​=n−1。特判掉就好了。二是所有人帽子颜色不全相同，这样必定有人戴着非独特的帽子。这时 aia_iai​ 的最大值就是 xxx，最小值就是 x−1x-1x−1。设有 ppp 人的帽子颜色独特，有 qqq 人的帽子颜色不独特，那么 p+q=np+q=np+q=n；并且恰有 ppp 种独特的颜色。再设有 rrr 种不独特的颜色，那么 p+r=xp+r=xp+r=x。由假设“所有人帽子颜色不全相同”，则 r&gt;0r&gt;0r&gt;0。又由“不独特”至少有 222 人，因此 q≥2rq\\ge 2rq≥2r。这两个不等式整理一下就可以得出“合法”的条件了。 旅途一道有意思的搜索题。对于没有补给的情况，任意点都不会访问两次，因此只要建图跑最短路即可。对于有补给的情况，就需要搜索了。我用的是分阶段搜索。每领到一个补给，就进入一个新的阶段；同一阶段任意点都不会访问两次，搜过去即可。标程的方法更为巧妙。如果经过一个点，使得生命值和经过的泥潭数都没有发生变化，那么一定是在闲逛！因此我们可以把 (x,y,w,ans)(x,y,w,\\mathrm{ans})(x,y,w,ans) 作为状态（www 是生命值），这样就可以避免闲逛了。但是这样似乎还不能加 visited？比如这一组数据1234563 5 5SMMM.M###CMM...M####ME###好像就不太行的样子…… 魔术挺不错的计数题。暴力方法当然是直接搜。优化过的暴力就是从“独特”的字符开始搜，尽量减少不可能状态。看这个数据范围，似乎只要 Meet in the Middle 就可以过呢。可是……Meet in the Middle 如何快速合并呢？要求不能重复……要是直接记录，状态空间过大，复杂度无法承受啊。那怎么办呢？使用封印的秘法：容斥原理！ 容斥原理复 (yu) 习 (xi)容斥原理是一个很迷的东西，可以处理各种东西。容斥原理：有一个全集 UUU，并且有若干个对 UUU 中元素定义的谓词（bool 函数）p1,p2,⋯ ,pnp_1,p_2,\\cdots,p_np1​,p2​,⋯,pn​，设满足谓词 pip_ipi​ 的元素集合为 PiP_iPi​。设 AtA_tAt​ 为恰好满足 ttt 个谓词的元素的集合，如 A0A_0A0​ 为 P1∪P2∪⋯Pn‾\\overline{P_1 \\cup P_2 \\cup \\cdots P_n}P1​∪P2​∪⋯Pn​​。现在想要求一个值 W=w0∣A0∣+w1∣A1∣+⋯+wn∣An∣W=w_0\\vert A_0 \\vert + w_1 \\vert A_1 \\vert+\\cdots+w_n \\vert A_n \\vertW=w0​∣A0​∣+w1​∣A1​∣+⋯+wn​∣An​∣，其中 w0,w1,⋯ ,wnw_0,w_1,\\cdots,w_nw0​,w1​,⋯,wn​ 是任意给定的系数。也就是，每个元素对最终答案的贡献只与它满足的谓词个数有关，那么就可以使用容斥原理进行转化。容斥原理是把“∣A0∣,∣A1∣,⋯ ,∣An∣\\vert A_0\\vert,\\vert A_1\\vert,\\cdots,\\vert A_n\\vert∣A0​∣,∣A1​∣,⋯,∣An​∣”这些不易求的量（可能需要枚举所有元素才能计算）转化为求另一些量。对于谓词的集合 SSS，设 f(S)f(S)f(S) 为“满足集合 SSS 中所有谓词的元素个数”（也就是“至少能满足 SSS 中所有谓词的元素个数”），那么我们只需要对所有 SSS 求出 f(S)f(S)f(S)，再把 f(S)f(S)f(S) 赋予适当的“容斥系数”sjs_jsj​，就能计算出 WWW 了。注意这里的容斥系数 sjs_jsj​ 仅与 ∣S∣\\vert S\\vert∣S∣ 有关，也就是 sjs_jsj​ 是 ∣S∣\\vert S\\vert∣S∣ 的函数；谓词集合对答案的贡献也只与它的大小（所含的谓词的个数）有关。总结一下，容斥原理转化是将求“恰满足 ttt 个谓词的元素个数”转化为“对于每一个谓词的集合，计算至少满足这个集合中所有谓词的元素个数”，从“枚举元素，数满足的所有谓词个数”变成了“枚举谓词的集合，数满足该集合中所有谓词的元素个数”。如何求“容斥系数”呢？“容斥系数”一定存在么？假设任选的某个元素 xxx 恰满足 ttt 个谓词，那么这个元素对 WWW 的贡献应该是 wtw_twt​。下面我们从“容斥”角度考虑它对答案的贡献。如果用容斥原理计算答案，那么要考虑“它满足哪些谓词的集合中所有的谓词”——考虑这 ttt 个谓词的集合 BBB，那么上面引号中条件的充要条件就是“这个谓词的集合是 BBB 的子集”。因此只有 BBB 的子集中才会出现 xxx 的贡献。也就是说，xxx 只要想要对答案作出贡献，就必须作为某个“满足某个谓词集合中所有谓词的元素”，而这些谓词集合都是 BBB 的子集；因此只需要对于 BBB 的所有子集 CCC，计算出“把 xxx 作为满足 CCC 中所有谓词的元素”时作出的贡献，再把这个贡献求和，就能得到“容斥法计算出的 xxx 对答案的贡献”。考虑 BBB 的一个 jjj 元子集 CCC，那么 xxx“作为满足 CCC 中所有谓词的元素”时对答案的贡献就等于容斥系数 sjs_jsj​。BBB 一共有 Ctj\\mathrm{C}^{j}_{t}Ctj​ 个 jjj 元子集，因此 xxx 的总贡献就是 s0Ct0+s1Ct1+s2Ct2+⋯+stCtts_0 \\mathrm{C}^0_t+s_1\\mathrm{C}^1_t+s_2\\mathrm{C}^2_t+\\cdots+s_t \\mathrm{C}^t_ts0​Ct0​+s1​Ct1​+s2​Ct2​+⋯+st​Ctt​。这个值应该与定义法算出来的 wtw_twt​ 相等，也就是 s0Ct0+s1Ct1+s2Ct2+⋯+stCtt=wts_0 \\mathrm{C}^0_t+s_1\\mathrm{C}^1_t+s_2\\mathrm{C}^2_t+\\cdots+s_t \\mathrm{C}^t_t=w_ts0​Ct0​+s1​Ct1​+s2​Ct2​+⋯+st​Ctt​=wt​。上述方程涵盖了所有“满足 ttt 个谓词的情况”。要涵盖所有元素的情况，也就是涵盖满足 0,1,2,⋯ ,n0,1,2,\\cdots,n0,1,2,⋯,n 个谓词的情况，我们就需要列 t=0,1,⋯ ,nt=0,1,\\cdots,nt=0,1,⋯,n 时的方程，并把这些方程联立起来求一组解。如果能求出解，那么“容斥系数”存在，并且我们也就求出了“容斥系数”。这些方程是：\\begin{align}\\begin{cases}s_0 \\mathrm{C}^0_0&amp;=w_0 \\\\ s_0 \\mathrm{C}^0_1+s_1 \\mathrm{C}^1_1&amp;=w_1\\\\ s_0\\mathrm{C}^0_2+s_1 \\mathrm{C}^1_2+s_2 \\mathrm{C}^2_2&amp;=w_2\\\\ \\vdots &amp;= \\vdots \\\\ s_0\\mathrm{C}^0_n+s_1 \\mathrm{C}^1_n+s_2 \\mathrm{C}^2_2+\\cdots+s_n\\mathrm{C}^n_n&amp;=w_n \\end{cases}\\end{align}可以看到，一共有 n+1n+1n+1 个未知数（s0,s1,⋯ ,sns_0,s_1,\\cdots,s_ns0​,s1​,⋯,sn​）和 n+1n+1n+1 个方程，而且未知数的系数矩阵是下三角矩阵，下三角矩阵的下三角部分全都非零（因为都是组合数嘛），因此是一定有唯一解的。具体地说，s0=w0s_0=w_0s0​=w0​，sj=wj−s0Cj0−s1Cj1−⋯−sj−1Cjj−1Cjj=wj−s0Cj0−s1Cj1−⋯−sj−1Cjj−1s_j=\\frac{w_j-s_0\\mathrm{C}^0_j-s_1\\mathrm{C}^1_j-\\cdots-s_{j-1}\\mathrm{C}^{j-1}_j}{\\mathrm{C}^{j}_{j}}=w_j-s_0\\mathrm{C}^0_j-s_1\\mathrm{C}^1_j-\\cdots-s_{j-1}\\mathrm{C}^{j-1}_jsj​=Cjj​wj​−s0​Cj0​−s1​Cj1​−⋯−sj−1​Cjj−1​​=wj​−s0​Cj0​−s1​Cj1​−⋯−sj−1​Cjj−1​，直接递推就可以 O(n2)O(n^2)O(n2) 求出所有容斥系数。如果想要更快呢？我们整理一下式子，把式子写成求和号的形式：sj=wj−∑k=0j−1skCjks_j=w_j-\\sum^{j-1}_{k=0}s_k\\mathrm{C}^k_jsj​=wj​−k=0∑j−1​sk​Cjk​把组合数拆开：sj=wj−∑k=0j−1skj!k!(j−k)!s_j=w_j-\\sum^{j-1}_{k=0}s_k\\frac{j!}{k!(j-k)!}sj​=wj​−∑k=0j−1​sk​k!(j−k)!j!​像数列一样把变量的形式调整得更相似：sjj!=wjj!−∑k=0j−11(j−k)!×skk!\\frac{s_j}{j!}=\\frac{w_j}{j!}-\\sum^{j-1}_{k=0}\\frac{1}{(j-k)!}\\times \\frac{s_k}{k!}j!sj​​=j!wj​​−∑k=0j−1​(j−k)!1​×k!sk​​令 Tj=sjj!T_j=\\frac{s_j}{j!}Tj​=j!sj​​，Qj−k=1(j−k)!Q_{j-k}=\\frac{1}{(j-k)!}Qj−k​=(j−k)!1​，Lj=wjj!L_j=\\frac{w_j}{j!}Lj​=j!wj​​（变量名都是乱选的，不要打我）（这些都是可以 O(n)O(n)O(n) 转化为答案或 O(n)O(n)O(n) 计算出来的），那么：Tj=Lj−∑k=0j−1TkQj−kT_j=L_j-\\sum_{k=0}^{j-1}T_k Q_{j-k}Tj​=Lj​−k=0∑j−1​Tk​Qj−k​这是一个典型的卷积型式子，已经可以用分治 FFT 在 O(nlog⁡nlog⁡n)O(n\\log n\\log n)O(nlognlogn) 的时间内解决了。还可以做得更好吗？这个式子里面有卷积以外的求和，很讨厌。不妨把式子重新移项整理成更整齐的形式：∑k=0j−1TkQj−k+Tj=Lj\\sum_{k=0}^{j-1}T_kQ_{j-k}+T_j=L_jk=0∑j−1​Tk​Qj−k​+Tj​=Lj​由于 Q0=1Q_0=1Q0​=1，因此左边可以整理成很漂亮的形式：∑k=0jTkQj−k=Lj\\sum_{k=0}^{j}T_kQ_{j-k}=L_jk=0∑j​Tk​Qj−k​=Lj​标准卷积出现了！下面我们把它改成多项式。设 F(x)=∑i=0∞TixiF(x)=\\sum_{i=0}^{\\infty} T_ix^iF(x)=∑i=0∞​Ti​xi，G(x)=∑i=0∞QixiG(x)=\\sum_{i=0}^{\\infty} Q_ix^iG(x)=∑i=0∞​Qi​xi，H(x)=∑i=0∞LixiH(x)=\\sum^{\\infty}_{i=0}L_ix^iH(x)=∑i=0∞​Li​xi，那么F×G=HF\\times G=HF×G=H也就是F=H×G−1F=H\\times G^{-1}F=H×G−1于是就可以用多项式求逆 O(nlog⁡n)O(n \\log n)O(nlogn) 解决了！另外注意一个细节，G(x)=∑i=0∞xii!=exG(x)=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}=e^xG(x)=∑i=0∞​i!xi​=ex，因此 G−1G^{-1}G−1（是逆元，不是反函数）就是 e−xe^{-x}e−x！那还求什么逆呢？e−x=∑i=0∞(−x)ii!=∑i=0∞(−1)ixii!e^{-x}=\\sum^\\infty_{i=0}\\frac{(-x)^i}{i!}=\\sum^\\infty_{i=0}(-1)^i\\frac{x^i}{i!}e−x=∑i=0∞​i!(−x)i​=∑i=0∞​(−1)ii!xi​。下面我们研究一下经典的容斥。w0=1,w1=w2=⋯=wn=0w_0=1,w_1=w_2=\\cdots=w_n=0w0​=1,w1​=w2​=⋯=wn​=0 当属最经典的容斥——求不满足任何一个谓词的元素个数。此时 H(x)=1H(x)=1H(x)=1，F(x)=e−xF(x)=e^{-x}F(x)=e−x，也就是 Ti=(−1)ii!T_i=\\frac{(-1)^i}{i!}Ti​=i!(−1)i​，得到 si=(−1)is_i=(-1)^isi​=(−1)i。这和我们用经典方法得到的结果一致，也就是加上偶数的、减去奇数的。那如果是 w0=w1=⋯=wk−1=wk+1=⋯=wn=0,wk=1w_0=w_1=\\cdots=w_{k-1}=w_{k+1}=\\cdots=w_n=0,w_k=1w0​=w1​=⋯=wk−1​=wk+1​=⋯=wn​=0,wk​=1——求恰好满足 kkk 个谓词的元素个数呢？此时 H(x)=xkk!H(x)=\\frac{x^k}{k!}H(x)=k!xk​，F(x)=xkk!e−x=∑i=0∞(−1)ixi+kk!i!=∑i=k∞(−1)i−kxik!(i−k)!F(x)=\\frac{x^k}{k!}e^{-x}=\\sum^{\\infty}_{i=0}(-1)^i\\frac{x^{i+k}}{k!i!}=\\sum_{i=k}^{\\infty}(-1)^{i-k}\\frac{x^{i}}{k!(i-k)!}F(x)=k!xk​e−x=∑i=0∞​(−1)ik!i!xi+k​=∑i=k∞​(−1)i−kk!(i−k)!xi​，T0=T1=⋯=Tk−1=0T_0=T_1=\\cdots=T_{k-1}=0T0​=T1​=⋯=Tk−1​=0，Ti=(−1)i−k(i−k)!T_i=\\frac{(-1)^{i-k}}{(i-k)!}Ti​=(i−k)!(−1)i−k​，si=i!Ti=(−1)i−ki!k!(i−k)!=(−1)i−kCiks_i=i!T_i=(-1)^{i-k}\\frac{i!}{k!(i-k)!}=(-1)^{i-k}\\mathrm{C}^k_isi​=i!Ti​=(−1)i−kk!(i−k)!i!​=(−1)i−kCik​。阅读上面这段推导过程的时候一定要明确 T,Q,L,F,G,HT,Q,L,F,G,HT,Q,L,F,G,H 各自的定义！或者，如果撇开 T,Q,LT,Q,LT,Q,L，F,G,HF,G,HF,G,H 分别可以看成是 s,1,ws,1,ws,1,w 的 EGF（注意不是 OGF！）。如果是 w0=w1=⋯=wk−1=0,wk=wk+1=⋯=wn=1w_0=w_1=\\cdots=w_{k-1}=0,w_k=w_{k+1}=\\cdots=w_n=1w0​=w1​=⋯=wk−1​=0,wk​=wk+1​=⋯=wn​=1——求至少满足 kkk 个谓词的元素个数呢？如果觉得用多项式直接做有困难，可以尝试用一下乘法分配律（从组合意义上说是加法原理）——把“至少 kkk 个”拆成“恰好 j(k≤j≤n)j(k\\le j\\le n)j(k≤j≤n) 个”的和。这样 st=∑j=kt(−1)t−jCtjs_t=\\sum _{j=k}^{t}(-1)^{t-j}\\mathrm{C}_{t}^{j}st​=∑j=kt​(−1)t−jCtj​。这个和式有点像朱世杰恒等式的形式，可以试着用 Cnr=Cn−1r−1+Cn−1r\\mathrm{C}^r_n=\\mathrm{C}^{r-1}_{n-1}+\\mathrm{C}^{r}_{n-1}Cnr​=Cn−1r−1​+Cn−1r​ 变形，变形的结果是 st=(−1)t−kCt−1k−1s_t=(-1)^{t-k}\\mathrm{C}^{k-1}_{t-1}st​=(−1)t−kCt−1k−1​。当然，对于大多数非经典的容斥问题，可以先在纸上画表找规律，说不定就能求出来了呢。实在不行还可以使用暴力求系数或多项式算法。 用容斥原理解本题回到本题，我们想要处理的就是“如何选出交集为空的前后状态”。设前半段有 nnn 个字符。如果我们以“前半段”为思考主体，对于某一个确定的前半段选择方案，取 nnn 个谓词，其中第 iii 个谓词为“后半段是否选到了前半段的第 iii 个字符”。我们想要的是“不满足任意谓词的后半段个数”，那么根据上面经典容斥的第一个模型，容斥系数是 (−1)t(-1)^t(−1)t。也就是，对于字符的 ttt 元集合 SSS，“至少取到 SSS 中所有字符的每一个后半段”要对答案有 (−1)t(-1)^t(−1)t 的贡献。于是，我们可以枚举前半段选择方案，再枚举它所选的字符集合的子集 SSS，求出“至少取到 SSS 中所有字符的后半段”的个数（设这个数是 uuu），再给答案累加上 (−1)∣S∣u(-1)^{\\vert S \\vert}u(−1)∣S∣u。如何求出“至少取到 SSS 中所有字符的后半段”的个数呢？这个条件的充要条件就是“SSS 是这个后半段所选字符集合的子集”，因此我们对于每一个后半段，枚举它的子集，在子集处累加 111 即可。另外注意，由于前半段和后半段要能连起来，也就是断点处的字符必须是一样的，因此我们要先枚举断点，然后由断点向两边分别枚举后半段和前半段，累加计算答案。总结一下，本题的解题框架是：先枚举断点；从断点往右找后半段，在找出的每一个后半段的子集处标记；从断点往左找前半段，枚举找到的前半段的每一个子集，累加答案。 线性数据结构 链表 哈希表 (Hana’s Table!)对于一个字符串或大整数，可以把它模 mod\\mathrm{mod}mod（大质数）的值作为“特征值”，把它模 ppp（小质数）的值作为“哈希索引值”；每次按照索引值查找，如果找到特征值，那么就认为这个对象存在。 栈, 队列 蚯蚓发现“单调”的结论很重要，当然也可以直接感性理解、略去证明。 单调栈, 单调队列什么是单调性思想？简单地说，就是“如果一个 OIer 比你小，还比你强，那你就打不过他了”！稍形式化地说，这类问题中的元素有时效性（转移的能力）和价值（值的优劣性），如果一个元素的转移能力和价值都超过了另一个，那么它就总可以替代另一个，于是另一个就不必被保存。单调性数据结构主要有，单调队列、单调栈、二分单调栈、单调性 set 等。 Print Article状态转移方程 f[i]=min⁡(f[j]+(s[i]−s[j])2)+Mf[i]=\\min(f[j]+(s[i]-s[j])^2)+Mf[i]=min(f[j]+(s[i]−s[j])2)+M，其中 sss 数组单调递增。观察一下——这个东西具有决策单调性！为什么？考虑设 wj(x)=(x−s[j])2+f[j]w_j(x)=(x-s[j])^2+f[j]wj​(x)=(x−s[j])2+f[j]，那么 f[i]=min⁡(wj(s[i]))+Mf[i]=\\min(w_j(s[i]))+Mf[i]=min(wj​(s[i]))+M。wjw_jwj​ 是二次函数，而且所有 wjw_jwj​ 都可以通过互相平移得到。考虑两个这样的二次函数（不重合），它们的差是一个一次函数——一次函数是单调的，因此一旦一个函数变得优于（从劣于变到优于）另一个，它就永远优于另一个了。而且由于这些二次函数的对称轴单调右移，因此后面的状态最终都会比前面的状态优。或者我们也可以拆式子。wj(x)=(x−s[j])2+f[j]=x2−2s[j]x+s2[j]+f[j]w_j(x)=(x-s[j])^2+f[j]=x^2-2s[j]x+s^2[j]+f[j]wj​(x)=(x−s[j])2+f[j]=x2−2s[j]x+s2[j]+f[j]。可以发现这是一个以 −2s[j]-2s[j]−2s[j] 为斜率的一次函数，斜率是随时间（计算顺序）单调递减的，后面总比前面优。因此可以使用单调队列维护当前直线（“上/下凸壳”），发现队头变劣就弹掉；加入新直线时，如果发现新直线与队尾直线的交点小于队尾直线与队尾前一条直线的交点，即新直线的生效点在队尾直线的生效点以前，新直线完全覆盖了队尾直线，就把队尾直线弹掉。注意这样的斜率 dp 与“函数平移”型决策单调性 dp 的区别——这里的入队比的是生效点，就像用 set 的普通斜率优化 dp 比较“作用范围元组”一样；而很多“函数平移”型 dp 只需要比较“在当前点的大小”。弹队头和入队时弹队尾都是单调队列正确性的保证。 关于决策单调性简单的决策单调性，斜率如果随时间单调变化，可以用单调队列或单调栈。困难的决策单调性，没有明显的斜率，可以使用二分单调队列或二分单调栈。困难的斜率优化，斜率不按时间单调变化，可以用 set 维护。极为困难的决策单调性！既没有明显的斜率，函数又不便计算的……考虑用 CDQ 分治（整体二分）！ 单调队列优化多重背包具有决策过期性质，可以用单调队列维护。 Little Bird每个状态具有位置、高度两个属性，这两个属性都具有单调特点。等等，高度没有范围，劳累值有范围——考虑反转值域，把位置（树的序号）和劳累值作为定义域，高度作为值域。这样还有天然的好处——类似 LIS 的福利，每次转移只差 111！或者说这题就和 LIS 非常相像吧。但是这个“双单调”怎么办呢？我们可以用单调数组（类似 LIS）套单调队列解决。单调数组中每一个数就对应一个单调队列，单调队列维护位置属性，单调数组维护高度属性。 Blocks求最长的均值不小于 kkk 的子段。每个数减去 kkk 后变为求最长的和非负的子段。考虑枚举区间右端点，也就是对每一个 rrr，要在 O(1)O(1)O(1) 时间求出一个最小的 lll，使得 Sl≤SrS_l\\le S_rSl​≤Sr​。考虑单调覆盖性质。一个状态的转移能力由 SSS 决定，SSS 越小，转移能力越强；价值由位置决定，位置越靠左，价值越大。如果一个状态的 SSS 比另一个大，位置还在另一个的右边，那就会被“另一个”覆盖。因此可以维护一个不被覆盖的反链——SSS 与位置反向变化的东西，因为询问的高度不单调，因此每次在反链中二分寻找即可。二分？这怎么 O(1)O(1)O(1)？其实右端点也有单调覆盖性质！右端点的 SSS 越大，转移能力越强；位置越靠右，价值越大。因此右端点也在一个反链里！这样我们可以把左边的反链和右边的反链都做出来，这样枚举右端点的时候 SSS 就是单调变化的了！既然是单调变化的，那么左端点那边的反链就可以单调删除元素，转移能力得以真正体现！你要问我“反链”用什么维护？当然是单调栈啦！综上，当前后状态都按照转移能力的单调顺序（前状态的转移能力越来越强，后状态的转移能力越来越弱）给出时，我们便可以用单调队列或单调栈 O(1)O(1)O(1) 解决；如果没有完全按这个顺序给出，但是具有单调的（偏序）覆盖性质的话……我们就取反链，反链就是单调的啦！另外……反链总是包含了”无敌状态“——转移能力最强的零状态。 树形数据结构 并查集 简单题nnn 点 mmm 边无向图，一旦一个点的度为 111，这条边就会自动消失。求至少要人工删除多少条边，使得这个图中没有边。如果一个图有环，一定不能变成无边状态。因此图一定要删到无环的状态。考虑一棵树，我们都知道树有 Prufer 序列对吧？树的 Prufer 序列其实就是一个类似上面的过程，因此树一定可以变成无边状态。综上，我们只需要把每一个连通块都变成树即可。那么要删的边数就是（每个连通块） m−(n−1)m-(n-1)m−(n−1)。 例题给定一个无边的 nnn 点图，在线维护这个图，每次操作连接两个点或询问这两个点连通的最早时刻。可以用“边带权”的并查集解决，边权就是操作的时刻。合并时按秩合并即可保留树的结构，ufind 的时候顺手计算一下边权的最大值即可。题目可以改成“给定图上两点，询问它们之间所有路径上‘边权最大值’的最小值”。按边权从小到大加边即可。 类银河英雄传说 (Cube Stacking)每次有 merge 和查询到根距离两种操作，merge 时指定方向。不能按秩合并，那就路径压缩。边权记为到父亲距离。 黑白点（[HEOI2016/TJOI2016]树）有一棵树，初始时只有根节点是黑的，每次操作染黑一个点或询问一个点的最近黑色祖先。染黑一个点就相当于把这个点的子树与它的父亲断开，查询最近黑色祖先就是查所在子树根节点。如果正着做就是断开，不好做；于是把操作离线，倒序处理，就变成了连接（merge），就可以用并查集了。如果强制在线怎么办？用类似树链剖分的方法——这回不需要维护树上两点路径，因此直接按 dfs 序即可——建立线段树，这回有区间上推（如果小于 xxx 就改成 xxx）的修改操作，打上标记即可。 ST 表与倍增 ST 表求 LCA对每个节点，每次访问到就在数组中记录一次（这叫做欧拉序）。比如 111 有 2,3,42,3,42,3,4 三个孩子， 222 有 5,65,65,6 两个孩子，那么这棵树的欧拉序就是 1,2,5,2,6,2,1,3,1,4,11,2,5,2,6,2,1,3,1,4,11,2,5,2,6,2,1,3,1,4,1。考虑欧拉序的记录方法，来到一个节点的时候记录一次，每遍历完一个子节点记录一次——因此长度为 n+m=2n−1n+m=2n-1n+m=2n−1。现在把欧拉序中记录的每个节点的编号改成记录每个节点的深度，接着再记录一下每个节点在欧拉序上的开始位置和结束位置（op,ed\\mathrm{op,ed}op,ed？），这样对两个点，只要查它们 op,ed\\mathrm{op,ed}op,ed 之间的最小深度就可以了。这个深度欧拉序有什么特征么？相邻两个点的深度只会变化 111，也就是数列中每两个数的大小要么差 111，要么差 −1-1−1！这就是—— ±1\\pm 1±1 RMQ我们怎么求 ±1\\pm 1±1 RMQ 呢？这里有一种玄学的分块方法，可以做到 O(n)O(n)O(n) 预处理、O(1)O(1)O(1) 查询！考虑把整个数列分成大小为 ⌊log⁡n2⌋\\lfloor \\frac{\\log n}{2} \\rfloor⌊2logn​⌋ 的块（取整符号下略），那么总共就有 2nlog⁡n\\frac{2n}{\\log n}logn2n​ 块。我们把每一块的最小值都求出来。现在把每一块看作一个整体，组成一个“块的数列”——长为 2nlog⁡n\\frac{2n}{\\log n}logn2n​。对这个数列作 RMQ，使用 ST 表，复杂度为 O(2nlog⁡n×(log⁡(2n)−log⁡log⁡n))≈O(n)O(\\frac{2n}{\\log n}\\times (\\log (2n)-\\log\\log n))\\approx O(n)O(logn2n​×(log(2n)−loglogn))≈O(n)。查询时怎么办呢？分块的思想是“整体使用预处理信息，局部暴力”。起点和终点之间部分的最小值可以直接用“块的数列”的信息得到，但是起点和终点所在块的最小值呢？这个要是暴力，查询可就不是 O(1)O(1)O(1) 的了！这时候就要用到性质了。首先，如果一个区间的差分数列是确定的，那么这个区间的区间最值的位置也就是确定的。接着，由于是 ±1\\pm 1±1 RMQ，因此每一块内部的差分数列也就只有 2log⁡n2=n2^{\\frac{\\log n}{2}}=\\sqrt{n}22logn​=n​ 种，暴力枚举这所有的块内差分可能性，对每一种可能性，都算出它所有子段（有 Clog⁡n22≈log⁡nlog⁡n\\mathrm{C}^{2}_{\\frac{\\log n}{2}}\\approx \\log n\\log nC2logn​2​≈lognlogn 种）的最值位置，这个过程的总复杂度是 O(nlog⁡nlog⁡n)&lt;O(n)O(\\sqrt{n}\\log n\\log n)&lt;O(n)O(n​lognlogn)&lt;O(n)。查询时就直接根据当前块的差分数列种类，查看相应种类、相应区间的最值表，就可以做到 O(1)O(1)O(1) 查询了！看起来这样树上 LCA 就可以很快地完成了！但实际上—— 笛卡尔树假如我说树上 LCA 可以转为 ±1\\pm 1±1 RMQ，那么你是相信的。假如我说一般的 RMQ 可以转为 LCA，你信么？不管你信不信，这确实是可以 O(n)O(n)O(n) 做到的。笛卡尔树是一棵满足堆性质和 BST 性质的二叉树：父节点的值大于 / 小于子节点的值，也就是值满足堆性质；左节点的下标小于父节点，右节点的下标大于父节点，也就是下标满足 BST 性质。是不是和 Treap 有点像？当然，它们的作用还是有很大差别的。事实上，笛卡尔树上两点的 LCA 正是这两点形成区间的 RMQ！（稍加模拟，我也不想证明。）那么现在的问题就是怎么建立笛卡尔树了。考虑从左到右一个一个地把数加入到笛卡尔树中。最后加入的数一定在树的右儿子-右儿子-右儿子这一条链上，也就是一定是在最右边。我们选这样一条从根节点一直往右走的路径作为树的主链，把主链中的点插入一个栈中，把左儿子“挂”在主链上。那么最后加入的树一定要插入栈中。根据堆性质，如果这个数比栈中所有数都大 / 小，那么我们就可以把这个点直接放在栈顶。否则，假如这个数只比栈中的前 lll 个数大 / 小，那么我们就把后面的树整体拿出来，作为这个点的子节点。实际操作时不断弹栈，直到栈为空或栈顶节点满足堆性质，再把刚才最后一个弹出的节点作为这个点的左儿子，最后入栈即可。可以看出，上述建树过程是 O(n)O(n)O(n) 的。因此只要我们先建出笛卡尔树，再根据笛卡尔树的欧拉序做好 ±1\\pm1±1 RMQ 的预处理，我们就可以做到 O(n)−O(1)O(n)-O(1)O(n)−O(1) RMQ 了！当然读入一个数是 O(log⁡10x)O(\\log_{10} x)O(log10​x) 的，所以实际上作用也不是很大……但是可以过由乃救爷爷这一题。 倍增与 Floydnnn 点 mmm 边有向图，边有边权。问从 111 号点开始，最少需要走多少条边才能使得经过的边的边权之和不小于 sss。首先可以想到动态规划，f[i][j][k]f[i][j][k]f[i][j][k] 表示从 iii 走 kkk 条边、来到点 jjj 的最大边权和，f[i][j][k]=max⁡(f[i][t][k−1]+w[t,j])f[i][j][k]=\\max(f[i][t][k-1]+w[t,j])f[i][j][k]=max(f[i][t][k−1]+w[t,j])。这个方程看上去不是很均衡，左边是 k−1k-1k−1，右边是 111……考虑用倍增优化：设 f[i][j][k]f[i][j][k]f[i][j][k] 是从 iii 走 2k2^k2k 条边、来到点 jjj 的最大边权和，f[i][j][k]=max⁡(f[i][t][k−1]+f[t][j][k−1])f[i][j][k]=\\max(f[i][t][k-1]+f[t][j][k-1])f[i][j][k]=max(f[i][t][k−1]+f[t][j][k−1])。这样我们就能在 O(n3log⁡k)O(n^3\\log k)O(n3logk) 的时间完成 dp 方程的计算。下面考虑如何计算答案。考虑倍增求答案。从大到小枚举 kkk，如果所有 f[i][j][k]f[i][j][k]f[i][j][k] 都小于 sss，就把答案加上 2k2^k2k，同时记录一个 g[i]g[i]g[i]，表示走了 ans\\mathrm{ans}ans 步，到达点 iii 后的最大边权和，ans[i]=max⁡(ans[j]+f[j][i][k])\\mathrm{ans}[i]=\\max(\\mathrm{ans[j]+f[j][i][k]})ans[i]=max(ans[j]+f[j][i][k])，又是一个 O(n2log⁡k)O(n^2 \\log k)O(n2logk)，就可以完成了。最后答案别忘了额外加 111，道理和倍增 LCA 相同。 ST 表与并查集[SCOI2016]萌萌哒：求满足 mmm 个形如”[l1,r1][l_1,r_1][l1​,r1​] 到 [l2,r2][l_2,r_2][l2​,r2​] 两个区间内的数字对应相等“的限制条件的没有前导零的 nnn 位数的数量，模 109+710^9+7109+7。考虑暴力怎么写。用并查集维护“相等”的条件，每次暴力连边，最后统计连通块的数量，有一个（包含最高位的那一个）连通块有 999 种选择，其余连通块都有 101010 种选择，直接计算即可。这个并查集 merge 操作显然太多了，怎么办呢？我们需要一种高效的区间 merge 的方法。我们能不能给区间打个标记，标记意味着这个区间整体和另一个区间 merge 了呢？这样我们就要考虑把区间拆成若干个小区间——ST 表就可以，因为重叠也没关系。每次合并的时候就把 [l1,l1+2k−1][l_1,l_1+2^k-1][l1​,l1​+2k−1] 与 [l2,l2+2k−1][l_2,l_2+2^k-1][l2​,l2​+2k−1] 合并，相应地把第二个区间合并。再考虑如何得到连通块的个数。其实很简单，把 LC(x)\\mathrm{LC}(x)LC(x) 与 LC(ufind(x))\\mathrm{LC}(\\mathrm{ufind}(x))LC(ufind(x)) 合并、RC(x)\\mathrm{RC}(x)RC(x) 与 RC(ufind(x))\\mathrm{RC}(\\mathrm{ufind}(x))RC(ufind(x)) 合并即可，其中 ufind(x)\\mathrm{ufind}(x)ufind(x) 指的是 xxx 在并查集上的根。 线段树 诡异的线段树 线段树与区间色数[POI2015] KIN：选取一个连续的区间，使得区间中只出现一次的数的种类最多。考虑枚举区间右端点，维护右端点在此位置时不同左端点的答案变化情况，并直接取 max⁡\\maxmax 即可。怎么维护呢？考虑新加入的数 xxx 对答案的影响。设 xxx 上一次、上上次出现的位置分别为 l1,l2l_1,l_2l1​,l2​，那么在区间 (l2,l1](l_2,l_1](l2​,l1​] 中，xxx 从只出现一次变为了出现多次，答案减一；在区间 (l1,cur](l_1,\\mathrm{cur}](l1​,cur] 中，xxx 从不出现变为了只出现一次，答案加一。因此发生答案改变的左端点是一个区间，可以用线段树的区间加操作实现；求 max⁡\\maxmax 也可以用线段树解决。因此，这题只需要用线段树就可以了！于是，我们找到了用线段树维护（持续维护、可以维护所有区间）区间色数的方法。此外，某些区间色数问题还可以用双指针解决——求最短的至少包含 kkk 种颜色的区间，若枚举左端点，左端点右移，则右端点单调右移。树上的色数问题可以用 dfs\\mathrm{dfs}dfs 序或树链剖分转为序列区间色数问题。 线段树与区间上下推这是一道 IOI 原题。给定一个初始全 000 序列，有两种操作：对某区间内的所有数 xxx，令 x=max⁡(t,x)x=\\max(t,x)x=max(t,x)（ttt 是操作参数）对某区间内的所有数 xxx，令 x=min⁡(t,x)x=\\min(t,x)x=min(t,x)求最后的序列。这道题与“萌萌哒”类似，如果每次区间操作都暴力地对区间内每一个数都进行调整，那么复杂度将无法承受。我们需要选择一种数据结构，直接对“区间”进行操作。“萌萌哒”这道题中，操作之间互不影响，而且操作区间可以重叠，因此可以直接使用 st 表（若操作区间不可重叠，同样可使用 st 表，但操作区间要被二进制拆分成为 O(log⁡l)O(\\log l)O(logl) 个）。但是在这道题中，不同的操作前后会有影响，因此我们可以使用线段树。线段树的每一个点维护“已经对这个区间进行、但还没有对这个区间的孩子应用 (apply) 的限制”——如果我们把我们的数想象成一排金属球，那么 1 操作可以想象成用一块钢板从下往上推区间内的球，一直推到高度 ttt，使之不低于 ttt；2 操作可以想象成用一块钢板从上往下压，一直压到高度 ttt。于是“每个区间的限制”有两种，一种是向下压的板到达的最小高度，一种是向上推的板到达的最大高度。初始时长度大于 111 的区间都没有限制——向下压的板的最小高度（记为 nnn）为 ∞\\infty∞，向上推的板的最大高度（记为 mmm）为 000；可以认为初始时长度为 111 的区间的 nnn 和 mmm 都是 000。现在考虑对一个区间进行 1 操作。用一块自下而上的上推钢板推这个区间，会有什么变化呢？如果原来的下界钢板低于 ttt，当然会被推到 ttt 位置，否则不变；上界同理。因此，这个操作对这个区间的变化是 m=max⁡(m,t),n=max⁡(n,t)m=\\max(m,t),n=\\max(n,t)m=max(m,t),n=max(n,t)。再考虑 2 操作，类似地，m=min⁡(m,t),n=min⁡(n,t)m=\\min(m,t),n=\\min(n,t)m=min(m,t),n=min(n,t)。由于有些操作之间会相互影响，因此如果有一个要应用到孩子、但不应用到父亲区间的操作，就必须先把标记下传。标记下传也就是把之前 lazy tag 延迟应用的操作应用到孩子上，也就是对孩子进行 1 m, 2 n1\\ m,\\ 2\\ n1 m, 2 n 这两个操作——这两个操作的顺序无关紧要，因为在维护父节点的两个标记的时候，已经保证了这两块钢板 m≤nm\\le nm≤n，因此这两个操作之间不会相互影响。输出的时候直接输出叶子节点的 mmm 或 nnn 即可。由于上述过程中，叶子节点的 m,nm,nm,n 始终相同——夹着单个球的板总是紧密合在一起的，因此输出哪一个都可以。 动态开点线段树与线段树合并对于权值线段树，如果要像普通线段树那样静态建树、开点，空间将是非常非常大的，完全——无法承受啊！于是有了动态开点的操作。对于一个线段树节点，都像平衡树一样记录它的左子和右子，需要时再开点记录。可以用“引用”来优化实现。对于一个长度为 nnn 的区间，动态开点线段树只需要 2n2n2n 的空间就足够了。动态开点线段树还有一个好处——可以快速合并两棵结构相同的线段树！所谓“结构相同”指的就是“维护的区间（长度）相同”，这样它们对区间的划分就是相同的。合并的方法是，同时遍历这两棵线段树，如果两棵树当前节点都为空，那么合并后的树当前节点也为空；如果两棵树中只有一个当前节点为空，那么合并后的树直接使用另一棵树中的当前节点；如果两棵树当前位置上都有节点，那么递归合并；如果到了叶子节点，就把信息合并为一个节点，插入即可。合并的复杂度是多少呢？每次递归就相当与删除了一个节点，因此复杂度不会超过删除所有节点的复杂度——也就相当与把所有曾经做过的插入操作重新做一遍嘛——当然这是一个上界。大多数时候，线段树合并还是非常高效的。 线段树合并与逆序对[POI2011]ROT-Tree Rotations：给定一个 nnn 个叶子的二叉树，每个非叶节点都有两个孩子，可以交换任意非叶节点的左右子树，求交换后树的叶子遍历序列（按先序 / 中序 / 后序中任意一种方式遍历树，把遇到的叶子的权值依次记录）的逆序对数的最小值。我们首先可以注意到，交换某个非叶节点的左右子树，只影响这个非叶节点左右子树对应的两个子段之间的逆序对数量，不会影响两个子段之内以及其他位置的逆序对数量。因此，我们每次只需要比较两个子段之间的正序对和逆序对数，若逆序对数多则交换，否则不换即可。如何统计两个序列之间的逆序对数量呢？我们当然可以用归并排序的方法统计，但是归并排序每次归并是 O(n1+n2)O(n_1+n_2)O(n1​+n2​) 的，如果我们的树极度不均衡，在一条主链上，每个主链节点都外挂一个儿子的话……自然就被卡到接近 O(n2)O(n^2)O(n2) 了吧。怎么办呢？想一想求逆序对还有什么办法？当然是利用树状数组了——这里当然要“应景”地改为利用权值线段树。这样，我们的“归并”过程不久变成了线段树合并么？在线段树合并的过程中，如何统计逆序对数量呢？考虑左半部分一个较大的数和右半部分一个较小的数，记他们在合并后的树中的 LCA 为 ttt，那么在合并前的两棵树中，它们分别在左半部分节点 ttt 的右子树和右半部分节点 ttt 的左子树中，反之亦然。因此这是一个一一对应关系，我们只需要维护线段树每一个节点的 size，合并的时候对应相乘相加就好了。复杂度是比较优秀的，当然常数还是稍大……注意卡常以及用垃圾分类回收卡空间。 线段树灵活反转值域还记得反转值域吗？哪个维度方便、哪个维度范围小，就把哪个维度作为定义域；把不方便、范围大的维度作为值域！CF911G Mass Change Quries：给定一个长度为 nnn、值域为 [1,100][1,100][1,100] 的序列，每次操作把特定区间中的所有 xxx 改为 yyy（x,yx,yx,y 都在值域内），求所有操作完成后的序列。就像不能把 12 岁以下儿童放在副驾驶座上一样，看到 x,yx,yx,y 这么小，你忍心把她们放在值域上吗？倒是 nnn 比较大，可以放进值域里。好了，我们决定照顾儿童，把 x,yx,yx,y 作为定义域。对每个数值（xxx），建立一棵权值线段树，向线段树中插入这个数值所在的所有位置。比如说第 1,3,41,3,41,3,4 个数是 222，就向 222 的线段树中插入 1,3,41,3,41,3,4。对于每一次修改操作，我们只需要把 xxx 线段树中这个区间相应的节点“剪切”下来，“粘贴”到 yyy 线段树中就可以了！怎么“剪切”、“粘贴”呢？这又不是 Splay……不是 Splay 就不能快速分裂合并了吗？用类似线段树合并的方法，遍历到需要剪切的区间的时候就把节点指针“递给”需要粘贴的线段树。这就是一种很不错的做法了。其实还有一种更暴力的做法，每个节点维护“这个区间的 xxx 都变成了什么”，注意每一次都要暴力更新标记。记住“父节点的标记比子节点的标记时间要晚”。 线段树与区间覆盖[NOI2016] 区间：给定 nnn 个区间，要从中选出 mmm 个区间，使得这 mmm 个区间的交非空。定义一个区间的长度为右端点减左端点，定义一种选择方案的代价为所有被选区间长度的极差，求代价的最小值。这里首先用一个贪心的“选择扩充”——在不影响答案的情况下，要尽量多选，使得一个原先不满足题意的方案变得满足题意。（另一种常用的贪心策略是“选择压缩”——在保持选择方案满足题意的情况下，尽量少选，使得答案变优。两种贪心思想要综合运用。）怎么扩充呢？当然是“如果把区间按长度排序，最终方案所选的区间的长度是连续子段”咯——毕竟最长和最短区间之间的所有区间都可以贪心地选上嘛。这样就可以枚举两个区间端点暴力了。再多想一想，这个枚举可以优化么？观察到，最短区间长度增加时，最长区间长度不减——“单调移动”性质！这样就可以用双指针解决了。还有一个问题！如何判定当前所选的这些区间是否满足题意？“快速判定”也是单调枚举算法的重要环节啊。当然是要用到线段树。对每个被选区间，在线段树相应的区间中每个点加 111，然后查询全值域的最大值，如果最大值不小于 mmm，那么符合题意——如果真的要选出 mmm 个区间，我们就选“覆盖了这个点的所有区间中的任意 mmm 个”就行了嘛！还有一个小问题——区间端点数值太大，达到 10910^9109！哎呀这算什么问题呀，直接离散化就好了。这样，我们就在 O(nlog⁡n)O(n \\log n)O(nlogn) 的时间内解决了问题。 线段树优化 dpCF834D The Bakery（此题洛谷无）：有 nnn 个数字，要把它们分隔为 kkk 个部分，统计每个部分的色数，再把这些色数全部加起来作为答案。问答案最大是多少。n≤35000, k≤50n\\le 35000,\\ k\\le 50n≤35000, k≤50。看到这个，当然考虑 dp 了。设 f[i][j]f[i][j]f[i][j] 表示把 [1,i][1,i][1,i] 分成 jjj 个部分的最大答案，那么 f[i][j]=max⁡(f[t][j−1]+color[t+1...i])f[i][j]=\\max(f[t][j-1]+\\mathrm{color}[t+1...i])f[i][j]=max(f[t][j−1]+color[t+1...i])。这样就可以 O(n2k)O(n^2k)O(n2k) 暴力了。考虑优化上面的 dp 式子。还记得上面的“线段树与区间色数”吗？线段树可以高效地维护所有区间的色数，这样我们就可以用线段树高效地维护上面 f[t][j−1]+color[t+1...i]f[t][j-1]+\\mathrm{color}[t+1...i]f[t][j−1]+color[t+1...i] 这个式子（实质是区间色数加一个与右端点无关的常数）了，维护后区间 max⁡\\maxmax 即可。 扫描线 扫描线求矩形面积每碰到一个矩形，就把矩形对应的区域加 111，查询所有最小值为 111 的子区间长度即可。 扫描线维护区间信息UVA1608 不无聊的序列 Non-boring sequences：如果一个序列的任意连续子段都存在只出现了一次的元素，就称这个序列是不无聊的。请判断给定的序列是否无聊。这里又出现了“区间色数”之类的东西！完全可以用“线段树与区间色数”中的想法，维护区间“独特元素数”，右端点右移时维护线段树并查询区间最小值即可。当然我们还有另外的解法。考虑某个数 xxx 在序列中的出现，设它的出现位置依次为 y1,y2,⋯ ,yky_1,y_2,\\cdots ,y_ky1​,y2​,⋯,yk​，那么任意左端点在 [1,yi][1,y_i][1,yi​]，右端点在 [yi,yi+1)[y_i,y_i+1)[yi​,yi​+1) 范围内的区间都是有独特元素的。反之，对任意有独特元素的区间，都存在一个数 x0x_0x0​，使得这个区间的两端点满足上述条件。因此这是一个“充要条件”。我们考虑类似线性规划的方法，把区间的左右端点作为两个维度，区间化作点画在 R2\\mathbb{R}^2R2 上。那么一个“充要条件”就相当与把条件的区域用矩形覆盖，最后就检查是否所有区间都被覆盖即可。这就可以用扫描线处理了。综上，对于“区间”、“限制条件”的问题，我们也可以用线性规划的方法，把限制条件和所求点标到 R2\\mathbb{R}^2R2 上，用扫描线维护。 树状数组树状数组维护各种区间修改，重点是推式子、交换求和号——可以画图辅助理解。此外树状数组还有单点修改、维护区间最值；充当平衡树等诡异功能，常数小，编码简单，值得一学(bei)。 TrieTrie 的主要作用是处理位运算，特别是异或。 mex\\mathrm{mex}mex（全局）异或对 Trie 的改变，就是如果这一位为 111，那么这一层的所有左右儿子反转；如果这一位为 000，那么没有影响。例题：给定一个长度为 nnn 的自然数序列 AAA，每次操作全局异或一个数 或者 求 mex\\mathrm{mex}mex。由于异或具有结合律，因此把异或过的所有数维护到一个数，表示“之前所有异或操作的等效”，这样根据上面“全局异或对 Trie 的改变”一节，只需要根据这一影响，在每一位讨论是“尽量往左走”还是“尽量往右走”即可。如果在走的过程中遇到了期望方向没有儿子的点，那么就已经找到了；如果走的时候发现期望方向是满的，那就要往非期望方向走。特别地，如果整棵树都是满的，那么就输出 222 的一个幂。 51nod 1601 完全图的最小生成树计数这里肯定要用贪心咯。怎么求最小生成树？最小生成树是尽量取边权小的边构成生成树。边权？考虑贪心。最高位是 111 的边有没有必要选呢？假如我们不连任何最高位是 111 的边，那么“最高位是 000 的点集”和“最高位是 111 的点集”之间就没有边了，它们之间不连通，这肯定不是最小生成树。因此这样的边必须连一条。能不能只连一条呢？只要上述两个点集自身都是树，那么连一条边就可以把这两棵树合并起来了。尽可能少地选边权大的边，就是尽可能多地选边权少的边，这是符合最小生成树的求法的。因此我们的策略就是，把点按点权分成“最高位是 000 的点集”和“最高位是 111 的点集”，递归求解点集内部的生成树，再选择一条边权最小的“跨接边”就好了。如何选“跨接边”呢？把这两个点集中的点放在同一棵 Trie 中，在分叉后尽量地往相同方向走，如果 0,00,00,0 和 1,11,11,1 都存在，那么就两种都试一试。这么做，复杂度有保证么？考虑每一个数，它会被分到 log⁡v\\log vlogv 个集合中，在每个集合中它最多会被遍历到一次，遍历一次的复杂度是 log⁡v\\log vlogv，因此每一个数对复杂度的贡献是 O(log⁡vlog⁡v)O(\\log v\\log v)O(logvlogv)，总复杂度就是 O(nlog⁡vlog⁡v)O(n\\log v\\log v)O(nlogvlogv)，可以通过。方案数怎么统计呢？方案数当然是所有跨接边的选择数之积了！只要在找跨接边最小值的时候顺便数一下方案数即可。最后还有一个细节。如果最后遍历到了叶子节点，叶子节点不止一个数怎么办呢？跨接边当然是可以乱选，这些“跨接边”的代价都是 000。但是方案数……nnn 个节点的有标号无根树数量是 nn−2n^{n-2}nn−2，乘上这个数就好了。 异或粽子这道题……我确实有一个复杂度玄学但是跑得很快的分治做法。正解是怎么做的呢？可持久化 Trie当然先转化为前缀异或，这样就转化为了两两异或前 kkk 大。怎么办呢？还记得另一道题么？有 mmm 个有序序列，求这些序列合并起来后的前 kkk 大。只要用一个最大堆，插入每一个序列的最大候选值。然后每次取堆顶，再把堆顶所在的序列的下一个候选值放进堆，取 kkk 次就好了。如果我们枚举左端点，那么就能快速求出这个左端点异或的“后继”——次优解。于是就像上面这样建一个堆，每次取堆顶、插入候选即可。这题其实主要考的还是“前 kkk 大”的处理方法吧。 分治核心思想：缩小问题规模。 求第 kkk 大有两个有序序列，如何在 O(log⁡n)O(\\log n)O(logn) 的时间求出合并后的第 kkk 大数？想到“缩小问题规模”这个思想了吗？如果我们能每次把区间大小缩小到一半，就可以达成目标时间复杂度了。既然要每次缩小一半，那肯定和区间中点有关嘛。我们不妨取某一个区间的中点，然后怎么办呢？我们可以在另一个序列中查找这个中点的值所在的位置，这两个位置把两个区间分别分为“前段”和“后段”。如果“前段”中的数的个数大于 kkk，那么可以删除“后段”；如果“前段”中的数的个数不足 kkk，那么可以删除前段并把 kkk 减掉前段中数的个数。如果我们每次都选较长的区间，那么这两个区间的长度的最大值在两次查找后一定会折半，结合二分查找，总复杂度 T(n)=T(n2)+O(log⁡n)T(n)=T(\\frac{n}{2})+O(\\log n)T(n)=T(2n​)+O(logn)。要粗略地解这个递推式，假设 n=2tn=2^tn=2t，那么 T(n)=1+2+⋯+t=O(t2)T(n)=1+2+\\cdots +t=O(t^2)T(n)=1+2+⋯+t=O(t2)，于是复杂度是 O(log⁡nlog⁡n)O(\\log n\\log n)O(lognlogn)，还没有达到要求。怎么办呢？瓶颈当然是二分，于是我们不能用二分。每次取两个序列的中点 aia_iai​ 和 bjb_jbj​，不妨设 ai≤bja_i\\le b_jai​≤bj​。如果 i+j≤ki+j\\le ki+j≤k，那么第 kkk 大一定不在 aaa 的后半；否则第 kkk 大一定不会在 bbb 的前半，并且 kkk 要减去 bbb 前半的长度。每一次至少有一个区间长度减半，经过两次长度的最大值必定减半，T(n)=T(n2)+O(1), T(n)=O(log⁡n)T(n)=T(\\frac{n}{2})+O(1),\\ T(n)=O(\\log n)T(n)=T(2n​)+O(1), T(n)=O(logn)，满足要求。 Ants据说这是一道网络流？当然也可以用分治配合计算几何技巧（极角排序）解决。这里就不多说了（因为我不会计算几何(bushi）。 平面最近点对这道题在进阶指南题目总结里有很好的总结，这里略。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"搜索","slug":"搜索","permalink":"https://sweetlemon39.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"CSP 2019 集训 贪心和动态规划","slug":"CSP2019-greedy-and-dp","date":"2019-11-13T00:00:00.000Z","updated":"2020-02-02T00:00:00.000Z","comments":true,"path":"CSP2019-greedy-and-dp/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-greedy-and-dp/","excerpt":"贪心","text":"贪心 简单贪心 排队接水用邻项交换的方法可以证明，是从时间短到时间长排序。 区间选取每次尽量选早结束的区间。 选点覆盖区间每一个区间用尽量靠右的点覆盖。 删数字从最高位开始，如果后一个数字比前一个数字小，那么就删去这个数，删够 kkk 个为止。 数位乘积注意到如果把末尾的一些数字改成 999，乘积可能会变大。枚举要把末尾的多少位数字改成 999，求 max⁡\\maxmax 即可。 进阶贪心 均分纸牌像网络流一样，每个点最后的净流入/出是一定的，而且端点的流入/出只有一个方向。因此只需要进行那一次净流入/出就可以了。 环形均分纸牌Usaco 2012 Mar Haybale Restacking设 111 与 nnn 的流量为 xxx，就变成一堆绝对值之和的函数了。 合并果子参照哈夫曼树。 ONTAK 2010 Creative AccountingBZOJ 3544.给定数列 AAA 和一个模数 ppp，找一段区间，使得区间和模 ppp 最大。使用前缀和转化，对每一个 SrS_rSr​，都找一个 Sl(1≤l&lt;r)S_l(1\\le l&lt;r)Sl​(1≤l&lt;r)，使得 Sr−SlS_r-S_lSr​−Sl​ 模 ppp 最大。分成两段，用 set 维护就可以了。 反悔型贪心专题 概述使用贪心算法的一个条件是“局部最优可得出整体最优”，但是很多时候，这是不成立的。但有些情况下，我们可以通过“反悔”操作，修改局部最优解的一个或几个操作，使得局部最优解导出全局最优解。 EXPEDI - Expedition拿到题目，如果我们不敢用贪心怎么办呢？如果是 dp，那么状态数实在是爆炸啊。所以在考虑 dp 状态优化的时候，我们想到了贪心。有一种贪心策略是，只加油最多的加油站。但是这样的问题是，可能在到达好的加油站之前，车子已经没油了。考虑“子问题”。设“子问题”是走到第 iii 个加油站，油箱容量一直非负的情况下，最少的加油次数。下面要从第 iii 个加油站走到第 i+1i+1i+1 个加油站，要是车子目前油足够还好说，直接更新油量即可；若是油不够呢？我们先前已经对“每个加油站加不加油”作出了决策，现在发现油不够了，是要反悔了没有？怎么反悔？“唉，要是我们在之前那个加油站加过油就好了。”可以在之前没有加过油的、油量最多的加油站加一次油。由于我们是迫不得已才加油，因此加油次数是最少的。把经过的加油站的油量放进堆里，每次取堆顶即可。 数据备份同样是一道反悔的贪心。由于相邻两个数不能同时取，因此我们设置一个“自动反悔”的机制，即若 a,b,ca,b,ca,b,c 相邻，选了 bbb 后把三者删除，加入 a+c−ba+c-ba+c−b。今后如果选了 a+c−ba+c-ba+c−b，就意味着反悔了。这样就能平衡局部最优与全局最优的矛盾。 Cow Coupons先考虑简单的情况：如果钱很少，没买完优惠的牛就花完了呢？那当然是直接贪心取优惠价最低的若干头牛，也就是取 CiC_iCi​ 最小的一段。那么如果把 kkk 张优惠券用完了，还剩有钱呢？这时候就有牛需要按原价购买了。我们原先选的牛价格低，但是优惠幅度不一定大，在钱比较多的情况下买它们不一定划算。怎么办呢？我们考虑反悔，也就是调换优惠券的使用对象，原先买的牛不用优惠券，现在买的新牛使用优惠券。于是代价就是 Cj+(Pi−Ci)C_j+(P_i-C_i)Cj​+(Pi​−Ci​)。还可以从另外的角度考虑这个问题。为什么 CiC_iCi​ 前 kkk 小的牛一定要买呢？不妨假设某头 CiC_iCi​ 前 kkk 小的牛 α\\alphaα 没有买，那么一定有一头 CiC_iCi​ 较大（不是前 kkk 小）的牛 β\\betaβ 使用了优惠券；把牛 β\\betaβ 调换成牛 α\\alphaα，答案不会变劣。因此 CiC_iCi​ 前 kkk 小的牛是一定要买的，但是不一定使用优惠券，因为可能有其他的牛优惠幅度更大。因此上述反悔型贪心的算法是正确的。综上，反悔型贪心可以着重考虑“局部最优解”如何转化为“全局最优解”，通过转化使得贪心算法变得正确。 动态规划 递推与动态规划斐波那契, LIS。 动态规划的使用条件 最优子结构整个问题的最优解蕴含子问题最优解。 无后效性下一时刻的状态仅与当前状态有关，与前面的状态无关。如果不满足就要扩充状态才行。 动态规划的一般做题方法设计状态设计转移，注意转移方向注意初值计算复杂度 动态规划的分类线型动规背包问题区间动规树形动规状态压缩动规记忆化搜索特定的动态规划优化方法：决策单调性、斜率优化 线型动规LIS, LCS (子段/子序列) 背包问题01 背包、多重背包、完全背包、分数背包。其实还有有依赖的背包、分组背包等。 区间动规 石子合并设 f[i][j]f[i][j]f[i][j] 表示区间 [i,j][i,j][i,j] 全部合并的最小代价，枚举分割点（最后一次合并的位置）。 环形石子合并环形问题要么考虑断环成链，要么倍长环。这题可以考虑倍长环，在得到的链中取所有 nnn 长区间的最小答案即可。 能量项链据说只是把 +++ 变成了 ×\\times×。 [CQOI 2007] 涂色设 f[i][j]f[i][j]f[i][j] 表示区间 [i,j][i,j][i,j] 都被涂好的最小代价。每个区间肯定不会被涂超过一次，而且涂的区间“重叠而不覆盖”没有意义。（“重叠而不覆盖”指的是两个区间交集非空但不是子集关系。）下面把所有涂色方案分类。考虑涂的过程中有没有涂 [i,j][i,j][i,j] 这个区间。如果没有涂这个区间，那么一定可以找到一个点 kkk，使得不存在一次涂色，同时涂了 kkk 和 k+1k+1k+1。这个是由“不存在重叠而不覆盖的两个区间”性质保证的。于是我们枚举断点 kkk，令 f[i][j]=min⁡(f[i][j],f[i][k]+f[k+1][j])f[i][j]=\\min(f[i][j],f[i][k]+f[k+1][j])f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])。如果涂了这个区间，那么一定是因为这个区间的头和尾是一样的，我们想要先涂满这个区间，再在其上覆盖。因此这种情况仅当 a[i]=a[j]a[i]=a[j]a[i]=a[j] 时才会发生。如果我们强制不能涂这个区间呢？那么头和尾都必须单独着色，着色次数会多 111，且情况转换为“没有涂这个区间”。于是像上一种情况那样转移。但是，实际上我们是涂了 [i,j][i,j][i,j] 这个区间的，因此实际上着色次数要减 111，转移完成后减 111 即可。综上，f[i][j]=min⁡(f[i][k]+f[k+1][j])−(a[i]==a[j])f[i][j]=\\min(f[i][k]+f[k+1][j])-(a[i]==a[j])f[i][j]=min(f[i][k]+f[k+1][j])−(a[i]==a[j])。程序实现很简单，但是想出情况的转化还是有难度的。 树形动规 没有上司的舞会由于每个点选不选对它的父亲有影响，因此要记录到状态中。 骑士刚才那道题的基环树版本。对于环，我们可以断环成链，也可以倍长环。由于环上的点外面还挂有东西，因此不方便倍长环。于是可以选择断环成链。如何断环成链呢？我们找到环上的某一条边，把它断开，再人工考虑断开边的影响——我们强制边上的某一个点不可选。强制当然可以直接特判，但这里有一个比较神奇的方法。直接把禁用的点的权值设为 000 即可！（当然如果不放心，可以设为 −∞-\\infty−∞）。 POI 2008 STA这道题才是换根 dp 的模板吧。换根的影响非常简单，子树内的点深度减 111，子树外的点深度加 111。 USACO 2008 Jan 手机网络树上最小支配集。每个点可能被自己、父亲或孩子控制，需要分别讨论一下。类似的题目有“消防局的设立”，不过那个控制的范围更广一些。 DAG 动规 HAOI 2016 食物链裸题。 状压动规 疾病管理f[i][j]f[i][j]f[i][j] 表示前 iii 头牛，疾病集合为 jjj，直接转移即可。另外还有更简单的贪心做法：枚举最终的疾病集合（所含疾病个数不超过 kkk），对每一个集合，扫描所有牛，统计有多少牛的疾病是当前集合的子集。 混乱的奶牛记录最后一头奶牛和当前已选的奶牛。 送外卖由于是环，因此一个环会被算 nnn 次，非常不划算。我们强制环从 111 开始，这样就只需要记录当前环上点的集合和最后的点即可。 互不侵犯按行选择，记录当前选了几行、放了几个国王、当前行的状态即可。 概率动规 SGU495 Kids and Prizes概率论解法：考虑每一个盒子，它没有被任何人选到的概率自然是 (1−1n)m(1-\\frac{1}{n})^m(1−n1​)m，于是可以计算出它被选的概率，也就是它被选的期望。把所有盒子的期望加起来（其实就是乘以 nnn，或者说是独立观察量）就得到答案了。概率 dp 解法 1：设状态是 iii 人，选了 jjj 个礼物的概率。进行一些变换可以得到更好的递推式。概率 dp 解法 2：设状态是第 iii 个人得到礼物的概率。如果上一个人没有得到礼物，那么这个人得到礼物的概率和上一个人一样；如果上一个人得到了礼物，那么这个人得到礼物的概率少了 1n\\frac{1}{n}n1​。同样化简可以变得更好。 记忆化搜索可以简化实现，甚至可以剪枝。 经典动规算法 Floydf[i][j][k]f[i][j][k]f[i][j][k] 表示允许经过点 [1,k][1,k][1,k] 中转的前提下 i,ji,ji,j 的最短路，f[i][j][k]=min⁡(f[i][k][k−1]+f[k][j][k−1],f[i][j][k−1])f[i][j][k]=\\min(f[i][k][k-1]+f[k][j][k-1],f[i][j][k-1])f[i][j][k]=min(f[i][k][k−1]+f[k][j][k−1],f[i][j][k−1])。第三维度滚动压掉。理解这个意义很重要，有专门考这个的题。 动态规划的优化 琪露诺很明显的单调队列优化。 LIS有两种数据结构的优化方法。一种是反转值域后用单调数组，比较巧妙。另一种是令 f[a[i]]f[a[i]]f[a[i]] 表示以 a[i]a[i]a[i] 结尾的 LIS 的长度，然后利用动态开点线段树或离散化+树状数组就可以了。 动态规划的 NOIP 例题 加分二叉树因为有了序列，所以不是树形 dp，是区间 dp。注意考虑边界情况。 合唱队形把 LIS 和 LDS 合并起来就行了。 过河离散化后单调队列（？）。 金明的预算方案由于附件很少，因此直接枚举附件的选取情况。如果附件比较多，先对每一棵树做一次背包，然后分组背包即可。 传纸条由于两个路径不能相交，而相交的两个点到起点的路径长度一定相同，因此只要保证两条路径在距离起点相等的地方不相交即可。这样我们对两条路径同步走，f[i][j][k][l](i+j=k+l)f[i][j][k][l](i+j=k+l)f[i][j][k][l](i+j=k+l) 表示两条路径分别到达 (i,j),(k,l)(i,j),(k,l)(i,j),(k,l) 的方案数。另外由于 i+j=k+li+j=k+li+j=k+l，因此可以压掉一维 lll。 乌龟棋由于当前位置和用过的四种卡片的数量是线性相关的，因此可以压掉当前位置。 花匠考场上估计会写 O(nlog⁡n)O(n\\log n)O(nlogn) 的树状数组/线段树/set 优化 dp。当然这题还有一个更巧妙的方法，结合贪心，直接考虑与上一个的联系，如果这一个比上一个小，那么要么把上一个作为峰、这一个作为谷，要么不选这一个——因为上一个作为峰肯定比这一个作为峰更好。经过一番神奇 dp，就可以 O(n)O(n)O(n) 得到答案。另外还有直接贪心构造解的办法。 动态规划的高级应用 最大半连通子图 (Part)裸题？别忘了只是一个部分分。如果使用记忆化搜索，就不需要拓扑排序了。 Treats for the Cows因为是双端队列，所以就只能 dp 了，而且是区间 dp。另外这题实际上可以按区间长度滚动数组。 Round Subset有二维属性的背包？值域上不可能有两个数，因此可以把其中一个数拿到定义域里。f[i][j][k]f[i][j][k]f[i][j][k] 表示前 iii 个数、选了 jjj 个、其中有 kkk 个 555 因子时 222 因子的最多个数。计算量有点大，但毕竟是 CF 评测机嘛，信仰过。 New Year Santa Network又是树上点对 / 点组的问题，确实不能考虑以点组作为计数主体，一定会 TLE 的。因此我们考虑计算边的贡献。我们发现，树上三个点之间的三对距离经过一条边要么是 000 次，要么是 222 次——如果三个点分布在这条边的两侧（一边 111 个、一边 222 个），那么贡献是 222 次；否则贡献是 000 次。贡献为 222 次的情况数当然是 Cp2×Cq1+Cp1×Cq2\\mathrm{C}^2_p\\times \\mathrm{C}^1_q+\\mathrm{C}^1_p\\times \\mathrm{C}^2_qCp2​×Cq1​+Cp1​×Cq2​。修改边的时候用贡献乘以 Δw\\Delta wΔw 即可。 树上染色如果我们两两考虑点对，那肯定是要超时的。如果我们考虑树边对答案的贡献如何呢？一条树边对答案的贡献应该是“子树内外黑点数量之积”加上“子树内外白点数量之积”再乘以边权。接下来做一个树上背包就可以了。关于复杂度，有一个参考证明。 Outer Space Invaders拿到这道题，好像没有什么思路？每个外星人都有出现时间和消失时间，贪心似乎不太能做……我们先把外星人抽象成区间 [ai,bi][a_i,b_i][ai​,bi​]，画在高度 did_idi​ 上——也就是一条从 (ai,di)(a_i,d_i)(ai​,di​) 到 (bi,di)(b_i,d_i)(bi​,di​) 的线段。每次操作就是选取一个点 (xi,yi)(x_i,y_i)(xi​,yi​)，表示在 xix_ixi​ 时间进行一次半径为 yiy_iyi​ 的攻击，这次攻击可以消灭所有在时刻 xix_ixi​ 存在的、半径不大于 yiy_iyi​ 的外星人，也就是消除所有与线段 (xi,0),(xi,yi)(x_i,0),(x_i,y_i)(xi​,0),(xi​,yi​) 相交的线段。似乎还是没有什么思路？这里有一种“极限思考法”——没有思路的时候，考虑“最 xx”这样的特殊的元素。我们考虑半径最大的外星人，我们肯定需要一次半径为 yiy_iyi​ 的攻击来消灭它，但是在什么时刻攻击还不确定；并且，这一次攻击能够消灭此时存在的一切外星人。也就是，如果我们按照半径从大到小考虑所有外星人，那么我们就不需要收到“半径”的限制，已消灭的外星人就是若干个连续的区间——可以区间 dp！虽说是“区间”，但是我们还是没有搞清楚呐……想一想记忆化搜索吧。假设我们枚举“最强外星人”在时刻 ttt 被消灭，那么还剩下哪些外星人需要被消灭呢？当然是还剩“时刻 ttt 之前消失的外星人”和“时刻 ttt 之后出现的外星人”了。于是子问题就变成了“消灭时刻 ttt 之前消失的外星人”和“消灭时刻 ttt 之后出现的外星人”。假设“在时刻 ttt 之前消失的外星人”中，我们枚举“最强外星人”在时刻 t′t&#x27;t′ 被消灭。那么剩下的外星人当然是“在时刻 ttt 之前消失的外星人”和“在时刻 t’t’t’ 之后出现、但在时刻 ttt 之前消失的外星人”。终于找到规律了吗？我们的子问题其实是“在时刻 lll 之后出现、但在时刻 rrr 之前消失的外星人”，原问题是“在时刻 000 之后出现、但在时刻 n+1n+1n+1 之前消失的外星人”。于是这个区间 dp 终于定义完全了！转移方程也随之而来——f[i][j]=f[i][k−1]+f[k+1][j]+g[k]f[i][j]=f[i][k-1]+f[k+1][j]+g[k]f[i][j]=f[i][k−1]+f[k+1][j]+g[k]，其中 g[k]g[k]g[k] 表示在时刻 kkk 存在的所有外星人的半径的最大值。这个转移表示“在时刻 kkk 进行一次消灭在场所有外星人”的操作，其合理性已在上面论述。因此，很多时候记忆化搜索可以作为思考的切入点（“脚手架”），当然也可以作为实现的方式。 Problem a这些信息很多，怎么整理成容易处理的形式呢？我们要为每一个人安排一个准确的分数吗？好像非常困难啊。再思考一下每一个人说的话是什么意思。“有 aia_iai​ 个人比我分数高，有 bib_ibi​ 个人比我分数低”其实对“比我分数高”的人和“比我分数低”的人这两部分都没有要求，叙述的只是“把所有分数排序后， (ai,n−bi](a_i,n-b_i](ai​,n−bi​] 这一个区间是一个极大连续相等的段，并且我是其中的一个元素”。我们把每一个人说话的区间整合起来，把区间相同的人进行合并。如果同一个区间 (ai,n−bi](a_i,n-b_i](ai​,n−bi​] 的人数超过了 n−ai−bin-a_i-b_in−ai​−bi​，那么多出的人一定在说假话。接下来就是处理数轴上不同的区间了。如果两个不同的区间相交，就会出现矛盾，这是因为相等是等价关系，具有传递性，不同的极长连续相等区间是不可能相交的。因此问题变成了在数轴上选若干个不相交的区间，使得它们的权值和最大。把每一个区间的左右端点记为 Li,RiL_i,R_iLi​,Ri​，按 LiL_iLi​ 排序依次处理，f[i]f[i]f[i] 表示前 iii 个区间（必选第 iii 个）的最大权值和，那么 f[i]=max⁡(f[j])+w[i] (Rj&lt;Li)f[i]=\\max(f[j])+w[i]\\ (R_j&lt;L_i)f[i]=max(f[j])+w[i] (Rj​&lt;Li​)。这个东西可以用线段树或者树状数组优化到 O(nlog⁡n)O(n\\log n)O(nlogn)，于是问题解决。这题告诉我们要如何抽象处理信息。 庆典求把正整数 nnn 写成 mmm 个不同正整数的和的方案数，n≤105n\\le 10^5n≤105。“不同正整数”启示我们可以把整数从小到大排序，接着如果使用差分数组就可以很好地描述这个数列的性质——差分数组的每一项都为正。差分数组中第 iii 位的数对答案的贡献是 (m−i+1)di(m-i+1)d_i(m−i+1)di​，按照这个 dp，设状态 f[i][j]f[i][j]f[i][j] 是前 iii 个数、对和的贡献为 jjj 的方案数，那么 f[i][j]→f[i+1][j+(m−i)di+1]f[i][j]\\rightarrow f[i+1][j+(m-i)d_{i+1}]f[i][j]→f[i+1][j+(m−i)di+1​] ，其中 di+1d_{i+1}di+1​ 是所枚举的差分数组第 i+1i+1i+1 位的值。状态总数是 O(nm)O(nm)O(nm) 的，转移好像又不止 O(1)O(1)O(1)……感觉不太行的样子。不过可以用记忆化搜索 + 强剪枝搞掉不可能状态，也许有一定希望。但是！转移其实是可以 O(1)O(1)O(1) 的。这其实就是一个完全背包——每一个位置上的数的体积分别是 m,m−1,⋯ ,m−i+1,⋯ ,1m,m-1,\\cdots,m-i+1,\\cdots,1m,m−1,⋯,m−i+1,⋯,1，都有无穷多个，求把背包装满的方案数是多少。实际做的时候，我们不需要枚举 di+1d_{i+1}di+1​，只要像完全背包一样顺序枚举 jjj，并从本行转移（f[i+1][j]→f[i+1][j+(m−i)]f[i+1][j]\\rightarrow f[i+1][j+(m-i)]f[i+1][j]→f[i+1][j+(m−i)]，并滚动数组）即可！因此，熟悉经典的背包模型，对解题还是很有帮助的。差分数组也是处理单调递增 / 递减问题的好方法。注：上述方法有缺漏。这个和完全背包有区别，因为完全背包某个物品可以不选，但是这里不能不选。因此需要对完全背包的方程进行一些改动，变成 f[i][j]=f[i−1][j−(m−i+1)]+f[i][j−(m−i+1)]f[i][j]=f[i-1][j-(m-i+1)]+f[i][j-(m-i+1)]f[i][j]=f[i−1][j−(m−i+1)]+f[i][j−(m−i+1)]。这里又提供两种方法。一种方法是，先把差分数组的每一个数设为 111，计算这些 111 的总贡献。剩余的贡献要给差分数组里的某些数一点点加 111，给每个位置的数作调整对答案的贡献都不一样。接下来就考虑“给前 iii 个位置加了 111，总贡献是 jjj”即可。另一种方法是，构造一个每一个数都不相同的集合，可以有两种操作：给集合中所有数加 111、给集合中所有数加 111 后再加入一个 111——也可以从差分数组的角度理解。注：这里有一个可以提交的类似的题目：51nod 1201 整数拆分，但是这道题没有限定拆成多少个数。这样怎么办呢？没有确定的 mmm，我们又应该如何计算差分数组每个数的贡献呢？这里有一种办法：把差分数组倒过来，每个位置存储“这个位置的数比下一个数大多少”，那么第 iii 个位置的数对和的贡献就是 iii 了。于是就可以对所有的 mmm 都进行计算了。 集合选数这是一个有向无环图上独立集的计数问题，我们可以先把图画一画。在纸上稍微画一画就会发现，这是一个网格图森林！这是因为，2x2x2x 的三倍和 3x3x3x 的二倍都是 6x6x6x。而且网格图的宽不会很大，只有 log⁡3n≈10\\log_{3}n\\approx 10log3​n≈10。于是就可以在网格图上按列做状压 dp，最后把不同的网格图的答案乘起来就可以了。这道题的关键还是发现图的性质。 Eden 的新背包问题有 nnn 个物品，每个物品有若干个。有 QQQ 次询问，每次询问用 ViV_iVi​ 的背包能装下的物品的最大价值，但是要求不能用物品 DiD_iDi​（每次询问给定一对 Vi,DiV_i,D_iVi​,Di​）。n,Vi≤1000, Q≤1000n,V_i\\le 1000,\\ Q\\le 1000n,Vi​≤1000, Q≤1000 怎么做？那当然是做一个前后缀背包然后简单合并一下就好了。如果 Q≤3×105Q\\le 3\\times 10^5Q≤3×105 怎么办？这时候就不能每次查询都合并了！我们考虑离线之后进行 CDQ 分治或者线段树分治。（怎么想到的？区间太多大概是需要分治的吧(bushi)。联系分治 FFT。） Hotel求树上三元点集 {u,v,w}\\{u,v,w\\}{u,v,w} 的数量，要求三个点两两等距。n≤5000n\\le 5000n≤5000。考虑三个点的中间点（必定有这样一个点），它到三个点等距。把这个点作为根，变成了计算来自三个不同子树、深度相等的点的个数。这个应该不是很难进行树形 dp。 Osu! Easy这题比 osu! 一些图的 Easy 难多了……我们需要详细定义随机变量，这样有利于理解。注意，下面的几段都还没有引入期望。随机变量的推导可以认为是涵盖了各种可能情况时的推导。再次提醒，这里还没有期望！LiL_iLi​ 表示以第 iii 个点击结尾的 combo 的长度。对于 x，Li=0L_i=0Li​=0；对于 o，Li=Li−1+1L_i=L_{i-1}+1Li​=Li−1​+1，也就是不论 Li−1L_{i-1}Li−1​ 如何，LiL_iLi​ 总是等于 Li−1+1L_{i-1}+1Li−1​+1。对于 ?，情况比较复杂，LiL_iLi​ 有 12\\frac{1}{2}21​ 的概率等于 Li−1+1L_{i-1}+1Li−1​+1，有 12\\frac{1}{2}21​ 的概率等于 000。FiF_iFi​ 表示假如在第 iii 次点击后游戏意外退出（这个说法好牵强），此时的得分（或者可以理解为进行到第 iii 次点击时游戏界面显示的分数，打过 osu! 也大概知道吧(大雾)）。考虑如何从 Fi−1F_{i-1}Fi−1​ 计算 FiF_iFi​ 呢？这当然是考虑第 iii 次点击对分数有多少贡献啦。假如第 iii 次点击 miss 了，那么 FiF_iFi​ 当然等于 Fi−1F_{i-1}Fi−1​。但是如果成功了，那么 combo 加长了 111，分数增加了多少呢？由于 (x+1)2=x2+2x+1(x+1)^2=x^2+2x+1(x+1)2=x2+2x+1，也就是 (x+1)2−x2=2x+1(x+1)^2-x^2=2x+1(x+1)2−x2=2x+1，于是 combo 增长 111 对答案的增加量应该是 2Li−1+12L_{i-1}+12Li−1​+1。因此，对于 x，Fi=Fi−1F_i=F_{i-1}Fi​=Fi−1​；对于 o，Fi=Fi−1+2Li−1+1F_i=F_{i-1}+2L_{i-1}+1Fi​=Fi−1​+2Li−1​+1；对于 ?，上述两个等式成立的概率各为 12\\frac{1}{2}21​。或者，我们可以定义随机变量 Δi=Fi−Fi−1\\Delta_i=F_i-F_{i-1}Δi​=Fi​−Fi−1​。对于 x，Δi=0\\Delta_i=0Δi​=0；对于 o，Δi=2Li−1+1\\Delta_i=2L_{i-1}+1Δi​=2Li−1​+1；对于 ?，上述两个等式成立的概率各为 12\\frac{1}{2}21​。这些可都是随机变量的分布啊，我要它干什么呢？算期望确实要用到概率，接下来我们开始了！由于期望的线性性，Ex(Fi)=Ex(Fi−1+Δi)=Ex(Fi−1)+Ex(Δi)\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1}+\\Delta_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(\\Delta_i)Ex(Fi​)=Ex(Fi−1​+Δi​)=Ex(Fi−1​)+Ex(Δi​)。因此，我们只需要想办法计算出 Ex(Δi)\\mathrm{Ex}(\\Delta_i)Ex(Δi​)，就可以很容易地递推出 Ex(Fi)\\mathrm{Ex}(F_i)Ex(Fi​) 了（其实就是 Ex(Δi)\\mathrm{Ex}(\\Delta_i)Ex(Δi​) 的前缀和嘛）。对于 x，由于 Δi\\Delta_iΔi​ 恒等于 000，因此 Ex(Δi)=0\\mathrm{Ex}(\\Delta_i)=0Ex(Δi​)=0。对于 o，由于 Δi\\Delta_iΔi​ 恒等于 2Li−12L_i-12Li​−1，由期望的线性性，Ex(Δi)=Ex(2Li−1+1)=2Ex(Li−1)+1\\mathrm{Ex}(\\Delta_i)=\\mathrm{Ex}(2L_{i-1}+1)=2\\mathrm{Ex}(L_{i-1})+1Ex(Δi​)=Ex(2Li−1​+1)=2Ex(Li−1​)+1。对于 ?，我们要根据分布列计算 Ex(Δi)\\mathrm{Ex}(\\Delta_i)Ex(Δi​)，也就是把两种情况下的取值与概率相乘，加权相加——这应该算是全期望公式的应用吧。由于 Δi\\Delta_iΔi​ 取上述两种式子的概率各为 12\\frac{1}{2}21​，因此 Ex(Δi)=12(0+2Ex(Li−1)+1)=Ex(Li−1)+12\\mathrm{Ex}(\\Delta_i)=\\frac{1}{2}(0+2\\mathrm{Ex}(L_{i-1})+1)=\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}Ex(Δi​)=21​(0+2Ex(Li−1​)+1)=Ex(Li−1​)+21​。上面的三个式子中有两个出现了 Ex(Li−1)\\mathrm{Ex}(L_{i-1})Ex(Li−1​)，因此我们在计算 Ex(Δi)\\mathrm{Ex}(\\Delta_i)Ex(Δi​) 的同时也要计算 Ex(Li)\\mathrm{Ex}(L_i)Ex(Li​)。对于 x，由于 LiL_iLi​ 恒等于 000，因此 Ex(Li)=0\\mathrm{Ex}(L_i)=0Ex(Li​)=0。对于 o，由于 LiL_iLi​ 恒等于 Li−1+1L_{i-1}+1Li−1​+1，由期望的线性性，Ex(Li)=Ex(Li−1+1)=Ex(Li−1)+1\\mathrm{Ex}(L_i)=\\mathrm{Ex}(L_{i-1}+1)=\\mathrm{Ex}(L_{i-1})+1Ex(Li​)=Ex(Li−1​+1)=Ex(Li−1​)+1。对于 ?，我们还是要根据分布列计算 Ex(Li)\\mathrm{Ex}(L_i)Ex(Li​)。由于 LiL_iLi​ 取上述两种式子的概率各为 12\\frac{1}{2}21​，因此 Ex(Li)=12(0+Ex(Li−1)+1)=12Ex(Li−1)+12\\mathrm{Ex}(L_i)=\\frac{1}{2}(0+\\mathrm{Ex}(L_{i-1})+1)=\\frac{1}{2}\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}Ex(Li​)=21​(0+Ex(Li−1​)+1)=21​Ex(Li−1​)+21​。这样我们所需的所有递推式都全了，可以整理如下：\\begin{cases}\\begin{align} &amp;\\mathrm{Ex}(L_i)=0,&amp;a_i=\\mathrm{x} \\\\ &amp;\\mathrm{Ex}(L_i)=\\mathrm{Ex}(L_{i-1})+1,&amp;a_i=\\mathrm{o}\\\\ &amp;\\mathrm{Ex}(L_i)=\\frac{1}{2}\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}, &amp;a_i=\\mathrm{?} \\end{align}\\end{cases}\\begin{cases}\\begin{align} &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1}),&amp;a_i=\\mathrm{x} \\\\ &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+2\\mathrm{Ex}(L_{i-1})+1,&amp;a_i=\\mathrm{o}\\\\ &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}, &amp;a_i=\\mathrm{?} \\end{align}\\end{cases}初始值是 F0=L0=0F_0=L_0=0F0​=L0​=0。我们已经把辅助变量 Δi\\Delta_iΔi​ 处理掉了。注意一个要点！FiF_iFi​ 的式子里不要出现 LiL_iLi​，因为这样在应用全期望公式的时候会出问题。简单地说，就是全期望公式里面已经在讨论这个 ? 是否 miss 的这两种可能性了，但是 Ex(Li)\\mathrm{Ex}(L_i)Ex(Li​) 里面同样包含了这个 ? 是否 miss 的讨论，一个事件重复讨论就会导致问题；或者说，在全期望公式里，已经假设（或者说在……的条件下）了这个 ? 是否 miss，因此应该代入的是已经确定下来的上一个状态，而不是代入目前这个状态。如果不好理解，可以试着把 Ex(Fi)=Ex(Fi−1)+Ex(Li)−12, ai=?\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(L_i)-\\frac{1}{2},\\ a_i=\\mathrm{?}Ex(Fi​)=Ex(Fi−1​)+Ex(Li​)−21​, ai​=? 代入 ? 这个序列计算，就会发现问题。所以这道题就不用数组解决了。话说这题二次方是道蓝题，还有一道三次方的是一道紫题，真是不可理喻(bushi。 Vasya and Binary String此题略（大雾）。 POI2004 PRZ不是特别困难的状压 dp。 BZOJ3791 作业首先我们可以把连续的语文作业或数学作业累积在一起，这样序列就变成严格语数交错的了。下面有一个结论：kkk 次操作可以生成所有不超过 2k+12k+12k+1 块的序列。所谓“块”是指极长的连续 000 或 111。可以用数学归纳法证明，要点是“在一段 111 中间选一个区间变为 000，会变成 101101101，一次操作可以多产生 222 个区间”。于是就可以 dp 了。f[i][j][d]f[i][j][d]f[i][j][d] 表示第 jjj 段的末尾是 iii，变成了 d (d∈{0,1})d\\ (d\\in\\{0,1\\})d (d∈{0,1}) 序列时的最大收益，考虑上一段在哪里就可以了。 百度之星 最强密码给出一个只含小写字母的字符串 AAA，求最短的只含小写字母的字符串 BBB，使得 BBB 不是 AAA 的子序列（子序列可以不连续）。求 BBB 的长度和方案数。∣A∣≤105\\vert A \\vert\\le 10^5∣A∣≤105。我们怎么判断一个序列是不是另一个的子序列呢？先在 AAA 中找 B1B_1B1​ 第一次出现的位置 i1i_1i1​，在 i1i_1i1​ 之后找 B2B_2B2​ 第一次出现的位置 i2i_2i2​，在 i2i_2i2​ 之后再找 B3B_3B3​ 第一次出现的位置 i3i_3i3​……因此“BjB_jBj​ 匹配到 AiA_iAi​”的 iii 和 jjj 是重要的状态。设 f[i]f[i]f[i] 表示匹配到 AiA_iAi​ 的最小的 jjj，那么我们枚举 BjB_jBj​ 的下一个字符 ccc，找到 AiA_iAi​ 之后第一个为 ccc 的字符 i′i&#x27;i′（找不到则为 n+1n+1n+1），更新 f[i′]=min⁡(f[i′],f[i]+1)f[i&#x27;]=\\min(f[i&#x27;],f[i]+1)f[i′]=min(f[i′],f[i]+1)，同时统计方案数即可。找 i′i&#x27;i′ 的过程可以用一个数组维护，这样转移变为 O(26)O(26)O(26)。 The Minima Game每个人都会从大到小取数，进行 min-max dp 即可。 Treasure Chest状态不难想，但是卡空间怎么办呢？dp 压空间，当然是用滚动数组啦。如果按长度顺序转移，那么 lll 只会由 l−1l-1l−1 转移到，所以只记录左端点就可以描述状态了。 花仙子的魔法这题的 dp……很难理解吧。实在不行就找规律 + 大力拉格朗日吧。 严格 nnn 元树不错的题目。如果设状态为“深度为 iii 的严格 nnn 元树的数量”，那么子节点的深度怎么限制呢？可以有至多 n−1n-1n−1 个儿子深度小于 i−1i-1i−1，但是必须有一个儿子深度为 i−1i-1i−1……难道要用容斥？似乎容斥也是可以的——f[i]=(f[0]+f[1]+⋯+f[i−1])n−(f[0]+f[1]+⋯+f[i−2])nf[i]=(f[0]+f[1]+\\cdots+f[i-1])^n-(f[0]+f[1]+\\cdots+f[i-2])^nf[i]=(f[0]+f[1]+⋯+f[i−1])n−(f[0]+f[1]+⋯+f[i−2])n，初始条件 f[0]=f[1]=1f[0]=f[1]=1f[0]=f[1]=1。当然这里有更巧妙的办法。设 g[i]g[i]g[i] 表示深度不超过 iii 的严格 nnn 元树数量，那么 g[i]=1+g[i−1]ng[i]=1+g[i-1]^ng[i]=1+g[i−1]n——怎么理解呢？考虑严格 nnn 元树的深度，可以是 000（这时只有 111 种），可以大于 000（这时根节点的每一棵子树都是深度不超过 i−1i-1i−1 的严格 nnn 元树）。因此，很多时候放松限制条件也是 dp 状态设计的一种方法。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"贪心","slug":"贪心","permalink":"https://sweetlemon39.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sweetlemon39.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"CSP 2019 集训 图论","slug":"CSP2019-graph","date":"2019-11-10T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-graph/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-graph/","excerpt":"图论","text":"图论 NOIP 欢乐 赛 和注意到模意义下有乘法群，因此 nnn 的范围可以放到 mmm。如果直接暴力当然是可以拿到 80 分，但是带个 log⁡1018\\log 10^{18}log1018 肯定不能过 3×1063\\times 10^63×106。于是这里有一个把指数变小的小优化——扩展欧拉定理。a^{b}\\equiv \\begin{cases}\\begin{align} &amp;a^{b\\% \\varphi (p)}, &amp; a\\perp p \\\\ &amp;a^{b},&amp;\\gcd(a,p)&gt;1,b&lt;\\varphi(p)\\\\ &amp;a^{b\\%\\varphi(p)+\\varphi(p)},&amp;\\gcd(a,p)&gt;1,b\\ge \\varphi(p) \\end{align}\\end{cases}总之就是如果 b≥φ(p)b\\ge\\varphi(p)b≥φ(p)，ab≡ab%φ(p)+φ(p)a^b\\equiv a^{b\\% \\varphi (p)+\\varphi (p)}ab≡ab%φ(p)+φ(p)。为什么呢？证明有一定的难度，就先咕咕。可以参考这篇文章。可是 log⁡k\\log klogk 和 log⁡m\\log mlogm 其实差距不大。因此该 T 还是 T。怎么办呢？考虑我们是怎么计算 φ,μ\\varphi,\\muφ,μ 这些函数的？它们是积性函数，因此我们可以用线性筛计算。这里也是一样。我们对于每一个质数调用线性筛计算 pbp^bpb，对于合数直接根据已经算好的 pbp^bpb 得到 aba^bab。这样的时间复杂度就是 O(n+log⁡nlog⁡m)O(n+\\log n\\log m)O(n+lognlogm)，可以通过本题。 三角形三元环计数题啊……正统的三元环计数方法是由度数大的点向度数小的点连边（反之亦可，度数相等的点按编号顺序）。然后对于每一个点 xxx，标记它所有（出边的）邻点 uuu，标记完成后再从每一个邻点 uuu 遍历它的所有邻点 vvv，如果 vvv 也是 uuu 的邻点（也就是被 uuu 标记过），那么就找到了一个三元环。关于时间复杂度，考虑把上面两步（从 xxx 出发的遍历和从 uuu 出发的便利）分开计算。第一步的时间复杂度是 O(n+m)O(n+m)O(n+m)，第二步则比较玄学，是 O(nm)O(n\\sqrt{m})O(nm​) 一类的（假设 n,mn,mn,m 同阶）。如何计算补图中三角形的数目呢？考虑原图中的所有三点组，这些三点组之间可能有 0,1,2,30,1,2,30,1,2,3 条边。并且式子 m(n−2)m(n-2)m(n−2) 就把所有的一边组计数 111 次、二边组计数 222 次、三边组计数 333 次。在上述找三元环的过程中很容易计算出一边组和三边组的数量，再算出二边组的数量，用总的三点组数减去一、二、三边组的数量就可以得到补图中的三元环数了。这种题……如果不知道算法的话就多多暴力吧。 数谁知道这题暴搜能过啊？ 最短路 Greg and Graph所有的删东西都是不好做的，因此只要题目允许，直接离线倒过来做。加点？n≤500n\\le 500n≤500？直接 Floyd 就可以了。如果要加边，似乎是 SPFA？虽然正解似乎是动态树就是了。 社交网络n≤100n\\le 100n≤100 的最短路？直接 Floyd 更新一下方案数。 权值变换f(x)=−1x−1, f(f(x))=1−1xf(x)=-\\frac{1}{x-1},\\ f(f(x))=1-\\frac{1}{x}f(x)=−x−11​, f(f(x))=1−x1​。好像没有什么希望？再算下去就可以了，f(f(f(x)))=xf(f(f(x)))=xf(f(f(x)))=x！由于三次就循环了，所以只需要扩充状态，记录当前走的步数模 333 即可。 欧拉路和欧拉回路 SGU101这道题怎么好像是见过的样子……？如果把骨牌当做点，相同的数字当做边，然后……边数怎么好像很大的样子？而且我们要求的是一条恰好所有点且不重复的路径，这是……哈密顿路径？NPC 啊。这里有更好的方法！把数字当做点，骨牌当做边，就变成欧拉路径了。 POI Garbage这里有一个神奇的地方，存在一种方案，使得每一条边都只被操作奇数次，因为考虑两个有交的操作环（桥环），他们的公共边会被操作两次；但是如果我们观察实际操作一次的边，就会发现这些边是两个环的异或，并且恰好形成了一个大环；于是这样的操作可以被替换为“操作一个大环”。 DAG 经典题求 DAG 上 111 到 nnn 路径的必经点。考虑路径计数，如果 1→u1\\rightarrow u1→u 的路径数和 u→nu\\rightarrow nu→n 的路径数之积等于 1→n1\\rightarrow n1→n 的路径数，就说明 uuu 是必经点。 菜肴制作求（置换群意义下）逆元的字典序最小的拓扑序。也就是在 111 的位置尽量靠前的前提下，让 222 的位置尽量靠前；……；在 1,2,⋯ ,k1,2,\\cdots,k1,2,⋯,k 的位置尽量靠前的前提下，让 k+1k+1k+1 的位置尽量靠前；……事实上这里有一个很巧妙的转化：取反图，在反图上跑字典序最大的拓扑序，再反过来就可以了。这怎么证明呢？其实相当有难度。先证明一个小引理：反图的任意拓扑序反过来都是原图的拓扑序。这个根据拓扑序的定义就可以证出来了。下面说明这个算法一定会计算出最优解（证明不会证）。在反图上求解的过程中，如果在当前所有可选点中尽量选择大的，那么可以把小的位置留给小的点，并且可选的点的集合会变大；因此从理解上，这样是最优解。 连通性 Business这是入门经典的题目。我们肯定不会选择割点，接着讨论每一个点双，如果点双的周围有不小于 222 个割点，那么久不需要选；如果只有 111 个割点，那么就要在连通块内部建一个。特别地，如果全图点双连通，需要选 222 个。也可以从缩点的角度考虑。 新年的毒瘤根据树的定义——树是 nnn 个点、n−1n-1n−1 条边的简单无向连通图；因此只要删除一个点后，图仍满足这个性质，那么这个点就是毒瘤节点。只需要考虑非割点的点，去掉之后边数是否符合条件即可。 CF402E Strictly Positive Matrix这题真的很厉害。首先由于我们只关心是不是 000，因此我们可以把所有的正数变成 111，这样这个矩阵就变成了 010101 矩阵。接下来根据讲课内容，我们要把这个矩阵与图论联系起来。图论……矩阵……似乎只有邻接矩阵和基尔霍夫矩阵了。那么邻接矩阵的 kkk 次幂是什么意思呢？先令 k=2k=2k=2。那么 Gi,j2=∑u=1nGi,u×Gu,jG^2_{i,j}=\\sum \\limits_{u=1}^{n} G_{i,u}\\times G_{u,j}Gi,j2​=u=1∑n​Gi,u​×Gu,j​，由于只关心 010101，又可以化为 G^2_{i,j}=\\bigcup\\limits_{u=1}^{n} G_{i,u}\\and G_{u,j}。发现了什么？和 Floyd 很像吧。这就表示 iii 能否途经 uuu 到达 jjj！于是问题就明朗了。Gi,jkG^k_{i,j}Gi,jk​ 表示是否存在长度为 kkk 的 i→ji\\rightarrow ji→j 路径。因此只要这个图是强连通的，就可以满足要求。由于 nnn 只有 200020002000，因此每个点搜一遍就好了。另外多提一句，如果不改为 010101 矩阵，这个 GkG^kGk 又是什么意思呢？邻接矩阵某一位上的数如果大于 111，就说明这两点间有重边。而再看 Gi,j2=∑u=1nGi,u×Gu,jG^2_{i,j}=\\sum \\limits_{u=1}^{n} G_{i,u}\\times G_{u,j}Gi,j2​=u=1∑n​Gi,u​×Gu,j​，就会发现…… Gi,j2G^{2}_{i,j}Gi,j2​ 表示长度为 222 的 i→ji\\rightarrow ji→j 路径的条数！于是 Gi,jkG^{k}_{i,j}Gi,jk​ 就表示长度为 kkk 的 i→ji\\rightarrow ji→j 路径的条数。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"CSP 2019 集训 字符串和树","slug":"CSP2019-string-and-tree","date":"2019-11-10T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-string-and-tree/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-string-and-tree/","excerpt":"字符串","text":"字符串 哈希 (Hana~!)总之是很容易写，也比较稳的方法了。树哈希？把树的节点排一下序，然后转化为括号序列，最后字符串哈希就好了。 Blue Mary的战役nnn 这么小，当然暴力啦。如何快速比较两个子矩阵是否相等？当然哈希啦。 Trie多模匹配非常有用。 补退选前两个操作肯定是 Trie，第三个操作呢？在每个 Trie 节点上搞一个 vector 记录这个节点 size\\mathrm{size}size 为 ttt 的最早时刻，时空复杂度都可以接受。 KMP解释清楚算法的关键是 next 数组的“次优解”意义。 字符串周期这个在 KMP 小记 里有详细介绍。 抄卡组对于 *，我们怎么处理呢？对于两个都有星号的字符串，只有第一个星号之前和最后一个星号之后的字符串是需要匹配的，因为中间不一样的地方都可以塞进星号里。对于两个没有星号的字符串，直接暴力比较是否完全相同即可。对于一个有星号和一个没有星号的字符串，每两个星号之间的部分必须依次在无星号字符串里匹配。这个使用 KMP 就可以了。 Manacher 双倍回文求一个字符串最长的形如 wwRwwRww^Rww^RwwRwwR 的子串，其中 wRw^RwR 表示 www 的 reverse。首先要发现一个特点，就是 wwRwwRww^Rww^RwwRwwR 不是简单的回文串的拼接，它自身也是回文串——事实上这个通过多举例就可以发现，证明也很简单。于是我们假设第二个 www 的位置是 [x,y][x,y][x,y]，那么以 x−1x-1x−1 为中心的回文半径必须覆盖到 wwRww^RwwR，也就（大约）是 2(y−x)+x2(y-x)+x2(y−x)+x；以 yyy 为中心的回文串必须覆盖到 xxx。因此大概是一个可以用数据结构优化的东西。 树 dfs 序第一种是长度为 nnn 的简单 dfs 序，只在 op 时加入序列。这时所有子树都是连续序列。模板题是 LOJ 144 DFS 序 1、LOJ 145 DFS 序 2。第二种是长度为 2n2n2n 的 dfs 序，在 op 时加入正的值，在 ed 时加入负的值，这时节点到祖先的路径也成为了连续序列——序列中无关的点都会正负抵消。 [HAOI2015]树上操作看到题是不是就写了树剖？树剖确实是可以做的，但是也可以用长度为 2n2n2n 的 dfs 序。这里唯一的问题是，如何进行子树修改操作？这是一段序列，我们需要正的加、负的减。有两种方法。一种是正负分离，搞一个 op 序列和一个 ed 序列，对每个点记录一下它在 op 序列上的位置和在 ed 序列上的位置，加的时候在两个序列里分别加就行了。另一种方法是真的处理这个“正的加、负的减”。考虑这些操作对线段树这个节点的影响。线段树上这个节点只记录了这段区间的和，而这次修改对线段树这段区间和的影响当然是“正的增加量-负的减少量”，也就是 v×pcnt−v×ncntv\\times \\mathrm{pcnt}-v\\times \\mathrm{ncnt}v×pcnt−v×ncnt，提公因式得到 v(pcnt−ncnt)v(\\mathrm{pcnt}-\\mathrm{ncnt})v(pcnt−ncnt)，而 pcnt\\mathrm{pcnt}pcnt 和 ncnt\\mathrm{ncnt}ncnt 是建树后就不会再改变的，因此我们只需要记录每个节点所管理区间的正数个数和负数个数的差值，修改时就能正确计算出影响了。 树上前缀和与树上差分这里复制树上前缀和与树上差分的原文。树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。 树上前缀和树上前缀和——某个节点到根的路径上的每个点的权值和求法：dfs\\mathrm{dfs}dfs时带参数传递下去即可用法：x→yx\\rightarrow yx→y的权值和点权：s[x]+s[y]−s[lca]−s[par(lca)]s[x]+s[y]-s[\\mathrm{lca}]-s[\\mathrm{par}(\\mathrm{lca})]s[x]+s[y]−s[lca]−s[par(lca)]边权： s[x]+s[y]−2s[lca]s[x]+s[y]-2s[\\mathrm{lca}]s[x]+s[y]−2s[lca] 树上差分树上差分——某个节点对它到根的路径上的每个点的贡献求法：修改x→yx\\rightarrow yx→y上每个点/边的权值时：点权：d[x]+=w, d[y]+=w, d[lca]−=w, d[par(lca)]−=wd[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=w,\\ d[\\mathrm{par}(\\mathrm{lca})]-=wd[x]+=w, d[y]+=w, d[lca]−=w, d[par(lca)]−=w边权：d[x]+=w, d[y]+=w, d[lca]−=2wd[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=2wd[x]+=w, d[y]+=w, d[lca]−=2w用法：某个节点的权值即为它子树所有节点的差分和 点权和边权我们的树上前缀和与树上差分（还有树链剖分，小声）都是基于点权的。那么如果遇到边权的问题，如何解决呢？当然是把边权分配到点上了啊。由于每个点的父节点是唯一的，因此每个点到父节点的连边是唯一的。那么，我们把边权分配到子节点上，也就是分配到深度较大的端点上，问题就解决了。 树上两点距离当然要找 LCA，然后如何求距离呢？可以在倍增的时候边跳边算。但是如果带上修改（每次修改一条边的权值）呢？这就要用到树上前缀和了。设 d[i]d[i]d[i] 表示从 iii 到根的路径长度（“某个节点到根的路径上的每个对象的权值和”），查询的时候 d[x]+d[y]−2d[LCA(x,y)]d[x]+d[y]-2d[\\mathrm{LCA}(x,y)]d[x]+d[y]−2d[LCA(x,y)] 就可以了。修改边权会且仅会影响到一棵子树里所有点的 ddd，根据长为 nnn 的 dfs 序的性质，子树里的点是一个连续的区间。区间修改-单点查询，用差分树状数组就可以了。 DFS 序 3, 树上差分 1这是 LOJ 的模板。路径加，可以拆成两条树链（树上的点到祖先的路径）的加，就是所谓的“区间加”。如果不用树链剖分，就要使用树上差分，将树链的修改变为端点的单点修改，这样询问一个点的权值就要查看所哟对它有贡献的点。回忆一下，树上差分的定义是“某个节点对它到根的路径上的每个点的贡献”，于是对某个点有贡献的点就是以它为根的子树中的所有点。因此查询单点权值就要变为查询子树和。那么查询子树权值怎么办呢？子树和的子树和？还记得数列差分是如何处理“前缀和的前缀和”的吗？再存一个“i×dii\\times d_ii×di​”就可以了。这里也是类似的，要维护类似于 depth(x)×dx\\mathrm{depth}(x)\\times d_xdepth(x)×dx​ 的东西。 DFS 序 4其实这道题和 树上操作 是同一道题……但是数据范围不对！怎么办呢？似乎可以用 ±1\\pm 1±1 DFS 序配合正负分离做到？如果非要用普通 DFS 序呢？修改有两种，一种是单点加，一种是子树加。由于是加法，因此我们可以把两种修改操作分开，查询时分别计算贡献。考虑单点加对查询（树链）的影响，那当然是用树上前缀和（树链型）直接做——单点加、区间查，树状数组就可以处理。考虑子树加对树链的影响。 LCA 运输计划给定树上的 mmm 对点，把某一条树边的权值改为 000，使得这 mmm 对点距离的最大值最小。由于是“最大值最小”，为了方便，我们采用二分答案——二分一个答案，表示“是否可以使所有点对之间的距离都不大于 ans\\mathrm{ans}ans”，满足可二分性。接下来的问题就是如何在 O(n+m)O(n+m)O(n+m) 时间内判定了。由于只能删除一条边，这个问题事实上比较简单。考虑每一对距离超过了 ans\\mathrm{ans}ans 的点（假设这样的点有 ttt 对），它们之间的路径上必须有一条边被操作，并且这一条边，否则这对点的距离不变，不可能满足要求。假设距离最大的点的距离是 ddd，那么删除的边的权值至少是 d−ansd-\\mathrm{ans}d−ans。对于每一对点，我们可以给这一对点路径上的所有边都打上标记，表示删除这些边会影响这一对点的距离。最后要删除的边一定影响到所有 ttt 对点，且权值至少为 d−ansd-\\mathrm{ans}d−ans。于是我们再扫描一下所有边，查看是否存在这样的边即可。问题是，怎么打标记呢？这是一个路径加、加完毕后查询的操作，因此可以用树上差分解决。 巡逻只加一条边时，树变成基环树，环上的边只需要走一次，因此把这一条边连在直径上即可。加两条边时，会形成两个简单环，只在一个环上的边只需走一次，其余边要走两次。因此在只加一条边的基环树的基础上找直径，把原来的环上每一条边的权值设为 −1-1−1，表示选了这条边要把原来省下的费用还回去。 最小生成树 货车运输最大瓶颈路 + 树上查询。 免费道路比较神奇的题目。首先判断是否无解，求最小生成树和最大生成树，如果最小生成树中 000 边少于 kkk 条或最大生成树中 000 边多于 kkk 条，就一定无解。否则考虑从最小生成树加一条 111 边、删一条 000 边，一定能逐渐减少 000 边数量、增加 111 边数量，从而达到 000 边恰好是 kkk 条的状态。（结论：一个图的两个生成树，一定可以通过一系列连续的“删边-加边”操作相互变换得到，变换过程中任意边数为 n−1n-1n−1 的时刻都得到一个生成树。）然而我们不能一条一条边地替换。现在的方法是，把最大生成树中的所有 000 边加入，再把其余的边排序做最小生成树，先加 000 边直到 000 边达到 kkk 条，接下来只加 111 边，加到连通为止。这就相当于把最大生成树中的一些 111 边自动替换成了 000 边，因此是一定可以求出解的。这题应该是介绍了生成树之间的变换吧。 次小生成树在最小生成树上换边，从小到大加入非树边，把非树边所在环上最大的一条边替换掉即可。 最小生成树计数求 nnn 个点的图的不同的最小生成树的数量，n≤100n\\le 100n≤100。这道题非常好地阐述了最小生成树的性质。在 Kruscal 过程中，如果把边按照权值分成若干块，块内所有边权值相等，那么无论块内边的顺序如何，跑完某一块后，图的连通性总是一定的，这一块被选的边的数量也是相同的。因此不同块的选边是独立的，我们只需要每一块枚举一下即可。如果没有原题中的限制，同权边很多怎么办呢？可以用矩阵树定理计算。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"字符串","permalink":"https://sweetlemon39.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树","slug":"树","permalink":"https://sweetlemon39.github.io/tags/%E6%A0%91/"}]},{"title":"树上前缀和与树上差分","slug":"s-and-d-on-a-tree","date":"2019-06-26T00:00:00.000Z","updated":"2019-06-26T00:00:00.000Z","comments":true,"path":"s-and-d-on-a-tree/","link":"","permalink":"https://sweetlemon39.github.io/s-and-d-on-a-tree/","excerpt":"树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。","text":"树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。 树上前缀和树上前缀和——某个节点到根的路径上的每个点的权值和求法：dfs\\mathrm{dfs}dfs时带参数传递下去即可用法：x→yx\\rightarrow yx→y的权值和点权：s[x]+s[y]−s[lca]−s[par(lca)]s[x]+s[y]-s[\\mathrm{lca}]-s[\\mathrm{par}(\\mathrm{lca})]s[x]+s[y]−s[lca]−s[par(lca)]边权： s[x]+s[y]−2s[lca]s[x]+s[y]-2s[\\mathrm{lca}]s[x]+s[y]−2s[lca] 树上差分树上差分——某个节点对它到根的路径上的每个点的贡献求法：修改x→yx\\rightarrow yx→y上每个点/边的权值时：点权：d[x]+=w, d[y]+=w, d[lca]−=w, d[par(lca)]−=wd[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=w,\\ d[\\mathrm{par}(\\mathrm{lca})]-=wd[x]+=w, d[y]+=w, d[lca]−=w, d[par(lca)]−=w边权：d[x]+=w, d[y]+=w, d[lca]−=2wd[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=2wd[x]+=w, d[y]+=w, d[lca]−=2w用法：某个节点的权值即为它子树所有节点的差分和 点权和边权我们的树上前缀和与树上差分（还有树链剖分，小声）都是基于点权的。那么如果遇到边权的问题，如何解决呢？当然是把边权分配到点上了啊。由于每个点的父节点是唯一的，因此每个点到父节点的连边是唯一的。那么，我们把边权分配到子节点上，也就是分配到深度较大的端点上，问题就解决了。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"树","slug":"树","permalink":"https://sweetlemon39.github.io/tags/%E6%A0%91/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"前缀和","slug":"前缀和","permalink":"https://sweetlemon39.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://sweetlemon39.github.io/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"桶排序、基数排序与后缀排序","slug":"bucket-radix-suffix-sort","date":"2019-06-25T00:00:00.000Z","updated":"2019-06-25T00:00:00.000Z","comments":true,"path":"bucket-radix-suffix-sort/","link":"","permalink":"https://sweetlemon39.github.io/bucket-radix-suffix-sort/","excerpt":"最近学后缀数组，需要接触到这些排序方法，于是乎开帖记录。","text":"最近学后缀数组，需要接触到这些排序方法，于是乎开帖记录。 术语说明本文中，“排名”可以粗浅地理解为“不大于xxx的元素个数称为xxx的排名”。但是，有重复元素的时候，假设小于xxx的元素个数是aaa，不大于xxx的元素个数是bbb，那么这些重复元素的排名各不相同，且都位于区间(a,b](a,b](a,b]中。如，数组1,1,2,3,3,41,1,2,3,3,41,1,2,3,3,4中各元素的排名可以是1,2,3,4,5,61,2,3,4,5,61,2,3,4,5,6，当然也可能是2,1,3,5,4,62,1,3,5,4,62,1,3,5,4,6等等。本文中要大量使用“元素数组”、“排名数组”这样的词汇，请牢记它们的含义：叫做什么数组，里面存的就是什么值。“元素数组”指根据排名查元素编号的数组，即ele:{rank}→{id}\\mathrm{ele}:\\left\\{\\mathrm{rank}\\right\\}\\rightarrow \\left\\{\\mathrm{id}\\right\\}ele:{rank}→{id}“排名数组”指根据元素编号查排名的数组，即rk:{id}→{ele}\\mathrm{rk}:\\left\\{\\mathrm{id}\\right\\}\\rightarrow \\left\\{\\mathrm{ele}\\right\\}rk:{id}→{ele}这两个数组之间是逆映射的关系。在桶排序中，还会用到桶数组。桶数组是根据元素值查“这个值的元素有多少个”的数组，做前缀和后就是根据元素值查“不大于这个值的元素有多少个”的数组。通常，我们使用它的后一种含义。“桶数组”是根据元素值查“不大于这个值的元素有多少个”的数组，即bucket:{value}→{rank}\\mathrm{bucket}:\\left\\{\\mathrm{value}\\right\\}\\rightarrow \\left\\{\\mathrm{rank}\\right\\}bucket:{value}→{rank}熟悉这些映射关系，对于快速写出代码有很大帮助。文中还用了 Pascal 的数组区间符号。a[1...3]={1,2,3}表示a[1]=1,a[2]=2,a[3]=3。 离散化首先我们通过复习离散化方法，熟悉“元素数组”和“排名数组”的意义。123456789101112131415int a[MAXN]; //原始数据int ele[MAXN],rk[MAXN]; //定义见上文bool cmp(const int lhs,const int rhs);for (int i=1;i&lt;=n;i++) ele[i]=i; //初始化，假设第i名的元素下标是isort(ele+1,ele+1+n,cmp); //排序后，第i名元素的下标是ele[i]//利用rk和ele的互逆关系求rkfor (int i=1;i&lt;=n;i++) rk[ele[i]]=i; //第i名元素的下标所对应的排名是i bool cmp(const int lhs,const int rhs)&#123; //利用元素给下标排序 return a[lhs]&lt;a[rhs];&#125;上述代码执行后，rk数组中的值就是离散化目标值。 桶排序 单关键字桶排序桶排序？这个谁不会啊？123456789int a[MAXN],bucket[MAXM]; //原始数据, 桶(桶的定义域是原始数据的值域)for (int i=0;i&lt;MAXM;i++) bucket[i]=0;for (int i=1;i&lt;=n;i++) bucket[a[i]]++;int pos=0;for (int i=0;i&lt;MAXM;i++) for (int j=0;j&lt;bucket[i];j++) a[++pos]=i;但是如何用桶排序求出元素数组和排名数组呢？这里介绍一种简单的办法。我们知道，原始的桶数组记录的是“值为xxx的元素的个数”。如果对桶数组做前缀和，记录的就是“值不大于xxx的元素个数”——不就是“值为xxx的元素的（最大）排名”吗？之所以是“最大”，是因为可能有重复元素（参见“术语说明”）。于是，我们可以用这种方法得到元素数组和排名数组。下面这段代码对于理解多关键字桶排序比较重要，请认真阅读。如果对代码不太理解，请接着阅读下面的说明。1234567891011121314151617181920int a[MAXN],bucket[MAXN],ele[MAXN],rk[MAXN];for (int i=0;i&lt;MAXM;i++) bucket[i]=0;for (int i=1;i&lt;=n;i++) bucket[a[i]]++;for (int i=1;i&lt;MAXM;i++) bucket[i]+=bucket[i-1]; //求前缀和// 此时bucket数组的意义就是“给值，求最大排名”// 下面用bucket数组求ele数组for (int i=n;i;i--)&#123; // 这个循环是倒序的 int trank=bucket[a[i]]; // 求出i号元素的排名 bucket[a[i]]--; // 排名trank已经被i占用了，下一个来的元素要用上一个可用的排名 ele[trank]=i; // 排名为trank的元素编号是i // 上面这三条语句通常缩写为 // ele[ bucket[a[i]]-- ]=i;&#125;//此时, a[ele[1]],a[ele[2]],...,a[ele[n]]就是有序的了//再利用rk和ele的互逆关系求rkfor (int i=1;i&lt;=n;i++) rk[ele[i]]=i; //第i名元素的下标所对应的排名是i现在问题来了，为什么这个循环是倒序的呢？也就是说，我们需要搞清楚，排名的“分配原则”是什么。同时我们还要搞懂这行关键代码：ele[ bucket[a[i]]-- ]=i;首先，如果数组中没有重复元素，那么bucket[a[i]]只会被访问一次，其中的值正是i号元素的真正排名。但如果数组中有重复元素呢？举个例子，如果a[1...6]={1,4,3,1,3,2}，那么在求前缀和之前，bucket[1...4]={2,1,2,1}；求前缀和之后，bucket[1...4]={2,3,5,6}。那么，111的“最大排名”是222，333的“最大排名”是555。我们倒序循环分配排名。首先i=6，ele[ bucket[a[6]]-- ]=6。执行语句时bucket[a[6]]=bucket[2]=3，于是我们得到了666号元素的排名是333，也就是被赋予了排名333的元素是666号(ele[3]=6)。根据--运算符的规则，我们把bucket[2]的值减111，那么执行后bucket[2]=2。这表示，排名333已经被占用了，下一个值为222的元素只能使用排名222——当然，由于数列中只有一个元素的值是222，因此不存在所谓的“下一个元素”。接着i=5，ele[ bucket[a[5]]-- ]=5。bucket[a[5]]=bucket[3]=5，那么这次我们把排名555赋给a[5]。这时bucket[3]--，表示下一个值为333的元素只能使用排名444——在这里就表示，靠前的一个333将使用排名444。继续模拟这个过程，最后ele[1...6]={1,4,6,3,5,2}。在模拟的过程中我们发现，值相同的元素，先者总是得到较大的排名。就有些像孔融让梨，孔融是把大的梨让出去，先拿到排名的元素是把靠前的排名让给后拿到排名的元素。而我们倒序循环，原本靠后的元素将先得到排名，结果就是值相同的元素，原本靠后的，排名也较大（即在排序后的数组里也靠后）。这正满足了“稳定性”的定义——这样它就是“稳定排序”了。当然，这么做的意义远不止如此，正是这一操作，为桶排序提供了可扩展性。请看—— 多关键字桶排序什么叫“多关键字”呢？就有点像中考成绩排序——先按总分等级排序，总分等级相同的再按A+数排序，A+数相同的……概括地说，就是，优先按第一关键字排序，如果第一关键字相同，再按第二关键字排序。下面我们只讨论两个关键字的情形；在此基础上，很容易扩展出更多关键字的排序。还记得上面讲的“稳定性”吗？我们有一个思路——先按第二关键字排序，再按第一关键字做稳定排序。为什么先排次要关键字呢？可以这么理解——第一次排序的结果会被第二次排序打乱，因此是次要的。第一次排序只是为了第二次排序在关键字相同时，提供原先的相对位置。也就是，第一次排序的功效，体现在了排序前相对位置上。那么我们就可以写出多关键字桶排序的代码了。123456789101112131415161718192021int a[MAXN],b[MAXN];// a 为主要关键字, b为次要关键字// ele_b是第一次排序时用的ele数组int bucket[MAXN],ele[MAXN],ele_b[MAXN],rk[MAXN];for (int i=0;i&lt;MAXM;i++) bucket[i]=0;for (int i=1;i&lt;=n;i++) bucket[b[i]]++;for (int i=1;i&lt;MAXM;i++) bucket[i]+=bucket[i-1];for (int i=n;i;i--)// 仍然注意这个循环是倒序的 ele_b[ bucket[b[i]]-- ]=i;//现在b[ele_b[1]],b[ele_b[2]],...,b[ele_b[n]]是有序的//我们下一次桶排序循环的时候,就按照ele_b[n],ele_b[n-1],...,ele_b[1]的顺序for (int i=0;i&lt;MAXM;i++) bucket[i]=0;for (int i=1;i&lt;=n;i++) bucket[a[i]]++;for (int i=1;i&lt;MAXM;i++) bucket[i]+=bucket[i-1];//这三个for循环基本相同for (int i=n;i;i--)// 按我们上面说的做！ ele[ bucket[ a[ ele_b[i] ] ]-- ]=ele_b[i];整段代码最难理解的应该就是ele[bucket[a[ele_b[i]]]--]=ele_b[i];这一行了。足足四层嵌套，让不少多关键字桶排序和基数排序的初学者望而生畏。下面我们解析它。对b做排序的时候，我们已经写过一次三层嵌套了。ele_b[ bucket[b[i]]-- ]=i;，意思是bucket[b[i]]中存着b[i]的排名，那么排名为bucket[b[i]]的元素编号就是i。对a做排序的时候，我们不是要按ele_b[n],ele_b[n-1],...,ele_b[1]的顺序做嘛——于是，运用换元法，把ele_b[i]带入原来的i中，不就得到了这一行代码吗？于是，双关键字的桶排序就写好了。这也就是这道题的解法。 基数排序基数排序其实就是多关键字的桶排序。比如，给三位数排序，第一关键字是百位，第二关键字是十位，第三关键字是个位。但实际操作中，我们所用的模数不是101010，而是222的幂。根据挑战这道题的经验，我们取256(28)256(2^8)256(28)为模，把323232位整数（也就是int）分为四个关键字进行排序，分别排序四次就好了。12345678910111213141516171819202122232425262728#define MASK 255int a[MAXN],b[MAXN]; //a储存原数据, b在排序过程中会发生改变int b1[BUSKN],b2[BUSKN],b3[BUSKN],b4[BUSKN]; //val -&gt; rank, 四次排序的桶int e1[MAXN],e2[MAXN],e3[MAXN],e4[MAXN]; //rank -&gt; ID, 四次排序的ele数组for (int i=1;i&lt;=n;i++)&#123; int t=b[i]=a[i]; b1[t&amp;MASK]++,t&gt;&gt;=8; b2[t&amp;MASK]++,t&gt;&gt;=8; b3[t&amp;MASK]++,t&gt;&gt;=8; b4[t&amp;MASK]++; //分别加到桶里&#125;for (int i=1;i&lt;=MASK;i++) b1[i]+=b1[i-1],b2[i]+=b2[i-1], b3[i]+=b3[i-1],b4[i]+=b4[i-1]; //给桶做前缀和//核心步骤——赋予排名for (int i=n;i;i--) e1[b1[b[i]&amp;MASK]--]=i, b[i]&gt;&gt;=8;for (int i=n;i;i--) e2[b2[b[e1[i]]&amp;MASK]--]=e1[i],b[e1[i]]&gt;&gt;=8;for (int i=n;i;i--) e3[b3[b[e2[i]]&amp;MASK]--]=e2[i],b[e2[i]]&gt;&gt;=8;for (int i=n;i;i--) e4[b4[b[e3[i]]&amp;MASK]--]=e3[i];for (int i=1;i&lt;=n;i++) ayano(a[e4[i]],' '); //按顺序输出整数 后缀排序给后缀排序是建立后缀数组（Suffix Array）的关键操作。字符串s[1...n]的后缀就是指这些子串：s[1...n],s[2...n],s[3...n],...,s[n...n]。按照后缀的起始点，分别把它们编号为1,2,3,⋯ ,n1,2,3,\\cdots,n1,2,3,⋯,n。“后缀排序”就是对这nnn个后缀（就是nnn个字符串）进行排序。当然不是真的排序，只是求出元素数组和排名数组罢了。在这里重新强调元素数组和排名数组的定义：元素数组，此处称作后缀数组或sa数组，表示排名为i的后缀的编号是sa[i]排名数组，此处称作rank（缩写为rk）数组，表示编号为i的后缀排名为rk[i]还是那句话，“名副其实”，后缀数组里的东西是后缀（的编号），排名数组里的东西是排名。如何给后缀排序呢？最简单的方法当然是直接应用一遍快速排序，时间复杂度是O(nlog⁡n)\\mathrm{O}(n\\log n)O(nlogn)，足够快了吧。可惜的是，这个时间复杂度是错的。由于比较两个字符串是O(n)\\mathrm{O}(n)O(n)而非O(1)\\mathrm{O}(1)O(1)的，快速排序需要O(nlog⁡n)\\mathrm{O}(n\\log n)O(nlogn)次比较，因此正确的复杂度应该是O(n2log⁡n)\\mathrm{O}(n^2 \\log n)O(n2logn)，无法承受。那么改成基数排序吧？字符串的排序是按照字典序，也就是以第一个字符为第一关键字、以第二个字符为第二关键字，以此类推。可是这样会有nnn个关键字，需要（桶）排序nnn次，每次排序的时间复杂度是O(n)\\mathrm{O}(n)O(n)，合起来达到O(n2)\\mathrm{O}(n^2)O(n2)，依然无法承受。做不出来的时候怎么办？看看我们是不是漏条件了啊。上面的两种方法可是不仅可以用于后缀排序，还可以用于“给nnn个字符串排序”啊。这不就相当于，“后缀”的条件完全没有利用上吗？那怎么可能做得出来啊。“后缀”的条件是，这些字符串有很多的公共部分！利用这些公共部分，就能改善我们算法的时间复杂度！利用这个条件的方法很多，像后缀树、后缀平衡树、后缀自动机等。当然，我们在这里要介绍的是最简单的一种——倍增法求后缀数组。倍增法的主要思想是，“用排名代替具体的元素”。我们用字符串&quot;aabaaaab&quot;做例子（这个例子好经典，为什么？因为它是 IOI 2009 国家集训队论文里边的啊~），它的后缀有&quot;b&quot;,&quot;ab&quot;,&quot;aab&quot;,&quot;aaab&quot;,&quot;aaaab&quot;,'baaaab&quot;,&quot;abaaaab&quot;,&quot;aabaaaab&quot;。首先，我们把所有的后缀调整成一样长的，也就是（假装）我们在字符串后面补了一些空字符（'\\0'，字典序是最小的；下面用0表示）。那么后缀就变成了&quot;b0000000&quot;,&quot;ab000000&quot;,&quot;aab00000&quot;,&quot;aaab0000&quot;,&quot;aaaab000&quot;,'baaaab00&quot;,&quot;abaaaab0&quot;,&quot;aabaaaab&quot;。补这些字符并不影响字典序，因为我们规定，比不出大小时短的字符串较小。思考这个问题：某些元素，按(a,b)(a,b)(a,b)双关键字排序的排名是xxx，按(c,d)(c,d)(c,d)双关键字排序的排名是yyy，那么按(a,b,c,d)(a,b,c,d)(a,b,c,d)四关键字排序的排名是否就相当于按(x,y)(x,y)(x,y)双关键字排序的排名呢？（关键字的顺序表示主次顺序。）思考后可以发现，答案是肯定的。那么，我们就把这个字符串的所有长度为111的块进行排序；接着把它所有长度为222的块按照组成它的两个111块的排名（在前面的是主要关键字，在后面的是次要关键字）进行双关键字排序，就可以得到222块的排名；然后再把444块按照222块的排名进行双关键字排序，得到444块的排名……直到块的长度不小于nnn为止。此时每一个块都是原串的后缀（因为长度不小于nnn，因此除了s[1...n]，其余块都一定要越过s[n]补零，也就成了后缀），我们就得到了后缀的排序。引用一下集训队论文里的图片——从图中我们可以看到，每一次排序都是把上次排序的rank数组作为元素值，也就是“用排名代替具体的元素”。排序的主要关键字是上一次的rank[i]，次要关键字是上一次的rank[i+w]，其中w=2kw=2^kw=2k。从图中我们还可以看到，我们不必实际地去补“0”，只需要在所找的222块、444块等超出边界的时候直接令他们的原排名为000即可。那么，我们就可以实现代码了。首先是桶排序部分的代码。我们已经把次要关键字rk[i+w]的元素数组制作好并存到了数组tp里，因此相当于次要关键字已经排好序了。注意，sa和tp都是元素数组。12345678910111213void bucket_sort(int n,int m)&#123; // 任务: 根据主要关键字的值数组rk和次要关键字的排名数组tp, 计算元素数组sa // n是字符串长, m是rk和tp的值域（[1,m]） // 各映射的信息: rk: id-&gt;val, tp: rank-&gt;id, bucket: val-&gt;rank, sa: rank-&gt;id for (int i=0;i&lt;=m;i++) bucket[i]=0; for (int i=1;i&lt;=n;i++) bucket[rk[i]]++; for (int i=1;i&lt;=m;i++) bucket[i]+=bucket[i-1]; for (int i=n;i;i--) sa[ bucket[ rk[ tp[i] ] ]-- ] = tp[i];&#125;四重嵌套那一行可能比较难写。一个较为快速的推法是，把映射关系写下来，再根据映射关系写（“量纲分析”）。要求出sa，先写sa[ ]=sa的值是id，值是id的只有tp，写下sa[ ]=tp[i]sa的定义域是rank，值域是rank的只有bucket，写下sa[bucket[ ]--]=tp[i]（是bucket，所以伴随着--）bucket的定义域是val,值域是val的只有rk，写下sa[bucket[rk[ ]]--]=tp[i]rk的定义域是id，值域是id的已知量只有tp，写下sa[bucket[rk[tp[i]]]--]=tp[i]。接着再来实现后缀排序的主函数。123456789101112131415161718192021222324252627282930313233343536373839404142void suffix_sort(int n)&#123; //字符串长度为n //先做一遍长度为1的块的排序 //因为是第一遍排序, 所以第一关键字是字符大小 //第二关键字随意指定一个，那么第二关键字的元素数组可以设为1,2,...,n int m='z'-'/'; //假设字符集是0-9,A-Z,a-z //m表示字符集大小,也就是值数组的值域 for (int i=1;i&lt;=n;i++) //分别求出第一遍排序的主要关键字 值数组 和次要关键字 元素数组 rk[i]=str[i]-'/', tp[i]=i; bucket_sort(n,m); //下面开始重复排序，也就是倍增过程 for (int w=1,p=0;w&lt;n &amp;&amp; p&lt;n;w&lt;&lt;=1,m=p)&#123; //w表示上一次排序的块长 //为进行排序,先制作tp数组 p=0; //记录排名 //先处理那些次要关键字已经超过了串的末尾,也就是达到补零位置的块 for (int i=n-w+1;i&lt;=n;i++) tp[++p]=i; //将“++p”这个排名分配给i这个块 //这些块的次要关键字都一样,任意指定一些最靠前的排名就好了 //接着根据上一回排序的“排名”的元素数组，制作本次的元素数组 for (int i=1;i&lt;=n;i++) //取上一回第i名的块,分配排名 if (sa[i]&gt;w) //如果某个块的编号小于w,那么这次就不会作为后继块(sa[i]-w已经小于0了) tp[++p]=sa[i]-w; //给sa[i]-w（前驱块的编号）分配++p的排名 //上述循环顺序进行, 先遍历到的块比较小, 分配靠前的排名 //现在tp数组制作完成，开始进行排序 bucket_sort(n,m); //现在根据sa数组制作rk数组 swap(rk,tp); //tp数组已经使用完毕了(排序后就不需要上一次排序的信息了),下面我们用它来储存上一轮的rk数组 rk[sa[1]]=1; //排名为1的元素所对应的排名是1 p=1; //此处p的含义是已经分配了的排名 for (int i=2;i&lt;=n;i++) if (tp[sa[i]]==tp[sa[i-1]] &amp;&amp; tp[sa[i]+w]==tp[sa[i-1]]+w) //上述两个条件说明, 组成 sa[i]和sa[i-1],即排名为i和i-1的两个元素的两个块完全相同 rk[sa[i]]=p; else rk[sa[i]]=++p; //到此处,p表示已经分配出的排名种类数；同时也是值数组的值域,因此可以作为下一轮的m值 //p=n表示已经区分出了n种后缀,后缀排序就完成了 &#125;&#125;通过这两个函数，我们就计算出了sa和rk数组，也就实现了后缀排序。输出sa数组就可以通过这道模板题了。可能这里的注释还有一些不清楚的地方，但是暂时无法进一步完善了（哭）。如果有什么问题在评论区提吧。那么这篇文章就结束了。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sweetlemon39.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"排序","slug":"排序","permalink":"https://sweetlemon39.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://sweetlemon39.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"奇闻记录","slug":"adventure-record","date":"2019-04-09T00:00:00.000Z","updated":"2019-04-09T00:00:00.000Z","comments":true,"path":"adventure-record/","link":"","permalink":"https://sweetlemon39.github.io/adventure-record/","excerpt":"准备省选了，没想到还遇到这样的坑……开个贴记录一下神坑。","text":"准备省选了，没想到还遇到这样的坑……开个贴记录一下神坑。std::sort的比较函数要求高在重载sort的比较函数时，一定要注意，若a==b，则cmp(a,b)一定不能返回true，否则会引发段错误。因此，在写莫队的奇偶排序时，必须写(bel[lhs.l]&amp;1)?(lhs.r&lt;rhs.r):(lhs.r&gt;rhs.r)，而不能写(bel[lhs.l]&amp;1)^(lhs.r&lt;rhs.r)。upd: 这个问题在两个多月后又重现了……莫队RE多半就是这个原因了啊。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"奇闻","slug":"奇闻","permalink":"https://sweetlemon39.github.io/tags/%E5%A5%87%E9%97%BB/"}]},{"title":"离线算法","slug":"offline-algorithm","date":"2019-04-09T00:00:00.000Z","updated":"2019-04-09T00:00:00.000Z","comments":true,"path":"offline-algorithm/","link":"","permalink":"https://sweetlemon39.github.io/offline-algorithm/","excerpt":"今天花了一整天练习数据结构，尤其是基础根号算法。其中最有特色的当属离线算法。","text":"今天花了一整天练习数据结构，尤其是基础根号算法。其中最有特色的当属离线算法。在很久远的过去（大概是2017年春），无知的我在写洛谷月赛的数据结构题时，就有了离线的思想，但并没有想到太多有效的离线算法。下面总结一些常见的离线算法。莫队莫队算是一种比较通用的离线算法。普通莫队可以处理没有修改操作、能够O(1)\\mathrm{O}(1)O(1)移动区间左右端点的题目，主要思想是对询问进行分块，使得在块内左端点移动量较小、右端点单调移动，时间复杂度O(nn)\\mathrm{O}(n\\sqrt{n})O(nn​)。带修莫队增加时间维度，对左右端点都分块，支持单点的修改操作，时间复杂度O(n53)\\text{O}(n^{\\frac{5}{3}})O(n35​)。代码实现上需要注意的是std::sort的比较函数。移动某一端点在莫队的时间复杂度无法承受的时候，我们也可以考虑多记录一些信息，在使某一端点单调移动的同时，保留另一端点的所有信息。即移动端点O(1)\\mathrm{O}(1)O(1)或O(log⁡n)\\mathrm{O}(\\log n)O(logn)；对于某确定的rrr，查询某一lll的答案的时间也为O(1)\\mathrm{O}(1)O(1)或O(log⁡n)\\mathrm{O}(\\log n)O(logn)。这样就可以实现O(mlog⁡n)\\mathrm{O}(m\\log n)O(mlogn)。典型题目有询问区间不同元素数。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"离线","slug":"离线","permalink":"https://sweetlemon39.github.io/tags/%E7%A6%BB%E7%BA%BF/"}]},{"title":"组合数学中的图论笔记","slug":"graph-in-math","date":"2019-02-28T00:00:00.000Z","updated":"2019-02-28T00:00:00.000Z","comments":true,"path":"graph-in-math/","link":"","permalink":"https://sweetlemon39.github.io/graph-in-math/","excerpt":"设GGG为一个n(n≥5)n(n\\ge 5)n(n≥5)阶图，且GGG的任意n−2n-2n−2阶子图的边数为一定值3k(k∈N+)3^{k}(k\\in \\mathbb{N_{+}})3k(k∈N+​)。求nnn的所有可能取值。","text":"设GGG为一个n(n≥5)n(n\\ge 5)n(n≥5)阶图，且GGG的任意n−2n-2n−2阶子图的边数为一定值3k(k∈N+)3^{k}(k\\in \\mathbb{N_{+}})3k(k∈N+​)。求nnn的所有可能取值。解：设GGG的边数为m(m∈N+)m(m\\in \\mathbb{N_{+}})m(m∈N+​)。GGG的所有n−2n-2n−2阶子图共有Cnn−2=Cn2\\text{C}^{n-2}_{n}=\\text{C}^{2}_{n}Cnn−2​=Cn2​个，这些子图的边数之和即为Cn2×3k\\text{C}^{2}_{n}\\times 3^{k}Cn2​×3k，设这个值为 y=Cn2×3ky=\\text{C}^{2}_{n}\\times 3^{k}y=Cn2​×3k。另一方面，考虑每一条边eee，eee所在的n−2n-2n−2阶子图共有Cn−2n−4=Cn−22\\text{C}^{n-4}_{n-2}=\\text{C}^{2}_{n-2}Cn−2n−4​=Cn−22​个，因此eee被计算入答案的次数为Cn−22\\text{C}^{2}_{n-2}Cn−22​次。因此，y=m×Cn−22y=m\\times \\text{C}^{2}_{n-2}y=m×Cn−22​。于是得到Cn2×3k=m×Cn−22\\text{C}^{2}_{n}\\times 3^{k}=m\\times \\text{C}^{2}_{n-2}Cn2​×3k=m×Cn−22​，整理得m=n(n−1)3k(n−2)(n−3)∈N+m=\\frac{n(n-1)3^{k}}{(n-2)(n-3)}\\in \\mathbb{N_+}m=(n−2)(n−3)n(n−1)3k​∈N+​。若(n−2)(n−3)(n-2)(n-3)(n−2)(n−3)有质因子p(p≥5)p(p\\ge 5)p(p≥5)，则知p∣n−2p\\mid n-2p∣n−2或p∣n−3p\\mid n-3p∣n−3，从而p∤n(n−1)3kp\\nmid n(n-1)3^kp∤n(n−1)3k，得m∉N+m\\not \\in \\mathbb{N_+}m​∈N+​，矛盾。若4∣(n−2)(n−3)4\\mid(n-2)(n-3)4∣(n−2)(n−3)，则知4∣n−24\\mid n-24∣n−2或4∣n−34\\mid n-34∣n−3，从而4∤n(n−1)3k4\\nmid n(n-1)3^k4∤n(n−1)3k，得m∉N+m\\not \\in \\mathbb{N_+}m​∈N+​，矛盾。而n−2n-2n−2和n−3n-3n−3中必有一个为偶数，于是得(n−2)(n−3)=2×3t(t∈N)(n-2)(n-3)=2\\times 3^t(t\\in \\mathbb{N})(n−2)(n−3)=2×3t(t∈N)。由于gcd⁡(n−2,n−3)=1\\gcd(n-2,n-3)=1gcd(n−2,n−3)=1，得n−2=2,n−3=3tn-2=2,n-3=3^tn−2=2,n−3=3t或n−3=2,n−2=3tn-3=2,n-2=3^tn−3=2,n−2=3t。结合条件知n=5n=5n=5为唯一满足条件的nnn值。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}]},{"title":"探索爱的旅程","slug":"violet-evergarden-review","date":"2019-02-22T00:00:00.000Z","updated":"2019-02-22T00:00:00.000Z","comments":true,"path":"violet-evergarden-review/","link":"","permalink":"https://sweetlemon39.github.io/violet-evergarden-review/","excerpt":"探索爱的旅程 ——观《紫罗兰永恒花园》[1]^{\\text{[1]}}[1]有感爱一直都藏在阳光里；就算看不见，就算摸不着，也一直在那里。[2]^{\\text{[2]}}[2]——题记","text":"探索爱的旅程 ——观《紫罗兰永恒花园》[1]^{\\text{[1]}}[1]有感爱一直都藏在阳光里；就算看不见，就算摸不着，也一直在那里。[2]^{\\text{[2]}}[2]——题记爱是人类追求的永恒目标，也是文学作品、影视作品赞颂的永恒主题。《紫罗兰永恒花园》这部动画从一个崭新的角度，对爱作了诠释。影片“献给所有尚未知晓爱的人”，但谁又能完全理解“爱”呢？因此我想，对每个人，看了这部动画都会有新的收获吧。这部动画的内容，简单来说，就是军人薇尔莉特在战后治愈、救赎自己的故事[3]^{\\text{[3]}}[3]，也就是薇尔莉特的成长过程、探索爱的旅程。薇尔莉特是基尔伯特少佐在战场上“捡”到的孤儿，虽已十四岁但还不通世事，却有很强的战斗力。少佐收养了她，教她生活的基本技能。在战争中，薇尔莉特协同少佐作战，立下了赫赫战功。在最后的战斗中，他们遭遇险境，少佐牺牲自己，救了薇尔莉特。战后，少佐的遗言“你要活下去，变得自由；我真心，爱着你”让薇尔莉特开始探索“爱”的含义。她成为了一位“自动手记人偶”，帮助人以书信的形式传达自己的情感。在工作的过程中，薇尔莉特领会到了各种各样的爱，最终真正在心智上成熟了。动画出彩的地方很多。从表面看，那精心绘制的画面、充满意境的音乐就已让人沉醉；从深层看，无论是坚定的反对战争、热爱和平的主旋律，还是十分感人的单元剧情节，亦或是主人公薇尔莉特那充满魅力的形象，都让人不断思考。而我最有感触的，则是薇尔莉特感受爱的过程。在少佐说出遗言时，薇尔莉特还完全不明白“我爱你”的意思，对许多情感也完全不了解；这让我看到了自己的影子。但接下来薇尔莉特的行动，就和我完全不同了。她积极追寻“爱”的含义，为了解爱而成为了自动手记人偶，走遍城市和乡村，走遍宫廷和前线。她为患重病将离去的母亲给她幼小的女儿写了五十封寄向未来的信，为妹妹给哥哥写了让他走出战后自责阴影的信；她用文字为两国的和亲搭起了桥梁，为即将牺牲的士兵传达了对未婚妻的挚爱；她用信抚平战争带给人们心中的创伤，她用信连接人与人之间的情感；在最后，她也为自己写了第一封信。她努力寻找爱，自然也收获了爱的含义，感受了生活的美好。薇尔莉特能感受到这么丰富而激烈的爱，和她生活的环境有关，客观上也是艺术塑造的需要。而在我们生活的这个世界，其实同样充满爱。父母对自己的期盼，同学之间真诚的交流，陌生人无私的帮助，其实和动画中一样，都是爱的表现；只是可能表现得比较平淡，从而容易被我们忽略。而我们，就要在这看似平凡的日常生活中，学会发现爱，发现美。只有付出了足够的努力，才有可能得到收获；学习如此，生活亦然。我在看完一部作品后，常常陷入羡慕作品中人物的误区。短时间的羡慕是可以理解的，因为这是喜爱作品中人物的直接表现；但我终究要意识到，我是不可能完全成为作品中人物的。不过有一点值得庆幸，那就是，虽然我们生活在不同的世界，处境不同，但却能感受到相同的爱与美好。既然如此，那么何不在生活中开始努力，在学习的同时，感受身边的爱，并给他人带来爱呢？一羽之鸟，清澈啼鸣着。在无名的青空下，寻觅着自己的身影。一羽之鸟，翩翩飞走了。于无名的蓝天里，寻觅着美好的明天。[4]^{\\text{[4]}}[4]这里的鸟，也许不止指薇尔莉特吧，也指的是不断确认着自我、不断向明天前进的我们。生活也许就是一次探索爱的旅程，我们在这场旅程中，发现自身的价值，收获生活的美好，体验获得与失去，最终明白，最重要的东西究竟是什么。走吧，别停步；你就是我的路标[4]^{\\text{[4]}}[4]。 参考文献[1] 晓佳奈,京都动画. 紫罗兰永恒花园(Violet Evergarden) [Y]. 哔哩哔哩动画. 2018注：Violet Evergarden实际上即为薇尔莉特·伊芙加登，片名的翻译使用了意译，人名的翻译使用了音译。[2] 薇尔莉特·伊芙加登(实际作者：唐沢美帆). Letter (《紫罗兰永恒花园》插曲) [L]. 2018[3] 姜钧域. 关于《紫罗兰永恒花园》[EB/OL]. 2019[4] 茅原実里. 路标(《紫罗兰永恒花园》片尾曲) [L]. 2018","categories":[{"name":"穿透世界边缘的呐喊","slug":"穿透世界边缘的呐喊","permalink":"https://sweetlemon39.github.io/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/"}],"tags":[{"name":"紫罗兰永恒花园","slug":"紫罗兰永恒花园","permalink":"https://sweetlemon39.github.io/tags/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/"},{"name":"世界间评论","slug":"世界间评论","permalink":"https://sweetlemon39.github.io/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E8%AF%84%E8%AE%BA/"}]},{"title":"蒟蒻诗","slug":"juruo-poem","date":"2018-11-01T00:00:00.000Z","updated":"2018-11-01T00:00:00.000Z","comments":true,"path":"juruo-poem/","link":"","permalink":"https://sweetlemon39.github.io/juruo-poem/","excerpt":"爆零复爆零，蒟蒻当屏写。不闻键盘声，惟闻蒟叹息。","text":"爆零复爆零，蒟蒻当屏写。不闻键盘声，惟闻蒟叹息。问蒟何所思，问蒟何所忆。蒟亦无所思，蒟亦无所忆。昨夜见模拟，哆啦大点兵，试题十二卷，卷卷有神题。神题无样例，数据无范围，愿为打暴力，从此来骗分。T1 搞搜索，T2 跑循环，T3 弄枚举，T4 输随机。旦开编辑器，暮得二十行，不闻哆啦催促声，但闻评测状态响 WA WA。旦输万能头，暮至 STL，不闻哆啦催促声，但闻毕爷数据鸣啾啾。万里赴 OJ，测试度若飞。红气传金柝，蓝光照铁衣。神犇百题死，蒟蒻十年归。归来见哆啦，哆啦坐明堂。保送十二校，赏赐百千强。哆啦问所欲，蒟蒻不用上清华，愿驰千里足，送儿还机房。神犇闻蒟来，出房相扶将；大佬闻蒟来，当户理红妆；巨神闻蒟来，磨笔霍霍写 AK。开我机房门，坐我宿舍床，删我战时板，写我旧时题。当机打游戏，对书帖金牌。出门看学长，学长皆惊忙：同行十二年，不知蒟蒻能 AK。正解空间炸，暴力代码奇；程序评测跑，安能辨我是暴力？","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"蒟蒻","slug":"蒟蒻","permalink":"https://sweetlemon39.github.io/tags/%E8%92%9F%E8%92%BB/"}]},{"title":"NOIP 2018 复习大纲","slug":"noip-2018-outline","date":"2018-11-01T00:00:00.000Z","updated":"2018-11-01T00:00:00.000Z","comments":true,"path":"noip-2018-outline/","link":"","permalink":"https://sweetlemon39.github.io/noip-2018-outline/","excerpt":"算法设计基础 枚举枚举子集、枚举子集的子集，枚举排列（next_permutation），FMT。","text":"算法设计基础 枚举枚举子集、枚举子集的子集，枚举排列（next_permutation），FMT。 贪心区间选取、哈夫曼树 单调枚举二分法、倍增法（注意数组维度优化）、尺取法。 分治归并排序（逆序对） 高精（压位高精） 搜索 状态设计 状态评估 状态转移 Meet in the Middle 迭代加深 动态规划 背包问题01背包，完全背包，多重背包，分组背包 树形dp点分治 区间dp DAG上dp 数位dp 状压dp 动态规划优化单调队列优化、四边形不等式 字符串 KMP字符串匹配，求字符串周期，公共前后缀树（next） Hash用Hash匹配字符串和子串 数据结构 链表 队列单调队列 栈单调栈 ST表 哈希表unordered_set，unordered_map 并查集带权并查集 树状数组 线段树 平衡树Treap，set，map，离散化（排序离散化、Treap离散化） bitset 图论 建图虚拟点（超级源、超级汇、超级中间点）、拆点（扩展状态）、虚拟边，重新建图 拓扑排序DAG，判环 最短路差分约束 最小生成树最小生成树，最优比率生成树 SCC,BCC割顶，桥，缩点 二分图二分图判断、染色，二分图匹配 树的基本性质树的直径、重心 树上倍增LCA及以LCA为基础的统计 数学 埃筛,欧筛求φ\\varphiφ函数 gcd⁡,exgcd\\gcd,\\text{exgcd}gcd,exgcd不定方程 同余kasumi，逆元（费马小定理、exgcd\\text{exgcd}exgcd、线性递推），模合数的技巧（分母整除分母时的做法和质因数分解向量的做法） 考试技巧 数据生成Python生成序列、树、DAG、图 对拍Shell, diff","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"大纲","slug":"大纲","permalink":"https://sweetlemon39.github.io/tags/%E5%A4%A7%E7%BA%B2/"}]},{"title":"NOIP 2018 集训 Day 5","slug":"NOIP2018-day5","date":"2018-10-24T00:00:00.000Z","updated":"2018-10-24T00:00:00.000Z","comments":true,"path":"NOIP2018-day5/","link":"","permalink":"https://sweetlemon39.github.io/NOIP2018-day5/","excerpt":"这是最后一篇即时笔记了呢 数学","text":"这是最后一篇即时笔记了呢 数学 数论 数论各种神器算法线性递推逆元：i−1=(p−⌊p÷i⌋)×(p%i)−1%pi^{-1}=(p-\\lfloor p\\div i\\rfloor)\\times (p\\%i)^{-1}\\% pi−1=(p−⌊p÷i⌋)×(p%i)−1%p。以及阶乘和阶乘的逆元的递推：n!≡n×(n−1)!(modp),(n!)−1≡n−1×((n−1)!)−1n!\\equiv n\\times (n-1)! \\pmod{p},(n!)^{-1}\\equiv n^{-1} \\times ((n-1)!)^{-1}n!≡n×(n−1)!(modp),(n!)−1≡n−1×((n−1)!)−1。可以用这个方法在O(n)\\text{O}(n)O(n)预处理后，O(1)\\text{O}(1)O(1)计算组合数。线性筛这个线性筛不仅可以筛质数，还可以计算积性函数。φ,μ\\varphi,\\muφ,μ等函数都可以用这种方法计算。详见贾志鹏 线性筛。 随机数生成器可以用矩阵，也可以用等比数列求和。这里介绍一些等比数列求和的方法。现在我们要求s=∑i=0nai=1+a+a2+⋯+an(modp)s=\\sum_{i=0}^{n}a^i=1+a+a^2+\\cdots+a^n \\pmod{p}s=∑i=0n​ai=1+a+a2+⋯+an(modp)。如果ppp是质数，我们就可以利用等比数列的求和公式s=an+1−1a−1≡(an+1−1)×(a−1)−1(modp)s=\\frac{a^{n+1}-1}{a-1}\\equiv (a^{n+1}-1)\\times (a-1)^{-1} \\pmod{p}s=a−1an+1−1​≡(an+1−1)×(a−1)−1(modp)。时间复杂度O(log⁡n)\\text{O}(\\log n)O(logn)。如果ppp不是质数，则答案可以如下计算：(an+1−1)%((a−1)p)÷(a−1)(a^{n+1}-1)\\% ((a-1)p)\\div (a-1)(an+1−1)%((a−1)p)÷(a−1)。上述方法可概括如下：若c=abc=\\frac{a}{b}c=ba​是整数，那么c%p=(a%(bp))÷bc\\% p=(a\\%(bp))\\div bc%p=(a%(bp))÷b。（注意aaa不能边算边模，aaa一定要保持原样，即必须保证参与计算的b∣ab\\mid ab∣a。如果要涉及到更复杂的膜 蛤 模合数，请参见Virtual NOIP Day 2 总结。）证明如下：设c≡x(modp),a≡t(modbp)c\\equiv x \\pmod{p},a\\equiv t \\pmod{bp}c≡x(modp),a≡t(modbp)。由同余的性质得，c−x=np,a−t=bmpc-x=np,a-t=bmpc−x=np,a−t=bmp。将ccc的定义带入得：ab−x=np\\frac{a}{b}-x=npba​−x=np，知a−bx=bnpa-bx=bnpa−bx=bnp。得a=bnp+bxa=bnp+bxa=bnp+bx。又知a=bmp+ta=bmp+ta=bmp+t，带入得bnp+bx=bmp+tbnp+bx=bmp+tbnp+bx=bmp+t，即bx−t=bp(m−n)bx-t=bp(m-n)bx−t=bp(m−n)，知bx≡t(modbp)bx\\equiv t \\pmod{bp}bx≡t(modbp)。由a−t=bmpa-t=bmpa−t=bmp知bc−t=bmpbc-t=bmpbc−t=bmp，得t=b(c−mp)t=b(c-mp)t=b(c−mp)。令k=c−mpk=c-mpk=c−mp，则t=bkt=bkt=bk。带入得bx≡bk(modbp)bx\\equiv bk \\pmod{bp}bx≡bk(modbp)，约去bbb得x≡k(modp)x\\equiv k\\pmod{p}x≡k(modp)。证毕。当然还可以用分治。现在要求s=∑i=0nai=1+a+a2+⋯+an(modp)s=\\sum_{i=0}^{n}a^i=1+a+a^2+\\cdots+a^n \\pmod{p}s=∑i=0n​ai=1+a+a2+⋯+an(modp)。如果nnn是偶数，设n=2kn=2kn=2k，那么s=1+a+⋯+ak+ak+1+⋯+a2k=(1+ak)(1+⋯+ak−1)+a2ks=1+a+\\cdots+a^k+a^{k+1}+\\cdots+a^{2k}=(1+a^{k})(1+\\cdots+a^{k-1})+a^{2k}s=1+a+⋯+ak+ak+1+⋯+a2k=(1+ak)(1+⋯+ak−1)+a2k如果nnn是奇数，设n=2k+1n=2k+1n=2k+1，那么s=1+a+⋯+ak+ak+1+⋯+a2k+1=(1+ak+1)(1+⋯+ak)s=1+a+\\cdots+a^k+a^{k+1}+\\cdots+a^{2k+1}=(1+a^{k+1})(1+\\cdots+a^k)s=1+a+⋯+ak+ak+1+⋯+a2k+1=(1+ak+1)(1+⋯+ak)取边界条件k=0k=0k=0，分治即可。 解方程系数这么大，怎么办？写高精写高精是不可能的，这辈子都不会写高精的！我们考虑把方程弱化为同余方程，取一个大数~~（比如某个数）~~，最好是long long\\text{long long}long long级别的，读入时直接把系数模ppp，然后枚举解即可。 Freda城堡的密码取long long\\text{long long}long long级别的Dark♂数，预处理出F1,F2,⋯ ,F100000F_1,F_2,\\cdots,F_{100000}F1​,F2​,⋯,F100000​模这个数的余数，枚举判断即可。 随机数生成的方法最简单的方法当然是直接rand()（是否srand()都可以）。下面介绍一种生成（几乎）不可预测的随机数的方法，对于OI\\text{OI}OI赛制来说没有什么用，但是对于Codeforces\\text{Codeforces}Codeforces这种需要防hack\\text{hack}hack的赛制，就很有用了。1234void *a=new char;void *b=(void *)(NULL);int x=a-b;delete a;上述代码会生成一个随机数xxx，请注意xxx一定是888的倍数。 小凯的疑惑 遗憾考场上怎么办？数论打表找规律！千万不要像我一样蠢到手算，面前摆的可是一台高科技计算机呢，怎么能不写程序找规律呢？找找规律就发现是一次函数了w_w。证明我有时间再补吧。看一道推广题：半质数的线性组合结论是2pqr−pq−pr−qr2pqr-pq-pr-qr2pqr−pq−pr−qr。 欧拉函数（$\\varphi $函数）φ(x)=∑i=1x[i⊥x]\\varphi(x)=\\sum_{i=1}^{x}[i \\perp x]φ(x)=∑i=1x​[i⊥x]，即[1,x][1,x][1,x]中与xxx互质的数的个数。φ(ab)=φ(a)φ(b) (a⊥b)\\varphi(ab)=\\varphi(a)\\varphi(b) \\ \\text{ }(a\\perp b)φ(ab)=φ(a)φ(b) (a⊥b) 中国生育剩余定理 long long O(1)\\text{long long} \\text{ O}(1)long long O(1) 快速乘有时候我们要计算a×b%pa\\times b\\% pa×b%p，其中a,b,pa,b,pa,b,p都是long long\\text{long long}long long级别的数字，那么我们怎么办呢？有一个玄学类型，叫做long double\\text{long double}long double，它作为浮点数类型，可以保存相当大的数，误差相对不是很大。再回顾一下模的概念：x%p=a−⌊xp⌋×px\\%p=a-\\lfloor\\frac{x}{p}\\rfloor \\times px%p=a−⌊px​⌋×p。于是我们的思路就是，用long double\\text{long double}long double暂时算出积的值并除以ppp，加上一点微小的EPS\\text{EPS}EPS，转换为long long\\text{long long}long long后乘以ppp，再用long long\\text{long long}long long下积的值减去上面计算的结果，加上ppp后再模ppp即可。上面说起来比较抽象，让我们看看代码。1234567891011ll mul(ll a,ll b,ll p)&#123; ll res; a%=p; b%=p; res=(ll)((long double)(a)*b/p+EPS); res=res*p; res=a*b-res; res+=p; res%=p; return res;&#125;压行后的代码如下：1234ll mul(ll a,ll b,ll p)&#123; a%=p,b%=p; return (a*b-(ll)((long double)(a)*b/p+EPS)*p+p)%p;&#125;注意这个方法在数字较大的时候很可能不准确，如果要保险，请使用龟速乘（O(log⁡n)\\text{O}(\\log n)O(logn)）。12345678910ll mul(ll a,ll b,ll p)&#123; ll ans=0; while (b)&#123; if (b&amp;1) ans=(ans+a)%p; a=(a&lt;&lt;1)%p; b&gt;&gt;=1; &#125; return ans;&#125; 组合数学 Catalan\\text{Catalan}Catalan数可以用生成函数解（学长的方法），也可以用图形直接转化为组合数（米尔嘉的神奇方法）。Cn=(2n)!(n+1)!n!C_{n}=\\frac{(2n)!}{(n+1)!n!}Cn​=(n+1)!n!(2n)!​可以表示：有nnn个结点的不同形态的二叉树的个数含nnn对括号的合法括号序列的个数长度为nnn的入栈序列对应的合法出栈序列个数通过连接顶点而将n+2n+2n+2边的凸多边形分成三角形的方法个数根据Catalan\\text{Catalan}Catalan数公式的推导过程，可以用Cn=Cn2n−Cn+12nC_{n}=\\text{C}^{2n}_{n}-\\text{C}^{2n}_{n+1}Cn​=Cn2n​−Cn+12n​进行无除法的递推。 合法括号序列将问题分解为，按键nnn次输入一个长度为mmm的序列和长度为mmm的序列有多少个是合法括号序列。前者可以通过dp\\text{dp}dp计算，而后者就是Catalan\\text{Catalan}Catalan数，最后将这两个相乘再累加即得答案。 子集选取注意到每个元素的选取是独立的。考虑某一个元素的选取，将选取方案转化为三角形上的折线，因此答案为2nk2^{nk}2nk。 卢卡斯定理应用：愚蠢的组合数 概率论 茶壶最优策略一定是选当前剩下的最贵的壶。将壶的价格从小到大排序为a1,a2,⋯ ,a2na_1,a_2,\\cdots,a_{2n}a1​,a2​,⋯,a2n​。那么第iii个壶被选中的概率是pi=i−12n−1p_i=\\frac{i-1}{2n-1}pi​=2n−1i−1​，于是总期望E=∑i=12npiai\\text{E}=\\sum_{i=1}^{2n}p_{i}a_{i}E=∑i=12n​pi​ai​。 NOIP 2018\\text{NOIP }2018NOIP 2018初赛T8\\text{T8}T8结论：在[0,1][0,1][0,1]内找nnn个数，其中最大数的期望是nn+1\\frac{n}{n+1}n+1n​，最小数的期望是1n+1\\frac{1}{n+1}n+11​。 期望独立事件：若P(AB)=P(A)P(B)\\text{P}(AB)=\\text{P}(A)\\text{P}(B)P(AB)=P(A)P(B)，则AAA和BBB是独立的。期望的性质：线性性：Ex(aX+bY)=aEx(X)+bEx(Y)\\text{Ex}(aX+bY)=a\\text{Ex}(X)+b\\text{Ex}(Y)Ex(aX+bY)=aEx(X)+bEx(Y)独立随机变量的期望：若X,YX,YX,Y独立，则Ex(XY)=Ex(X)Ex(Y)\\text{Ex}(XY)=\\text{Ex}(X)\\text{Ex}(Y)Ex(XY)=Ex(X)Ex(Y)条件概率。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"NOIP 2018 集训 Day 4","slug":"NOIP2018-day4","date":"2018-10-23T00:00:00.000Z","updated":"2018-10-23T00:00:00.000Z","comments":true,"path":"NOIP2018-day4/","link":"","permalink":"https://sweetlemon39.github.io/NOIP2018-day4/","excerpt":"动态规划","text":"动态规划 动态规划基础 动态规划问题的特征子问题重复最优子结构，无后效性（可以通过扩充状态满足这个特征） LIS\\text{LIS}LIS关于导弹拦截的介绍在这篇笔记里已经有了。神级技巧！注意lower_bound(begin,end,x)和upper_bound(begin,end,x)返回的都是迭代器！这么好的东西，我们怎么能不利用？可以用*lower_bound(begin,end,x)=x将数组中第一个大于等于xxx的数直接更改为xxx。 LCS\\text{LCS}LCS此处LCS\\text{LCS}LCS指的是最长公共子序列(Longest Common Subsequence)。如果是两个字符串的LCS\\text{LCS}LCS，那么只能通过暴力的O(n2) dp\\text{O}(n^{2})\\text{ dp}O(n2) dp解决。如果是两个排列的LCS\\text{LCS}LCS，可以转化为LIS\\text{LIS}LIS从而在O(nlog⁡n)\\text{O}(n\\log n)O(nlogn)的复杂度内解决。考虑第二个序列中的每个数bib_{i}bi​，建立一个新序列ccc，ci=pos(bi)=lower_bound(a,a+n,bi)−ac_{i} = \\text{pos} (b_{i})=\\text{lower}\\_\\text{bound}( a , a+n , b_{i} ) - aci​=pos(bi​)=lower_bound(a,a+n,bi​)−a，则序列ccc的一个上升子序列ci1,ci2,⋯ ,cimc_{i_1},c_{i_2},\\cdots ,c_{i_m}ci1​​,ci2​​,⋯,cim​​就代表aci1a_{c_{i_1}}aci1​​​对应bi1b_{i_1}bi1​​等，是一种公共子序列的对应。那么LIS\\text{LIS}LIS就代表着LCS\\text{LCS}LCS。如果对序列的限制改成：每个字符的出现次数为O(1)\\text{O}(1)O(1)，又怎么解呢？方法是：把一个字符拆成若干个字符来解！对于某一个字符，如果它在第一个序列中出现多次，就把它拆分为多次出现位置的倒序。如序列a=(1,2,3,1,3,2,4)a=(1,2,3,1,3,2,4)a=(1,2,3,1,3,2,4)，序列b=(2,1,1,2,3,1,2)b=(2,1,1,2,3,1,2)b=(2,1,1,2,3,1,2)，则可以把序列bbb拆为c=(6,2, 4,1, 4,1, 6,2, 5,3, 4,1, 6,2)c=(6,2,\\text{ }4,1,\\text{ }4,1,\\text{ }6,2,\\text{ }5,3,\\text{ }4,1,\\text{ }6,2)c=(6,2, 4,1, 4,1, 6,2, 5,3, 4,1, 6,2)，如222在aaa中出现的位置为2,62,62,6，就拆成6,26,26,2。这样做的好处是，如果有ccc中的一个上升子序列，那么它同样对应着一个公共子序列；倒序保证bbb中的同一个位置的数字不会对应aaa中的多个数字，“上升”（而非“不降”）保证aaa中的同一个位置的数字不会对应bbb中的多个数字。 公共子序列我也不记得怎么解了？ 树形dp\\text{dp}dp 聪聪可可对于每一条路径，在它的起点和终点的LCA\\text{LCA}LCA处统计数量。定义f[i][j](i∈[1,n],j∈{0,1,2})f[i][j](i\\in [1,n],j\\in \\{0,1,2\\})f[i][j](i∈[1,n],j∈{0,1,2})表示以iii为根的子树中，到iii的距离dis\\text{dis}dis同余于jjj的点的个数。在dfs\\text{dfs}dfs到某一个点时，初始化f[x][0]=1,f[x][1]=f[x][2]=0f[x][0]=1,f[x][1]=f[x][2]=0f[x][0]=1,f[x][1]=f[x][2]=0。每搜完一个子节点，就给答案累加上f[ch][0]×f[x][0]+f[ch][1]×f[x][2]+f[ch][2]×f[x][1]f[\\text{ch}][0]\\times f[x][0]+f[\\text{ch}][1]\\times f[x][2]+f[\\text{ch}][2]\\times f[x][1]f[ch][0]×f[x][0]+f[ch][1]×f[x][2]+f[ch][2]×f[x][1]，再把f[ch]f[\\text{ch}]f[ch]的结果累加到f[x]f[x]f[x]上（加的顺序要注意，防止重复计数）。 Tree点分治。具体做法考虑中。 Black Nodes in Subgraphs中文题面见这里。到Vjudge提交首先考虑预处理一些信息。先证明一个性质：对于每一个sss，如果可行的最小bbb为b1b_1b1​，可行的最大bbb为b2b_2b2​，那么对于任意k∈N,k∈[b1,b2]k\\in \\mathbb{N},k\\in [b_1,b_2]k∈N,k∈[b1​,b2​]，(s,k)(s,k)(s,k)都是可行的。证明方法：若b1=b2b_1=b_2b1​=b2​，显然成立。否则从最大解中删除一个黑点，在周围寻找一个白点，如果寻找不到，就寻找一个黑点。重复上述过程，不可能一直找不到白点，因为一棵树是连通的，又有b1&lt;b2b_1&lt;b_2b1​&lt;b2​，因此只要向最小解方向靠拢，就可以找到白点。找到白点后用白点替换删除了的黑点，解的大小即减小111。由于解可以不断地减小直到达到最小答案，因此证明完毕。证明了这个结论，我们也就只需求出，对于每一个sss，可行的bbb的最大值和最小值分别是多少。而最大值和最小值是对称的，即最大值是黑点最多，最小值是白点最多。因此我们只需要考虑最大值的做法即可。定义r[i]r[i]r[i]为iii个点的连通块中黑点的最大数目，定义f[i][j]f[i][j]f[i][j]为在以iii为根的子树中，包含iii的共有jjj个点的连通块中黑点的最大数目。r[j]=max⁡(f[x][j])r[j]=\\max(f[x][j])r[j]=max(f[x][j])。对树进行dfs\\text{dfs}dfs，对于某一棵子树的根节点xxx，先初始化f[x][1]=color[x],size(x)=1f[x][1]=\\text{color[x]},\\text{size}(x)=1f[x][1]=color[x],size(x)=1。接着对子节点iii进行搜索dfs(i,x)，得到f[i][j]的所有结果（1≤j≤size(i)1\\le j\\le \\text{size}(i)1≤j≤size(i)）。为什么连通块强制包含iii呢？因为有了根节点，才能保证是连通的呀。接着做一遍背包：123456for (int i=1;i&lt;=size[x];i++) //在加入这棵子树前的图中选i个点，一定选根 for (int j=0;j&lt;=size[child];j++) //在子树中选j个点 tempmax[i+j]=max(tempmax[i+j],f[x][i]+f[child][j]); //背包size[x]+=size[child]; //将子树大小累加for (int i=1;i&lt;=size[x];i++) f[x][i]=tempmax[i]; //将tempmax数组中的数据转移回f数组上述代码中使用tempmax数组的目的是在记录答案的同时不改变f数组中的数据。遍历完xxx的所有子节点后，我们把f[x][j]f[x][j]f[x][j]的答案更新到r[j]r[j]r[j]中。最小值同理，再做一遍即可。 背包 Median Sum这是ta\\text{ta}ta出的测试题，不算太难。使用大神器bitset\\text{bitset}bitset。开一个比总和大的bitset\\text{bitset}bitset，初始化bs[0]=1\\text{bs}[0]=1bs[0]=1，对于每一个数，将bs∣=bs&lt;&lt;a[i]\\text{bs}\\mid =\\text{bs}&lt;&lt;a[i]bs∣=bs&lt;&lt;a[i]，意为从前可行的每一个和，加上a[i]a[i]a[i]也是可行的。计算结果时从sum2\\frac{\\text{sum}}{2}2sum​开始往上找即可。 简单困难题bzoj\\text{bzoj}bzoj权限题，kule。继续动用大神器。由于是异或，因此同一个和出现两次和没有出现是一样的，出现奇数次相当于出现111次。因此只需保存每一个和出现次数mod 2\\mod{2}mod2的值。初始化和处理过程和上题相同，最后计算答案时扫描bitset\\text{bitset}bitset，把为111的索引的值异或起来即得答案。 No Need题意：对于集合AAA中的某一个数xxx，若∃B⊂A,x∉B,∑y∈By&lt;k\\exists B \\subset A, x \\not \\in B,\\sum_{y\\in B}y&lt;k∃B⊂A,x​∈B,∑y∈B​y&lt;k，且∑y∈B∪{x}≥k\\sum_{y\\in B\\cup \\left \\{ x \\right \\}}\\ge k∑y∈B∪{x}​≥k，则称xxx是必要的。求集合中不必要的数的个数。注意到∅⊂A\\varnothing \\subset A∅⊂A，而对于x≥kx\\ge kx≥k，令B=∅B=\\varnothingB=∅，则∑y∈By=0&lt;k,∑y∈B∪{x}=x≥k\\sum_{y\\in B}y=0&lt;k, \\sum_{y\\in B\\cup \\left \\{ x \\right \\}}=x\\ge k∑y∈B​y=0&lt;k,∑y∈B∪{x}​=x≥k，知xxx是必要的。因此，不必要的数必小于kkk。我们还可以证明单调性：若a≤ba\\le ba≤b，且aaa是必要的，那么bbb也是必要的。证明是，由于aaa是必要的，知存在满足上述条件的集合BBB。若b∉Bb\\not \\in Bb​∈B，则∑y∈B∪{b}≥∑y∈B∪{a}≥k\\sum_{y\\in B\\cup \\left \\{ b \\right \\}}\\ge \\sum_{y\\in B\\cup \\left \\{ a \\right \\}} \\ge k∑y∈B∪{b}​≥∑y∈B∪{a}​≥k。若b∈Bb \\in Bb∈B，则将BBB中的bbb换成aaa得到集合CCC，由a≤ba\\le ba≤b知∑y∈Cy≤∑y∈By&lt;k\\sum_{y\\in C}y\\le \\sum_{y\\in B}y&lt;k∑y∈C​y≤∑y∈B​y&lt;k，知CCC满足题设条件。而∑y∈C∪{b}=∑y∈B∪{a}≥k\\sum_{y\\in C\\cup \\left \\{ b \\right \\}}= \\sum_{y\\in B\\cup \\left \\{ a \\right \\}} \\ge k∑y∈C∪{b}​=∑y∈B∪{a}​≥k，证毕。有了上下界和单调性，我们就可以进行二分了。注意，下面这段代码的真实时间复杂度是O(n2log⁡n)\\text{O}(n^2 \\log n)O(n2logn)，因为bitset\\text{bitset}bitset的移位操作在复杂度上是O(n)\\text{O}(n)O(n)的，只是常数很小而已。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#define MAXN 5005#define MAXBS 5005using namespace std;bitset&lt;MAXBS&gt; bs;int a[MAXN];int main(void)&#123; int n,k; int ll,rr; scanf(\"%d%d\",&amp;n,&amp;k); for (int i=0;i&lt;n;i++)&#123; scanf(\"%d\",a+i); &#125; sort(a,a+n); n=lower_bound(a,a+n,k)-a; //(ll,rr] ll=-1,rr=n; while (rr-ll&gt;1)&#123; int mid=(ll+rr+1)&gt;&gt;1; int necessary=0; bs.reset(); // bs=0 bs.set(0); // bs[0]=1; for (int i=0;i&lt;n;i++) if (i!=mid) bs|=(bs&lt;&lt;a[i]); bs&gt;&gt;=(k-a[mid]); for (int i=0;i&lt;a[mid];i++)&#123; if (bs.test(i))&#123; necessary=1; break; &#125; &#125; if (necessary) rr=mid; else ll=mid; &#125; printf(\"%d\\n\",ll+1); return 0;&#125;当然，除了二分，我们还有O(n2)\\text{O}(n^2)O(n2)的更优的解法。二分法为什么慢呢？因为对于每一个mid\\text{mid}mid，我们都要计算一遍除了amida_{\\text{mid}}amid​以外的元素的组合能达到的数值。下面的方法可以避免重复计算。我们还需要一个结论。设s=∑i=1kais=\\sum_{i=1}^{k}a_{i}s=∑i=1k​ai​，如果∃B⊂A,{a1,a2,⋯ ,ak}∩B=∅,∑y∈By&lt;k\\exists B \\subset A, \\left\\{ a_{1},a_{2},\\cdots,a_{k} \\right \\} \\cap B =\\varnothing, \\sum_{y\\in B}y&lt;k∃B⊂A,{a1​,a2​,⋯,ak​}∩B=∅,∑y∈B​y&lt;k，且s+∑y∈B≥ks+\\sum_{y\\in B}\\ge ks+∑y∈B​≥k，那么aka_{k}ak​是必要的。证明：假设aka_kak​不是必要的，那么根据单调性，a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​都不是必要的。根据题目条件，将a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​按顺序加入到BBB中，则必存在1≤j≤k1\\le j\\le k1≤j≤k，使加入a1,a2,⋯ ,ak−1a_1,a_2,\\cdots,a_{k-1}a1​,a2​,⋯,ak−1​时，和小于kkk；加入aja_jaj​时，和大于等于kkk。因此aja_jaj​是必要的，与上述假设矛盾。故假设不成立，aka_{k}ak​是必要的。于是，我们可以根据ak+1,ak+2,⋯ ,ana_{k+1},a_{k+2},\\cdots,a_{n}ak+1​,ak+2​,⋯,an​的组合能达到的范围来确定aka_kak​的必要性，这样就避免了bitset\\text{bitset}bitset的重复计算，时间复杂度降到O(n2)\\text{O}(n^2)O(n2)。 数位dp\\text{dp}dp Counting Digits / 梦中的统计 / 数字计数先计算1≤m&lt;n1\\le m &lt;n1≤m&lt;n的整数中出现数字xxx出现的次数。依次考虑每一位，考虑个位时令t=1t=1t=1，考虑十位时令t=10t=10t=10，考虑百位时令t=100t=100t=100……那么在T=10tT=10tT=10t的一个完整周期内，这一位上数字xxx共出现了ttt次。考虑不完整的那一个周期，如果这一位上的数⌊nt⌋%10&gt;x\\lfloor\\frac{n}{t}\\rfloor \\% 10 &gt; x⌊tn​⌋%10&gt;x，那么出现了完整的ttt次；如果⌊nt⌋%10=x\\lfloor\\frac{n}{t}\\rfloor \\% 10 = x⌊tn​⌋%10=x，那么出现了n%tn \\% tn%t次；如果⌊nt⌋%10&lt;x\\lfloor\\frac{n}{t}\\rfloor \\% 10 &lt; x⌊tn​⌋%10&lt;x，那么没有出现。对于Counting Digits，暴力对每个数求解即可。优化是如果一个xxx不是解，且函数值为yyy，那么只比xxx大一点的数也不会是解，因此xxx可以增加一个大一点的数。另外，Counting Digits可以到这里提交。对于梦中的统计，求出端点相减即可。“数字计数”是只有一组数据的版本。双倍经验 状态压缩 Sphere Packing相当于求哈密顿路。状压。 状态转移的必备技巧（又名FMT\\text{FMT}FMT,Fans MeeTing Fast Mobius Transform）已知数组a[0...2k−1]a[0...2^k-1]a[0...2k−1]。设b[i]=∑j&amp;i=ja[j]b[i]=\\sum_{j\\&amp; i=j}a[j]b[i]=∑j&amp;i=j​a[j]（可以认为是AAA的所有子集的权值之和）。请在O(k2k)\\text{O}(k2^{k})O(k2k)的时间内求出bbb数组的值。暴力法：对每一个i∈[0...2k−1]i\\in [0...2^k-1]i∈[0...2k−1]，枚举j∈[0...2k−1]j\\in [0...2^k-1]j∈[0...2k−1]，如果满足条件，则求和。O(4k)\\text{O}(4^k)O(4k)。子集枚举法：对每一个集合AAA，枚举AAA的所有子集，进行求和。如何枚举子集？123456int i; //枚举A(表示为i)的子集for (int j=i;;j=(j-1)&amp;i)&#123; //进行操作 if (!j) break;&#125;时间复杂度O(3k)\\text{O}(3^{k})O(3k)。正解：进行递推。12345678int len=1&lt;&lt;k;for (int i=0;i&lt;k;i++)&#123; int tpow=1&lt;&lt;i; for (int j=0;j&lt;len;j++)&#123; if (j&amp;tpow) f[j]+=f[j^tpow]; &#125;&#125;如何理解上面这段代码呢？请看拙作第二题补充：请注意FMT\\text{FMT}FMT的应用范围！参考洛谷111111月月赛 咕咕咕。Upd: 这个东西又叫做 SoS (Sum over Subsets) dp。 Or Plus Max转化：i∣j≤ki\\mid j\\le ki∣j≤k这个条件很难利用，我们可以求一个数组f[k]=max⁡(Ai+Aj) (i∣j=k)f[k]=\\max(A_i+A_j)\\ \\ (i\\mid j=k)f[k]=max(Ai​+Aj​) (i∣j=k)，求f[k]f[k]f[k]的前缀最大值g[k]=max⁡(f[i]) (i≤k)g[k]=\\max(f[i])\\ \\ (i\\le k)g[k]=max(f[i]) (i≤k)，则g[k]g[k]g[k]即为答案数组。这么计算同样有难度。我们再进行一次转化：令h[k]=max⁡(Ai+Aj)(i⊆k,j⊆j,i≠j)h[k]=\\max(A_i+A_j)(i\\subseteq k,j\\subseteq j,i\\neq j)h[k]=max(Ai​+Aj​)(i⊆k,j⊆j,i​=j)，则我们直接用FMT\\text{FMT}FMT求出kkk的子集中AAA的最大值和次大值即可。 期望dp\\text{dp}dp 分手是住院祝愿首先考虑最优策略。假设当前亮着的编号最大的灯是xxx，则关掉它的最优策略是按下开关xxx把它关上，同时xxx的因数的灯的状态会改变。我们接着寻找下一个亮着的灯，继续如此操作。现在我们就能算出，如果一直按照最优策略，需要操作的次数。这样就能拿到k=nk=nk=n的505050分了。现在我们考虑随机情况。设状态kkk为“此时按照最优策略，还需操作kkk次”，f[k]f[k]f[k]表示从状态kkk转移到状态k−1k-1k−1所需操作次数的期望。在状态kkk，如果我们按了正确的开关（即kkk个正确开关中的一个），那么状态就转移成了k−1k-1k−1；如果我们按了其余的n−kn-kn−k个错误的开关，我们就必须再按一次这个错误的开关，因此状态被转移到了k+1k+1k+1。而状态k+1k+1k+1要转移到状态k−1k-1k−1，首先必须回到状态kkk。于是得到f[k]=kn×1+n−kn×(1+f[k+1]+f[k])f[k]=\\frac{k}{n}\\times 1+\\frac{n-k}{n}\\times (1+f[k+1]+f[k])f[k]=nk​×1+nn−k​×(1+f[k+1]+f[k])。由此式知f[n]=1,f[k]=(n−k)f[k+1]+nkf[n]=1,f[k]=\\frac{(n-k)f[k+1]+n}{k}f[n]=1,f[k]=k(n−k)f[k+1]+n​。可以从f[n]f[n]f[n]开始，递推得到所有fff的值。因此若设最优策略的步数为ttt，则答案即为∑i=k+1tf[i]+∑i=1k1\\sum^{t}_{i=k+1}f[i]+\\sum^{k}_{i=1}1i=k+1∑t​f[i]+i=1∑k​1有分数怎么办？最后不是求得不就是ans×n! %100003\\text{ans}\\times n! \\text{ }\\% 100003ans×n! %100003的值嘛，因此计算过程中遇到除法就换成乘以逆元就好了。 WJMZBMR打osu! / Easy期望有些很神奇的性质！期望的线性性质 Ex(k1X+k2Y)=k1Ex(X)+k2Ex(Y)\\text{Ex}(k_1X+k_2Y)=k_1\\text{Ex}(X)+k_2\\text{Ex}(Y)Ex(k1​X+k2​Y)=k1​Ex(X)+k2​Ex(Y) （见维基百科 Expected value）因此，期望可以乱加（逃）。只要是线性的，我们就方便处理。考虑一段连续的o，第kkk个位置和第k+1k+1k+1个位置的得分满足(k+1)2−k2=2k+1(k+1)^2-k^2=2k+1(k+1)2−k2=2k+1是线性的，可以处理。因此我们得出，如果一个位置是o，那么这个位置的得分的期望可以由上一个位置的得分期望计算出。设f[i]f[i]f[i]表示到第iii步为止得分的期望，g[i]g[i]g[i]表示在第iii步末尾连续o的个数的期望。设u[i]=f[i]−f[i−1]u[i]=f[i]-f[i-1]u[i]=f[i]−f[i−1]。现在对第iii步的状况进行讨论。如果第iii步是x，那么u[i]=0,g[i]=0u[i]=0,g[i]=0u[i]=0,g[i]=0。如果第iii步是o，那么根据上面的讨论，u[i]=2g[i−1]+1,g[i]=g[i−1]+1u[i]=2g[i-1]+1,g[i]=g[i-1]+1u[i]=2g[i−1]+1,g[i]=g[i−1]+1。如果第iii步是?，那么u[i]=(0+2g[i−1]+1)÷2=g[i−1]+0.5,g[i]=g[i−1]+0.5u[i]=(0+2g[i-1]+1)\\div 2=g[i-1]+0.5,g[i]=g[i-1]+0.5u[i]=(0+2g[i−1]+1)÷2=g[i−1]+0.5,g[i]=g[i−1]+0.5。于是只需要再使用f[i]=f[i−1]+u[i]f[i]=f[i-1]+u[i]f[i]=f[i−1]+u[i]计算即可。可以使用滚动数组节省空间。最后的答案即为f[n]f[n]f[n]。 按位或这是篇好博客，如果看不懂我自己写的就看这里的吧。暴力法设f[i]f[i]f[i]表示从数iii到2n−12^n-12n−1所需操作次数的期望，则f[2n−1]=0f[2^n-1]=0f[2n−1]=0，f[x]=1+∑i=02n−1f[x∣i]×p[i]f[x]=1+\\sum_{i=0}^{2^{n}-1}f[x \\mid i]\\times p[i]f[x]=1+∑i=02n−1​f[x∣i]×p[i]。于是最暴力的方法就有了：对于每一个xxx，枚举i⊈xi\\not\\subseteq xi​⊆x，将p[i]×f[x∣i]p[i]\\times f[x\\mid i]p[i]×f[x∣i]进行累加后加上111，再除以f[x]f[x]f[x]项的系数1−∑i⊆xp[i]1-\\sum_{i\\subseteq x}p[i]1−∑i⊆x​p[i]，即得f[x]f[x]f[x]。最后输出f[0]f[0]f[0]。正解看题解吧…… 歌唱王国利用KMP\\text{KMP}KMP的next\\text{next}next数组。 奇妙的解法 阿狸和桃子的游戏如果只有点权，就很简单了。加上边权了如何呢？把边权平分到两个端点上，如果这条边被两个人分别选择，那么差值为000；否则这两半会累加成一个完整的边权。tql 星之器我们可以发现，无论操作方法如何，从初状态转移到末状态释放的能量是相等的。考虑物理中势能的概念，我们定义一个点(x,y)(x,y)(x,y)的单位势能为Es=x2+y22E_{s}=\\frac{x^2+y^2}{2}Es​=2x2+y2​，一个点的势能为Ep=cnt(star)EsE_{p}=\\text{cnt}(\\text{star})E_sEp​=cnt(star)Es​，即星星数目乘以单位势能。定义一个状态的势能为所有点的势能之和。那么从初状态到末状态的能量释放数即为势能差。 Friends答案就是32n32^n32n。可以使用long double\\text{long double}long double直接输出。这个答案可以从样例推得。因为每一种语言都是独立的，设语言种数为nnn，则答案一定是ana^{n}an。代入样例知a=32a=32a=32。 一道防AK好题从结束标志0,0,00,0,00,0,0倒推。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sweetlemon39.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"NOIP 2018 集训 Day 3","slug":"NOIP2018-day3","date":"2018-10-22T00:00:00.000Z","updated":"2018-10-22T00:00:00.000Z","comments":true,"path":"NOIP2018-day3/","link":"","permalink":"https://sweetlemon39.github.io/NOIP2018-day3/","excerpt":"图论","text":"图论 图的存储邻接矩阵（O(n2)\\text{O}(n^{2})O(n2)）邻接表（时间复杂度O(n+m)\\text{O}(n+m)O(n+m)，空间复杂度O(n2)\\text{O}(n^{2})O(n2)）邻接链表（O(n+m)\\text{O}(n+m)O(n+m)） 图的遍历 bfs\\text{bfs}bfs计算无权图或树上最短路、求连通块比较实用。输出路径可以用dis\\text{dis}dis乱搞，也可以在松弛的时候记录路径上的上一个点（也可以叫做最短路径树上的父节点）。输出字典序最小的路径，可以在反图上进行搜索，再根据字典序倒推路径的上一个点。printf\\text{printf}printf输出技巧 printf(&quot;%5d&quot;,x);右对齐占555格，printf(&quot;%-5d&quot;,x);左对齐占555格。 障碍路线状态包含位置和朝向。巧妙地设计转移坐标数组turnx[]={0,1,0,-1};turny[]={1,0,-1,0};，使向右转恰好是+1(mod4)+1 \\pmod{4}+1(mod4)，左转恰好是−1(mod4)-1 \\pmod{4}−1(mod4)。为了使用bfs\\text{bfs}bfs，要一次性将所有下一个转弯的位置加入队列中，搜到终点直接返回即可。防止重复的要点：强制至少走一步，不允许原地转弯。 最优贸易强连通分量缩点+DAG\\sout{\\text{DAG}}DAG上dp\\sout{\\text{dp}}dp​纯bfs\\text{bfs}bfs！厉害吧。注意到价格很小，考虑到按价格拆点。先去除所有不能到达nnn的点，可以在反图上bfs\\text{bfs}bfs或dfs\\text{dfs}dfs。f[i][j]\\text{f}[i][j]f[i][j]表示到达iii时所经过的点的最低价为jjj能否实现。从起点开始进行bfs\\text{bfs}bfs，对于遍历到的每个可能状态f[i][j]\\text{f}[i][j]f[i][j]，用price[i]−j\\text{price}[i]-jprice[i]−j更新答案。如果发现了一个新的可能状态，就把它入队。 关押罪犯对答案二分，用bfs\\text{bfs}bfs或dfs\\text{dfs}dfs染色，自动过滤掉边权不大于答案的边。O((n+m)log⁡c)\\text{O}((n+m)\\log c)O((n+m)logc)。 DAG\\text{DAG}DAG 车站分级直接拓扑排序边会过多，要添加虚拟的中间点，两个级别的车站连边时，上一级别的车站统一向虚拟点连边，再由虚拟点连向下一级别的车站。这么做的原因是，题目给出的是∀(x,y)∈A×B,x&lt;y\\forall (x,y) \\in A \\times B,x&lt;y∀(x,y)∈A×B,x&lt;y这样的关系。回忆我们解数学题时处理这样的条件的过程：∀x1∈[a,b],∀x2∈[c,d],f(x1)&gt;g(x2)\\forall x_{1}\\in [a,b],\\forall x_{2}\\in [c,d],f(x_1)&gt;g(x_2)∀x1​∈[a,b],∀x2​∈[c,d],f(x1​)&gt;g(x2​)。我们可以把它转化为f(x)f(x)f(x)在[a,b][a,b][a,b]内的最小值大于g(x)g(x)g(x)在[c,d][c,d][c,d]内的最大值。进行知识迁移，我们把信息转化为min⁡(A)&gt;max⁡(B)\\min(A)&gt;\\max(B)min(A)&gt;max(B)。我们不妨设虚拟点的分级为min⁡(A)+max⁡(B)2\\frac{\\min(A)+\\max(B)}{2}2min(A)+max(B)​，则信息转化为，上一级别的所有车站的分级大于虚拟点的分级，下一级别所有车站的分级小于虚拟点的分级，这样这道题的难点就解决了。 最短路 SPFA\\text{SPFA}SPFA优化被称为SLF(Small label first)\\text{SLF(Small label first)}SLF(Small label first)策略。若当前入队的顶点的dis\\text{dis}dis比队头的dis\\text{dis}dis小，就将这个点从队头插入；否则插入队尾。在随机图上表现得不错，但是在恶意构造出的数据上会表现出O(2n)\\text{O}(2^n)O(2n)的复杂度~~，死得更惨~~。 道路重建考虑把已经有公路连接的点缩成同一个点，重新建图跑最短路即可。其实不需要重新建图，把完好的公路的权值改为000即可。 INGRED最暴力的方法是先用Floyd\\text{Floyd}Floyd计算出任意两点间的最短路，再枚举两个人访问的特殊点，再枚举访问的顺序，更新答案即可。比较好的方法是利用特殊点比较少的性质，从每个起点开始跑最短路。把每一个点的状态信息扩充，即把已经访问的特殊点记入点本身，或者说是“拆点”，把每一个点拆成2s2^s2s个，点(x,status)(x,\\text{status})(x,status)表示到点xxx且状态为status\\text{status}status的最短路。最后枚举两个人分别走过的特殊点，直接计算答案即可。这样之所以能带来速度提升，是因为它把前面暴力方法中连续枚举（即复杂度相乘）的访问顺序变成了分开枚举（复杂度相加）。计算特殊的最短路时，拆点时很重要的技巧。如飞行路线。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"搜索 总结","slug":"search","date":"2018-10-22T00:00:00.000Z","updated":"2018-10-22T00:00:00.000Z","comments":true,"path":"search/","link":"","permalink":"https://sweetlemon39.github.io/search/","excerpt":"搜索的内容一个搜索分为两部分，状态评估和状态转移。","text":"搜索的内容一个搜索分为两部分，状态评估和状态转移。状态评估是对某一（当前或未来）状态的状况判断，如是否合法、是否有解、是否已访问过、优越性如何；状态转移是从当前状态转移到另一个状态继续搜索。状态评估和状态转移是交叉进行的，互相辅助，状态评估时要为状态转移提供依据，状态转移时要维护状态评估的信息。 搜索的加速要为搜索加速，就要对状态评估进行分类。状态的评估可以分为可行性评估和最优性评估两类，例如判断状态是否合法属于可行性评估，而判断状态的优越性属于最优性评估。利用状态评估给搜索加速主要分为两类。一是根据状态评估的结果停止状态转移，即回溯，这种方法我们一般称为剪枝。二是根据状态评估的结果调整状态转移的顺序。我们可以让乐观估计更优的状态优先转移，从而让最优解尽早地被搜到；如果我们需要搜索的是一个顺序，那么可以让更容易失败的先枚举，如小木棍一题中按从大到小的顺序选择木棍。还要注意避免搜索状态的重复，例如愤怒的小鸟一题中强制抛物线经过当前剩下的编号最小的猪，可以避免同一个状态被多次枚举。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://sweetlemon39.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}]},{"title":"NOIP 2018 集训 Day 2","slug":"NOIP2018-day2","date":"2018-10-21T00:00:00.000Z","updated":"2018-10-21T00:00:00.000Z","comments":true,"path":"NOIP2018-day2/","link":"","permalink":"https://sweetlemon39.github.io/NOIP2018-day2/","excerpt":"冰茶姬","text":"冰茶姬 无线通讯网二分DDD，对于每一个DDD，将两个距离不超过DDD的点连边，连边后检查连通块的个数是否不大于SSS（必须两边都有卫星电话才能通话），当只有一个连通块时不需要卫星电话。O(n2log⁡x)\\text{O}(n^2 \\log x)O(n2logx)。对边排序，找到位于最小生成树上的第P−SP-SP−S条边（仍然注意只有一个连通块时不需要卫星电话），它的长度即为DDD的最小值。O(n2log⁡n)\\text{O}(n^2\\log n)O(n2logn)。 穿越走廊二分球体直径。对障碍物（包括圆和上下墙壁）进行两两的枚举，如果这两个障碍物之间的最小距离（两圆间距离/球与墙壁距离/两墙壁间距离）小于球的直径，就在这两个障碍物之间连边。如果最后上、下墙壁是连通的（可以视为有一堵贯穿上下墙壁的墙），就不可行；否则可行。连边方法同上。把边按从小到大排序，依次加入图中，则球体的最大直径就是恰使上下墙壁连通的那一条边的长度lll减去111（l−1l-1l−1）。 货车运输本蒟蒻的极度暴力方法：直接O(n3)\\text{O}(n^3)O(n3)跑Floyd\\text{Floyd}Floyd。303030分方法：二分限重，判断是否连通。O(qmlog⁡z)\\text{O}(qm\\log z)O(qmlogz)。对边排序，从大到小将边加入图中，直到起点和终点连通为止。O(mlog⁡m+qm)\\text{O}(m\\log m+qm)O(mlogm+qm)。 带权冰茶姬 关押罪犯对答案进行二分，对某个答案xxx，对所有怨气值大于xxx的罪犯连边，如果最后得到的图是二分图，则xxx可行。O((n+m)log⁡c)\\text{O}((n+m)\\log c)O((n+m)logc)对边排序，从大到小按上述方法连边，直到图不是二分图时，加入的最后一条边的权值即为答案。O(mlog⁡m)\\text{O}(m\\log m)O(mlogm)（带权）冰茶姬判二分图。 搜索 逛公园101010分：先Dijkstra\\text{Dijkstra}Dijkstra计算最短路长度，再dfs\\text{dfs}dfs枚举简单路径（无剪枝）。202020分：先Dijkstra\\text{Dijkstra}Dijkstra计算最短路长度，再dfs\\text{dfs}dfs枚举简单路径（当前已走路径长超过dis(1,n)+k\\text{dis}(1,n)+kdis(1,n)+k时剪枝）。303030分：先Dijkstra\\text{Dijkstra}Dijkstra计算每个点到111和nnn的距离，再dfs\\text{dfs}dfs枚举简单路径（dis(1,u)+w+dis(v,n)\\text{dis}(1,u)+w+\\text{dis}(v,n)dis(1,u)+w+dis(v,n)超过dis(1,n)+k\\text{dis}(1,n)+kdis(1,n)+k时剪枝）。其实只能过k=0k=0k=0的点。注意到有333个点k=0k=0k=0。先Dijkstra\\text{Dijkstra}Dijkstra计算最短路长度，再做一遍最短路计数。判断每个点是否在最短路上，重新建图，插入在最短路上的边（边权设为111），新图应该是一个DAG\\text{DAG}DAG，接着dp\\text{dp}dp即可（应该是O(\\text{O}(O(能过)))）。 国王游戏202020分：正序枚举排列并剪枝。505050分：因为后面的人得到的金币数一般多于前面的，因此倒序枚举排列可以让最大值尽早暴露出来从而便于剪枝。 飞扬的小鸟dp好烦啊，不想写dp505050分：dfs(x,y,t)\\text{dfs}(x,y,t)dfs(x,y,t)表示到达(x,y)(x,y)(x,y)，点了ttt次。枚举点了多少次即可。稍加可行性和最优性剪枝。 愤怒的绿鸟小鸟这题据说搜索可以拿满分，久仰久仰现在是亲自证明搜索可以满分了对于每一个状态，强制要求消灭当前编号最小的猪，再枚举另一只猪，如果过这两只猪的抛物线满足题目要求，则扫描所有猪，把在这条抛物线上的所有猪删除，继续搜索。关键是“强制要求消灭当前编号最小的猪”，因为抛物线没有先后之别，因此作如上处理可以减少状态数。为方便判断边界，可以dfs(x,k)\\text{dfs}(x,k)dfs(x,k)表示当前编号最小的猪是xxx，已经发射了kkk只鸟。upd\\text{upd}upd：没想到这题比预料中好写。用了记忆化状压搜索，先预处理每一条抛物线可以消灭的猪，再搜索。 宝藏先枚举根，再枚举生成树的形态。如何枚举生成树的形态呢？只需枚举每一个点在第几层即可。第kkk层的点可以连向第k−1k-1k−1层的任意一个与它有连边的点，为了使这个方案最优，应该往上一层中与它距离最小的点连边。上述优化极其有效，大大降低了枚举的生成树的数量。其实这个也没有我想象中的那么难实现嘛 废话你都看过老师代码了 换教室什么？期望dp？先用Floyd\\text{Floyd}Floyd算出任意两点最短路。再枚举提出更换教室申请的方案，对于每一种申请方案，计算出这种方案下的期望，加上剪枝即可。dfs(x,t)\\text{dfs}(x,t)dfs(x,t)表示当前计算到第xxx个教室，已经提出申请的次数是ttt。 斗地主极其繁琐。注意到对于30%30\\%30%的数据，n≤4n\\le 4n≤4。因此只能出火箭、炸弹、单张、对子、三张和三带一。因此就比较简单。 Mayan游戏30%30\\%30%数据为一维，不会有连锁反应。 翻转棋这道题是去年NOIP\\text{NOIP}NOIP初赛的问题求解呢……当时我什么都不懂~~，现在也还是什么都不懂~~。首先发现每个格子只有可能翻000或111次。接着我们发现，第一行的方案确定后，第二行的方案也确定了（如果上方的格子是111，就必须翻；否则不能翻），整个棋盘的翻转方案也确定了。因此只需要O(2n)\\text{O}(2^n)O(2n)。 狗哥玩木棒因为木棒全用完，因此正方形边长为∑l4\\frac{\\sum l}{4}4∑l​。 小木棍枚举原来木棍的段数（注意不能二分）。剪枝要点：木棍段数是总长的因数，还有许多极其难以想到的优化。 字符串 字符串 蛤 习 蛤 习 基 本 法不要把数字映射到000，要不然有没有都不知道基底要大于字符种数（否则会被冒充）膜 数还是选一个质数（比较simple\\text{simple}simple的数）吧，比如某些888位质数，或者998244353,993244853,998244853,109+7,109+9998244353,993244853,998244853,10^9+7,10^9+9998244353,993244853,998244853,109+7,109+9。时间复杂度O(n)+1s\\text{O}(n) + 1\\text{s}O(n)+1s。 子串的 蛤 习记录前缀 蛤 习 数组hash[x]\\text{hash}[x]hash[x]表示到xxx的前缀串的 蛤 习，则任意子串s[i...j]s[i...j]s[i...j]的 蛤 习 值就是(hash[j]−ej−i+1hash[i−1])%p(\\text{hash}[j]-e^{j-i+1}\\text{hash}[i-1])\\% p(hash[j]−ej−i+1hash[i−1])%p。时间复杂度O(1)+1s\\text{O}(1) + 1\\text{s}O(1)+1s。 蛤 习 求周期枚举循环节长度LLL，判断s[1...L],s[L+1...2L],s[2L+1...3L]...s[1...L],s[L+1...2L],s[2L+1...3L]...s[1...L],s[L+1...2L],s[2L+1...3L]...的子串 蛤 习 是否相等，注意最后一个循环节可能不满。时间复杂度∑i=1nni=O(nlog⁡n)\\sum_{i=1}^{n}\\frac{n}{i}=\\text{O}(n\\log n)∑i=1n​in​=O(nlogn)。KMP\\text{KMP}KMP可以O(n)\\text{O}(n)O(n)。 求每个字符为中心的回文串的最大长度从Manacher\\text{Manacher}Manacher那里借一个方便的转化：在相邻两字符之间插入一个奇怪的字符~~，比如男魂~~，最后答案除以222即可。做正向和逆向两个 蛤 习 ，对每一个中心，二分最大回文串长度。O(nlog⁡n)\\text{O}(n\\log n)O(nlogn)。 字符串匹配枚举位置。 优秀的拆分枚举子串，对每一个子串枚举AAA，O(n3)\\text{O}(n^3)O(n3)。不枚举子串，转而枚举A,BA,BA,B的分界线，在分界线两端分别枚举AAA和BBB，再用乘法原理计算总方案数，O(n2)\\text{O}(n^2)O(n2)。虽然这是一道NOI\\text{NOI}NOI的题目，但是仅用 蛤 习 再加上一些可以理解的暴力手段，就可以拿到959595分！因此 蛤 习 大法好！坚持 MoHf\\text{MoHf}MoHf！","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"搜索","slug":"搜索","permalink":"https://sweetlemon39.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"字符串","slug":"字符串","permalink":"https://sweetlemon39.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"NOIP 2018 集训 Day 1","slug":"NOIP2018-day1","date":"2018-10-20T00:00:00.000Z","updated":"2018-10-20T00:00:00.000Z","comments":true,"path":"NOIP2018-day1/","link":"","permalink":"https://sweetlemon39.github.io/NOIP2018-day1/","excerpt":"前缀和与差分数组","text":"前缀和与差分数组 多维的前缀和S[i]=S[i−1]+a[i]S[i]=S[i-1]+a[i]S[i]=S[i−1]+a[i]S[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j]S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]S[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j]S[i][j][k]=S[i−1][j][k]+S[i][j−1][k]+S[i][j][k−1]S[i][j][k]=S[i-1][j][k]+S[i][j-1][k]+S[i][j][k-1]S[i][j][k]=S[i−1][j][k]+S[i][j−1][k]+S[i][j][k−1]−S[i−1][j−1][k]−S[i−1][j][k−1]−S[i][j−1][k−1]-S[i-1][j-1][k]-S[i-1][j][k-1]-S[i][j-1][k-1]−S[i−1][j−1][k]−S[i−1][j][k−1]−S[i][j−1][k−1]+S[i−1][j−1][k−1]+a[i][j][k]+S[i-1][j-1][k-1]+a[i][j][k]+S[i−1][j−1][k−1]+a[i][j][k]总之，有奇数个−1-1−1的是加，有偶数个−1-1−1的是减。如果不想这么麻烦怎么办？可以先对行做一维前缀和，再对列做一维前缀和，即按定义并结合低维前缀和计算，是降维打击。 最大子矩阵问题通过枚举左右端点，降到一维进行处理。 激光炸弹坐标同时+1+1+1可以方便处理。枚举右下端点，用二维前缀和计算子矩阵和。 聪明的质检员注意二分的循环条件为r−l&gt;1r-l&gt;1r−l&gt;1，因为当r=l+1r=l+1r=l+1时无论midmidmid偏向哪一边都会导致无限循环。 狗哥采矿dp\\text{dp}dp。f[i][j]f[i][j]f[i][j]表示(1,1)→(i,j)(1,1)\\rightarrow(i,j)(1,1)→(i,j)区域未开采，其余部分已开采的最大矿数和。也可以f[i][j]f[i][j]f[i][j]表示(1,1)→(i,j)(1,1)\\rightarrow(i,j)(1,1)→(i,j)区域已开采，其余部分未开采的最大矿数和。 跳棋反向dp\\text{dp}dp。倒过来跳，[li,ri][l_{i},r_{i}][li​,ri​]中的点可以跳到iii。$$f[i]=\\sum^{r}_{j=l}f[j]$$用“后缀和”处理。正向dp\\text{dp}dp。对于每一个iii，给f[j](j∈[li,ri])f[j](j\\in [l_{i},r_{i}])f[j](j∈[li​,ri​])加上f[i]f[i]f[i]。用差分数组（边弄边查）达到O(n)\\text{O}(n)O(n)。 木棍分割先二分求出最大值的最小值www，可以O(nlog⁡∑l)\\text{O}(n\\log\\sum{l})O(nlog∑l)也可以O(log⁡nlog⁡∑l)\\text{O}(\\log n \\log \\sum{l})O(lognlog∑l)。此处笔记：二分时使用半开区间，如[l,r),(l,r][l,r),(l,r][l,r),(l,r]是很方便的，但是注意循环判断条件要取r−l&gt;1r-l&gt;1r−l&gt;1。再进行dp\\text{dp}dp。f[i][j]f[i][j]f[i][j]表示考虑到第iii根木棍，已经切了jjj次的方案数。f[i][j]f[i][j]f[i][j]从f[t][j−1]f[t][j-1]f[t][j−1]转移而来，其中t+1t+1t+1到iii的和不超过www。如何维护ttt呢？可以二分（本蒟蒻的想法），但是这样就会额外产生对数因子。大佬用的方法，就是由于iii是顺序枚举的，所以ttt的左界限也是单调向右移动的。只需要弄一个指针，在iii向右移动的时候把ttt相应向右移动即可。可理解为“双指针法”。类似的例子有dp\\text{dp}dp中的“决策单调性”（石子合并），也是根据上次的决策确定本次的决策范围。这道题对于空间的限制很紧，只能使用short\\text{short}short。另外注意如果要计算a−b(modp)a-b\\pmod{p}a−b(modp)，一定要(a+p−b)%p(a+p-b)\\%p(a+p−b)%p，否则变成负数了就没得救了。 飞扬的小鸟dp\\text{dp}dp，f[x][y]f[x][y]f[x][y]表示到达点(x,y)(x,y)(x,y)所需的最小点击次数，若f[x][y]=+∞f[x][y]=+\\inftyf[x][y]=+∞表示这个点不可达。这里必须逆向转移才能优化。f[x][y]f[x][y]f[x][y]可以从f[x−1][y+Yx−1]f[x-1][y+Y_{x-1}]f[x−1][y+Yx−1​]（掉了Yx−1Y_{x-1}Yx−1​）或者f[x−1][y+kYx−1](k∈N+)f[x-1][y+kY_{x-1}](k\\in N_{+})f[x−1][y+kYx−1​](k∈N+​)（点了kkk次）转移而来。先考虑点了的情形。可以发现y+kYx−1y+kY_{x-1}y+kYx−1​对于Yx−1Y_{x-1}Yx−1​是同余的，并且重复地做了求min⁡\\minmin操作。可以对同余的点做一个前缀/后缀minminmin，即记录g[x][y]=min⁡(g[x][t])(t≡y(modYx),t≤y)g[x][y]=\\min(g[x][t])(t\\equiv y\\pmod{Y_{x}},t\\le y)g[x][y]=min(g[x][t])(t≡y(modYx​),t≤y)思路类似多重背包的单调队列优化。也可以按mod Yx−1\\text{mod } Y_{x-1}mod Yx−1​分组计算，用f[x][y]=min⁡(f[x−1][y−Yx−1],f[x][y−Yx−1]+1)f[x][y]=\\min(f[x-1][y-Y_{x-1}],f[x][y-Y_{x-1}]+1)f[x][y]=min(f[x−1][y−Yx−1​],f[x][y−Yx−1​]+1)，因为到达(x,y)(x,y)(x,y)所需的点击次数恰好比到达(x,y−Yx−1)(x,y-Y_{x-1})(x,y−Yx−1​)的次数多111。时间复杂度O(nm)\\text{O}(nm)O(nm)。这题在实现上有相当的难度，尤其要注意碰到顶的情形。额外判断是否能碰到顶时，要注意代码实现。123456789101112//correctif (ubound==m)&#123; for (int j=1;j&lt;=m;j++)&#123; int tans=(m-j)/x[i-1]+(((m-j)%x[i-1])?1:0); f[i][m]=min(f[i][m],f[i-1][j]+max(1,tans)); &#125;&#125;//wrongif (ubound==m) for (int j=max(m-x[i-1],l[i-1]+1);j&lt;=m;j++) f[i][m]=min(f[i][m],f[i-1][j]+1);上面错误的写法错在，一个位置可能重复点击多次才碰到顶。 借教室454545分：暴力。{90,100}\\{90,100\\}{90,100}分：线段树，区间最小值。普通线段树常数太大，会TLE\\text{TLE}TLE一个点；也许zkw\\text{zkw}zkw线段树可以AC\\text{AC}AC。100100100分：注意到前kkk个订单能否满足是单调的，因此可以考虑二分可以满足的订单数。对于一个kkk，首先O(m)\\text{O}(m)O(m)用差分标记区间加，再O(n)\\text{O}(n)O(n)检查是否满足要求。总复杂度O((n+m)log⁡m)\\text{O}((n+m)\\log m)O((n+m)logm)。想到满分算法的思路应该是先考虑枚举能满足的订单数，使用差分数组进行维护，再发现单调性，将mmm降为log⁡m\\log mlogm。差分数组处理每一个订单是O(1)\\text{O}(1)O(1)的，然而线段树是O(log⁡n)\\text{O}(\\log n)O(logn)的，故差分数组的解法具有优越性。如果这题一开始就想到线段树，可能对思维定势造成干扰，从而无法得到正解。 最高的牛这道题HDM\\text{HDM}HDM讲过呢，可是我印象不是很深刻了……证明的要点：区间只会有覆盖而不会有交叉。记住要去重。 天天爱跑步显然很难，所以考虑拿404040分。前202020分是送你的。第555个点暴力是否可过？对于退化成链的151515分，考虑能被第jjj个点看到的玩家，他一定在t=Wjt=W_jt=Wj​时位于第jjj个点，因此他的起点Si=j−WjS_{i}=j-W_jSi​=j−Wj​且终点Ti≥jT_{i}\\ge jTi​≥j，或Si=j+Wj,Ti≤jS_{i}=j+W_j, T_{i}\\le jSi​=j+Wj​,Ti​≤j。我的想法是把玩家按(Si,Ti)(S_{i},T_{i})(Si​,Ti​)为第一、第二关键字排序，把观察员拆成(j+Wj),(j−Wj)(j+W_j),(j-W_j)(j+Wj​),(j−Wj​)两个查询。用两个指针，单调地处理查询。对每一个查询，寻找满足条件的玩家，记录到ans[j]ans[j]ans[j]中。老师的想法是，先处理出以xxx为起点的点的数目cnt[x]cnt[x]cnt[x]，按顺序枚举观察员，当一个玩家的终点超出观察员的观察范围时把这个玩家从cnt[x]cnt[x]cnt[x]中减掉。群里大佬概括指出，WjW_jWj​相当于起点与观察点的距离。也许根据这个思路，就能解决Si=1S_{i}=1Si​=1和Ti=1T_{i}=1Ti​=1的数据了呢（这样好像就808080分了……） 栈 单调栈例题：广播体操HDM\\text{HDM}HDM讲过，是POJ2559。首先最终的矩形的高度肯定等于某一个柱的高度，因此先枚举矩形的高度。设f[i]f[i]f[i]表示iii左边高度不小于h[i]h[i]h[i]的连续柱子段的长度，那么如果h[i]≥h[i−1]h[i]\\ge h[i-1]h[i]≥h[i−1]，那么i−1i-1i−1柱所满足的连续柱子段，一定也可以用于iii柱。而如果h[i]&gt;h[i−1]h[i]&gt;h[i-1]h[i]&gt;h[i−1]就意味着f[i]=0f[i]=0f[i]=0。如果有h[i]≥h[i−1]h[i]\\ge h[i-1]h[i]≥h[i−1]，那么我们在计算f[i]f[i]f[i]的时候就可以直接利用f[i−1]f[i-1]f[i−1]。如果有连续的几个不大于h[i]h[i]h[i]的顶点，我们可以把它们的信息合并，只使用最右边的一个。体现在程序实现上，我们维护一个栈sss，sss中元素的hhh值是单调递增的。我们枚举到iii时，就删除栈中h[k]≥h[i]h[k]\\ge h[i]h[k]≥h[i]的元素kkk，并把f[k]+1f[k]+1f[k]+1累加入f[i]f[i]f[i]中，直到栈顶元素h[k]&lt;h[i]h[k]&lt;h[i]h[k]&lt;h[i]或栈空。再计算g[i]g[i]g[i]表示iii右边高度不小于h[i]h[i]h[i]的连续柱子段的长度，则答案即为max⁡((f[i]+g[i])×h[i])\\max((f[i]+g[i])\\times h[i])max((f[i]+g[i])×h[i])。 降维打击例题：玉蟾宫枚举矩形底端所在的行，转化为上一题。 LIS 模板题：导弹拦截维护单调数组g[i]g[i]g[i]，表示长度为iii的最长不升子序列的最后一个元素的最大值（为了给后面的元素留下最大的余地）。由于序列越长，最后一个元素一般就越小，因此ggg的值是单调不升的。对于一个iii，在ggg中二分寻找不小于a[i]a[i]a[i]的最后一个（最长的）g[j]g[j]g[j]，则以iii结尾的最长不升子序列的最大长度就是j+1j+1j+1。接着更新ggg数组，令g[j+1]=max⁡(g[j+1],a[i])=a[i]g[j+1]=\\max(g[j+1],a[i])=a[i]g[j+1]=max(g[j+1],a[i])=a[i]，因为根据二分的过程，a[i]a[i]a[i]一定大于g[j+1]g[j+1]g[j+1]。最长上升子序列同理。 最大数线段树可以水过去，但是码量稍大（雾？）“如果一个人比你小，还比你强，你就比不过他了。”“如果一个元素在你后面，比你大，你就被他掩盖了。”维护栈sss，栈中元素单调递减，越靠前的元素就越老。加入一个元素时，把栈中小于它的元素全部删除，请退役（可以用二分辅助）。查询后LLL个元素的最大值时~~（国际初中生信息学奥林匹克）~~，在栈中二分寻找最靠前（最大）的一个满足位置不小于LLL的元素。 音乐会的等待维护单调不增栈，越靠前的元素就越大。加入一个元素时，先在栈中二分找出比它大的最后一个（最小的）元素，，再把栈中小于它的元素全部删除，可以用二分辅助。可以把相同的数据压缩进一个cntcntcnt里。 矩形先考虑一维的情形，如11001101，则11这一段有3个，1这一段有1个。归纳得出，如果某一段有nnn个连续的1，这一段的矩形数就是∑i=1ni\\sum_{i=1}^{n}i∑i=1n​i。对于二维的情形，考虑降维打击。枚举矩形的左端点和右端点，把同一行左右端点内的所有格子的按位与运算的结果作为一维时矩形的值。真的做一遍按位与吗？那样就是O(n4)\\text{O}(n^4)O(n4)的呢，还不如直接枚举矩形的左上右下端点。考虑线段树求区间最小值 考虑一个前缀和数组，如果这一段的长度是lll，那么这一段里面全都是111当且仅当这一段的区间和也为lll。总复杂度O(n3)\\text{O}(n^3)O(n3)。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sweetlemon39.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Sweetlemon 蒟蒻的拙作","slug":"my-math-problems","date":"2018-10-20T00:00:00.000Z","updated":"2019-10-20T00:00:00.000Z","comments":true,"path":"my-math-problems/","link":"","permalink":"https://sweetlemon39.github.io/my-math-problems/","excerpt":"（一）开学了，高一(21)班共有n(n∈N∗)n (n\\in \\mathbb{N^{*}})n(n∈N∗)名同学，他们的学号分别是1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n。班主任为了让同学们相互认识，想了一个好办法。","text":"（一）开学了，高一(21)班共有n(n∈N∗)n (n\\in \\mathbb{N^{*}})n(n∈N∗)名同学，他们的学号分别是1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n。班主任为了让同学们相互认识，想了一个好办法。他在一次班会课上说：“同学们，如果你的学号是xxx，而另一个同学的学号是yyy，并且x+y=2k+2(k∈N)x+y=2^{k}+2(k\\in \\mathbb{N})x+y=2k+2(k∈N)，那么你们之间就有缘分。现在请你和所有与你有缘分的同学握手吧！”(1) 当n=30n=30n=30时，求所有与555号同学握手的同学的学号。(2) 求同学们握手的总次数。(3) 班主任的办法很有效，握过手的两名同学互相成为了朋友。而且这种朋友关系还具有传递性，即如果甲、乙是朋友，乙、丙是朋友，那么甲、丙也是朋友。现在21班要组建一个团队参加比赛，为了保证团队的团结，要求团队中任意两人都是朋友。求团队中人数的最大值。题解：(1) n=30n=30n=30时，握手关系如下图：因此所有与555号同学握手的同学的学号所组成的集合为{1,13,29}\\left \\{ 1,13,29 \\right\\}{1,13,29}。(2) 把111号同学称为“根”（可以理解为“全班的希望”）。设xxx为集合A={x∈N∣1&lt;x≤n}A=\\left \\{ x\\in \\mathbb{N} \\mid 1&lt;x\\le n \\right\\}A={x∈N∣1&lt;x≤n}中的任意元素。对于某一个xxx，设yyy是集合{y∈N∣1≤y&lt;x}\\left \\{ y\\in \\mathbb{N} \\mid 1\\le y&lt; x \\right\\}{y∈N∣1≤y&lt;x}中的某个元素，且有x+y=2k+2(k∈N)x+y=2^{k}+2(k\\in \\mathbb{N})x+y=2k+2(k∈N)。如果存在这样的yyy，那么我们称yyy为xxx的“父亲”（x\\sout{x}x被y\\sout{y}y​打败了，被迫承认的）。下面我们证明，对于AAA中的每一个元素，都有且仅有111个父亲~~（废话，你还能认两个人作父亲？）~~。整数yyy是xxx的父亲当且仅当0&lt;y&lt;x0&lt;y&lt;x0&lt;y&lt;x且x+y=2k+2x+y=2^k+2x+y=2k+2。上述条件成立，当且仅当存在一个自然数kkk，使得0&lt;2k+2−x&lt;x0&lt;2^k+2-x&lt;x0&lt;2k+2−x&lt;x。调整得到x&lt;2k+2&lt;2xx&lt;2^k+2&lt;2xx&lt;2k+2&lt;2x，即x−2&lt;2k&lt;2x−2x-2&lt;2^k&lt;2x-2x−2&lt;2k&lt;2x−2。下面证明对于每一个xxx，有且只有一个自然数kkk满足上式。设x−2=2a1+2a2+⋯+2anx-2=2^{a_1}+2^{a_2}+\\cdots+2^{a_n}x−2=2a1​+2a2​+⋯+2an​其中 a1&gt;a2&gt;⋯&gt;an,{a1,a2,⋯ ,an}⊆Na_1&gt;a_2&gt;\\cdots&gt;a_n,\\left\\{a_1,a_2,\\cdots,a_n\\right\\}\\subseteq \\mathbb{N}a1​&gt;a2​&gt;⋯&gt;an​,{a1​,a2​,⋯,an​}⊆N。则x−2=2a1+2a2+⋯+2an≤2a1+2a1−1+2a1−2+⋯+21+20&lt;2a1+1x-2=2^{a_1}+2^{a_2}+\\cdots+2^{a_n}\\le 2^{a_1}+2^{a_1-1}+2^{a_1-2}+\\cdots+2^{1}+2^{0}&lt;2^{a_1+1}x−2=2a1​+2a2​+⋯+2an​≤2a1​+2a1​−1+2a1​−2+⋯+21+20&lt;2a1​+1而2x−4=2(x−2)=2a1+1+2a2+1+⋯+2an+1≥2a1+12x-4=2(x-2)=2^{a_1+1}+2^{a_2+1}+\\cdots+2^{a_n+1}\\ge 2^{a_1+1}2x−4=2(x−2)=2a1​+1+2a2​+1+⋯+2an​+1≥2a1​+1。于是x−2&lt;2a1+1≤2x−4x-2&lt;2^{a_1+1}\\le 2x-4x−2&lt;2a1​+1≤2x−4，知x−2&lt;2a1+1&lt;2x−2x-2&lt;2^{a_1+1}&lt;2x-2x−2&lt;2a1​+1&lt;2x−2，知存在k=a1+1k=a_1+1k=a1​+1使得上式成立。再证明a1+1a_1+1a1​+1是唯一满足条件的kkk。若有k′&lt;a1+1k&#x27;&lt;a_1+1k′&lt;a1​+1满足上式，那么由k′∈Nk&#x27;\\in \\mathbb{N}k′∈N知k′≤a1k&#x27;\\le a_1k′≤a1​，则2k′≤2a1≤x−22^{k&#x27;}\\le 2^{a_1}\\le x-22k′≤2a1​≤x−2，与上式矛盾。若有k′&gt;a1+1k&#x27;&gt;a_1+1k′&gt;a1​+1满足上式，那么由k′∈Nk&#x27;\\in \\mathbb{N}k′∈N知k′≥a1+2k&#x27;\\ge a_1+2k′≥a1​+2，则2k′≥2a1+2&gt;2a1+1+2a1+2a1−1+⋯+21+202^{k&#x27;}\\ge 2^{a_1+2}&gt;2^{a_1+1}+2^{a_1}+2^{a_1-1}+\\cdots+2^1+2^02k′≥2a1​+2&gt;2a1​+1+2a1​+2a1​−1+⋯+21+20。而2x−4=2a1+1+2a2+1+⋯+2an+1&lt;2a1+1+2a1+2a1−1+⋯+21+202x-4=2^{a_1+1}+2^{a_2+1}+\\cdots+2^{a_n+1}&lt;2^{a_1+1}+2^{a_1}+2^{a_1-1}+\\cdots+2^1+2^02x−4=2a1​+1+2a2​+1+⋯+2an​+1&lt;2a1​+1+2a1​+2a1​−1+⋯+21+20（此处请注意因为a1&gt;a2&gt;⋯&gt;an≥0a_1&gt;a_2&gt;\\cdots&gt;a_n\\ge0a1​&gt;a2​&gt;⋯&gt;an​≥0，所以a1+1&gt;a2+1&gt;⋯&gt;an+1≥1a_1+1&gt;a_2+1&gt;\\cdots&gt;a_n+1\\ge1a1​+1&gt;a2​+1&gt;⋯&gt;an​+1≥1。）于是有2k′&gt;2x−42^{k&#x27;}&gt;2x-42k′&gt;2x−4。然而，若x−2&lt;2k′&lt;2x−2x-2&lt;2^{k&#x27;} &lt;2x-2x−2&lt;2k′&lt;2x−2，则有2k′&lt;2x−22^{k&#x27;}&lt;2x-22k′&lt;2x−2，由2k′∈N2^{k&#x27;}\\in \\mathbb{N}2k′∈N知2k′=2x−32^{k&#x27;}=2x-32k′=2x−3，且由于k′&gt;a1+1≥1k&#x27;&gt;a_1+1\\ge1k′&gt;a1​+1≥1知2k′2^{k&#x27;}2k′一定是偶数，出现矛盾。综上，a1+1a_1+1a1​+1是唯一满足条件的kkk。由此，我们得出，对于AAA中的每一个元素，都有且仅有111个父亲。考虑每一次握手，设握手的两人分别为xxx和yyy，不妨设x&gt;yx&gt;yx&gt;y，则由上面的结论知yyy是xxx的父亲，因此每一次握手都仅在一个人和他的父亲之间发生~~（“发生”这个词好恐怖）~~，且学号大于111的每个人都会和他的父亲握手。有多少对父子关系就有多少次握手。111没有父亲，而所有学号大于111的人都有父亲，因此同学们握手的总次数为n−1n-1n−1。(3) 我们设111的祖先为111本身~~（我 生 我 自 己）~~，其余点的祖先定义为它父亲的祖先。（可以看上面的图帮助理解，按照图上的箭头反向往上走，走到最上面就是祖先。也可以理解为祖先是父亲的父亲的父亲的……父亲的父亲。）用符号语言来表示，记一个人的父亲为par(x)\\text{par}(x)par(x)，记一个人的祖先为gpar(x)\\text{gpar}(x)gpar(x)。那么若x=1x=1x=1，则gpar(x)=1\\text{gpar}(x)=1gpar(x)=1；否则gpar(x)=gpar(par(x))\\text{gpar}(x)=\\text{gpar}(\\text{par}(x))gpar(x)=gpar(par(x))。如gpar(2)=gpar(par(2))=gpar(1)=1\\text{gpar}(2)=\\text{gpar}(\\text{par}(2))=\\text{gpar}(1)=1gpar(2)=gpar(par(2))=gpar(1)=1。由父亲和祖先的定义知，一个人和他的祖先一定有朋友关系~~（怎么看着怪怪的）~~。观察上面的图，我们发现图上每一个人的祖先都是111！这是不是巧合呢？事实上，我们可以证明，任意满足1≤x≤n1\\le x\\le n1≤x≤n的整数的祖先都是111。怎么证明呢？我们可以 感性理解 用数学归纳法。首先，当x=1x=1x=1时，按照定义，欲证命题显然成立。接着，我们设当x≤kx\\le kx≤k时欲证命题成立，即“任意满足1≤x≤k1\\le x\\le k1≤x≤k的整数的祖先都是111”成立。下面我们要证明当x=k+1x=k+1x=k+1时命题也成立。由(2)，par(k+1)&lt;k+1\\text{par}(k+1)&lt;k+1par(k+1)&lt;k+1，由于par(k+1)∈N\\text{par}(k+1)\\in \\mathbb{N}par(k+1)∈N，知par(k+1)≤k\\text{par}(k+1)\\le kpar(k+1)≤k，由归纳假设知gpar(par(k+1))=1\\text{gpar}(\\text{par}(k+1))=1gpar(par(k+1))=1。由祖先的定义知gpar(k+1)=1\\text{gpar}(k+1)=1gpar(k+1)=1，即欲证命题在x=k+1x=k+1x=k+1时也成立。根据数学归纳法，对任意满足1≤x≤n1\\le x\\le n1≤x≤n的整数，gpar(x)=1\\text{gpar}(x)=1gpar(x)=1。（由于我们还没有学过数学归纳法，因此这段证明过程在实际书写时可以略微 意会 调整。）于是，每一个人都和111号同学是朋友。由朋友关系的传递性，全班同学都彼此是朋友。因此团队中人数的最大值为nnn。这道题解完了，我们有什么收获呢？我们要向高一(21)班的同学学习，让我们的班集体变得更团结~~，变得更团结的方式就是彼此认父亲，并发生握手关系~~。 （二）有一个有限集S={a1,a2,a3,⋯ ,an}S=\\left\\{ a_1,a_2,a_3,\\cdots, a_n\\right\\}S={a1​,a2​,a3​,⋯,an​}，并且设A={x∣x⊆S}A=\\left \\{x\\mid x\\subseteq S\\right \\}A={x∣x⊆S}。现在已知映射f0:A→Rf_0:A\\rightarrow \\mathbb{R}f0​:A→R，设AAA上的映射f1,f2,⋯ ,fnf_1,f_2,\\cdots,f_nf1​,f2​,⋯,fn​，对所有1≤k≤n1\\le k\\le n1≤k≤n的整数kkk，满足以下条件：∀x∈A ∧ ak∉x, fk(x)=fk−1(x)\\forall x\\in A \\ \\ \\wedge \\ \\ a_k\\not \\in x,\\ \\ f_{k}(x)=f_{k-1}(x)∀x∈A ∧ ak​​∈x, fk​(x)=fk−1​(x)∀x∈A ∧ ak∈x, fk(x)=fk−1(x)+fk−1(∁{ak}x)\\forall x\\in A\\ \\ \\wedge \\ \\ a_k\\in x,\\ \\ f_k(x)=f_{k-1}(x)+f_{k-1}(\\complement_{\\left\\{ a_{k} \\right\\} }x)∀x∈A ∧ ak​∈x, fk​(x)=fk−1​(x)+fk−1​(∁{ak​}​x)请写出fn(S)f_{n}(S)fn​(S)的值并给出证明。 （三）有一个游戏，初始时A={0},B={−1}A=\\left\\{0\\right\\},B=\\left\\{-1\\right\\}A={0},B={−1}。游戏有nnn次操作，第k(1≤k≤n)k(1\\le k\\le n)k(1≤k≤n)次会从A∪BA\\cup BA∪B中等概率随机选择一个数xxx，如果设这个数xxx所在的集合为S(S∈{A,B})S(S\\in \\left\\{A,B\\right\\})S(S∈{A,B})，那么这次操作会将SSS变为S∪{k}S\\cup \\left\\{k\\right\\}S∪{k}。求这nnn次操作后，AAA集合的元素数量是t(1≤t≤n+1)t(1\\le t\\le n+1)t(1≤t≤n+1)的概率。 题解此概率与ttt无关，都为1n+1\\frac{1}{n+1}n+11​。有几种证明方法： 数学归纳法设g[i][j]g[i][j]g[i][j]为进行了iii次操作，AAA集合中有jjj个数的概率。则g[0][1]=1=10+1g[0][1]=1=\\frac{1}{0+1}g[0][1]=1=0+11​，初始条件满足。g[i][j]=j−1i−1+2g[i−1][j−1]+(i−1+2)−ji−1+2g[i−1][j]=1i+1((j−1)g[i−1][j−1]+(i+1−j)g[i−1][j])\\begin{aligned}g[i][j]&amp;=\\frac{j-1}{i-1+2}g[i-1][j-1]+\\frac{(i-1+2)-j}{i-1+2}g[i-1][j]\\\\&amp;=\\frac{1}{i+1}((j-1)g[i-1][j-1]+(i+1-j)g[i-1][j])\\end{aligned}g[i][j]​=i−1+2j−1​g[i−1][j−1]+i−1+2(i−1+2)−j​g[i−1][j]=i+11​((j−1)g[i−1][j−1]+(i+1−j)g[i−1][j])​此时若有g[i−1][x]=1ig[i-1][x]=\\frac{1}{i}g[i−1][x]=i1​（归纳假设），则g[i][j]=1i+1((j−1)g[i−1][j−1]+(i+1−j)g[i−1][j])=1i+1(j−1+i+1−j)1i=1i+1\\begin{aligned}g[i][j]&amp;=\\frac{1}{i+1}((j-1)g[i-1][j-1]+(i+1-j)g[i-1][j])\\\\&amp;=\\frac{1}{i+1}(j-1+i+1-j)\\frac{1}{i}\\\\&amp;=\\frac{1}{i+1}\\end{aligned}g[i][j]​=i+11​((j−1)g[i−1][j−1]+(i+1−j)g[i−1][j])=i+11​(j−1+i+1−j)i1​=i+11​​因此根据数学归纳法证毕。 臆想法这一种方法需要很强的臆想能力。把“选到的数在AAA中”记为111，“选到的数在BBB中”记为000。那么nnn次操作可以记为一个010101序列，不妨记为{an}\\left\\{a_n\\right\\}{an​}。记{an}\\left\\{a_n\\right\\}{an​}的前nnn项和为{Sn}\\left\\{S_n\\right\\}{Sn​}。令S0=0S_0=0S0​=0。我们首先计算“操作序列恰好是某个（确定的）{an}\\left\\{a_n\\right\\}{an​}”的概率，记为P({an})P(\\left\\{a_n\\right\\})P({an​})。设g[i]g[i]g[i]为“前iii个操作恰好为{an}\\left\\{a_n\\right\\}{an​}的前iii项”的概率，那么P({an})=g[n]P(\\left\\{a_n\\right\\})=g[n]P({an​})=g[n]。令g[0]=1g[0]=1g[0]=1。下面考虑g[i]g[i]g[i]的递推式。g[i]={Si−1+1i+1g[i−1], ai=1,i−Si−1i+1g[i−1], ai=0(i≥1)g[i]=\\begin{cases}\\frac{S_{i-1}+1}{i+1}g[i-1],\\ a_i=1,\\\\ \\frac{i-S_{i-1}}{i+1}g[i-1],\\ a_i=0\\end{cases}(i\\ge 1)g[i]={i+1Si−1​+1​g[i−1], ai​=1,i+1i−Si−1​​g[i−1], ai​=0​(i≥1)对上面的递推式用累乘法，发现一些事情：g[n]g[n]g[n]的分母一定是2×3×4×⋯×(n+1)=(n+1)!2\\times 3\\times 4\\times\\cdots\\times (n+1)=(n+1)!2×3×4×⋯×(n+1)=(n+1)!假设aia_iai​之后下一个为111的项是ai′a_{i&#x27;}ai′​，那么 Si′−1=Si−1+1S_{i&#x27;-1}=S_{i-1}+1Si′−1​=Si−1​+1。而iii项的分子是 Si−1+1S_{i-1}+1Si−1​+1，i′i&#x27;i′项的分子是 Si′−1+1=Si−1+1+1S_{i&#x27;-1}+1=S_{i-1}+1+1Si′−1​+1=Si−1​+1+1，知i′i&#x27;i′项的分子恰好比iii项的分子多111。所以所有ai=1a_i=1ai​=1项的分子是从111逐个递增到SnS_nSn​的，所有ai=1a_i=1ai​=1项的分子的乘积是Sn!S_n!Sn​!假设aia_iai​之后下一个为000的项是ai′a_{i&#x27;}ai′​，那么 Si′−1=Si−1+(i′−1−i)S_{i&#x27;-1}=S_{i-1}+(i&#x27;-1-i)Si′−1​=Si−1​+(i′−1−i)。而iii项的分子是 i−Si−1i-S_{i-1}i−Si−1​，i′i&#x27;i′项的分子是 i′−Si′−1=i′−(Si−1+(i′−1−i))=i−Si−1+1i&#x27;-S_{i&#x27;-1}=i&#x27;-(S_{i-1}+(i&#x27;-1-i))=i-S_{i-1}+1i′−Si′−1​=i′−(Si−1​+(i′−1−i))=i−Si−1​+1，知i′i&#x27;i′项的分子恰好比iii项的分子多111。一共有n−Snn-S_nn−Sn​项为000，它们的分子从111逐个递增到n−Snn-S_nn−Sn​，于是所有ai=0a_i=0ai​=0项的分子的乘积是(n−Sn)!(n-S_n)!(n−Sn​)!那么就得到P({an})=Sn!(n−Sn)!(n+1)!P(\\left\\{a_n\\right\\})=\\frac{S_n!(n-S_n)!}{(n+1)!}P({an​})=(n+1)!Sn​!(n−Sn​)!​。上述几条结论不能推出来也没关系。“举例是理解的试金石”，我们不妨算一下010101序列010010010010010010的概率。g[1]=12g[0]g[1]=\\frac{1}{2}g[0]g[1]=21​g[0]，操作后AAA的元素数是111，BBB的元素数是222；g[2]=13g[1]g[2]=\\frac{1}{3}g[1]g[2]=31​g[1]，操作后AAA的元素数是222，BBB的元素数是222；g[3]=24g[2]g[3]=\\frac{2}{4}g[2]g[3]=42​g[2]，操作后AAA的元素数是222，BBB的元素数是333；g[4]=35g[3]g[4]=\\frac{3}{5}g[3]g[4]=53​g[3]，操作后AAA的元素数是222，BBB的元素数是444；g[5]=26g[4]g[5]=\\frac{2}{6}g[4]g[5]=62​g[4]，操作后AAA的元素数是333，BBB的元素数是444；g[6]=47g[5]g[6]=\\frac{4}{7}g[5]g[6]=74​g[5]，操作后AAA的元素数是333，BBB的元素数是555.把式子乘起来得到g[6]=1×1×2×3×2×42×3×4×5×6×7=(1×2×3×4)×(1×2)2×3×4×5×6×7g[6]=\\frac{1\\times 1\\times 2\\times 3\\times 2\\times 4}{2\\times 3\\times 4\\times 5\\times 6\\times 7}=\\frac{(1\\times 2\\times 3\\times 4)\\times (1\\times 2)}{2\\times 3\\times 4\\times 5\\times 6\\times 7}g[6]=2×3×4×5×6×71×1×2×3×2×4​=2×3×4×5×6×7(1×2×3×4)×(1×2)​我们只是把000的分子和111的分子分开，就得到了结论。或者，我们可以这么理解：概率的分子就是操作前这个集合中的元素个数。如果AAA集合要从111个元素变到u+1u+1u+1个元素（即序列中有uuu个111），必然经历了1→2,2→3,⋯ ,u→u+11\\rightarrow 2,2\\rightarrow 3,\\cdots,u\\rightarrow u+11→2,2→3,⋯,u→u+1的过程，这些过程中概率的分子之积自然是u!u!u!。BBB集合也是一样。不管如何，我们现在得到了——操作序列是某个“含有uuu个111”的010101串的概率是u!(n−u)!(n+1)!\\frac{u!(n-u)!}{(n+1)!}(n+1)!u!(n−u)!​（为方便描述，将上面推导过程中的SnS_nSn​用uuu代替了）。从式子中我们发现，所有“含有uuu个111”的010101串的概率是相等的。当u=t−1u=t-1u=t−1时，操作结束后，AAA的元素数就是ttt。于是，“操作结束后，AAA的元素数就是ttt”的概率，就等于所有“含有uuu个111”的010101串的概率之和。（这里用的是概率的加法原理，因为这些010101串两两互斥（操作序列不可能同时为两个010101串），且总事件全部由这些分事件所组成，因此可以这么计算。）有多少“含有uuu个111”的010101串呢？这是经典的子集问题，显然有Cnu=n!u!(n−u)!\\mathrm{C}_n^u=\\frac{n!}{u!(n-u)!}Cnu​=u!(n−u)!n!​个。神奇的事情发生了——把010101串数和每个010101串的概率乘起来：n!u!(n−u)!×u!(n−u)!(n+1)!=n!(n+1)!=1n+1\\frac{n!}{u!(n-u)!}\\times \\frac{u!(n-u)!}{(n+1)!}=\\frac{n!}{(n+1)!}=\\frac{1}{n+1}u!(n−u)!n!​×(n+1)!u!(n−u)!​=(n+1)!n!​=n+11​于是就证完了…… （四）AAA 是非空有限集，且对于 AAA 的所有非空子集 SSS，均有 {∅}∈S\\left\\{\\varnothing \\right\\}\\in S{∅}∈S 或 {∅}⊆S\\left\\{\\varnothing \\right\\}\\subseteq S{∅}⊆S。求 AAA。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"二分图学习笔记","slug":"bipartite-graph","date":"2018-10-18T00:00:00.000Z","updated":"2018-10-18T00:00:00.000Z","comments":true,"path":"bipartite-graph/","link":"","permalink":"https://sweetlemon39.github.io/bipartite-graph/","excerpt":"二分图 定义二分图又称双分图、二部图、偶图，指顶点可以分成两个不相交的集UUU和VVV，UUU和VVV皆为独立集（即同一个集内的顶点没有共同边）的图。（摘自维基百科）","text":"二分图 定义二分图又称双分图、二部图、偶图，指顶点可以分成两个不相交的集UUU和VVV，UUU和VVV皆为独立集（即同一个集内的顶点没有共同边）的图。（摘自维基百科）即如果能把某一个图的顶点集VVV划分为两个集合AAA和BBB，使得图中的每一条边都是由AAA中的顶点连向BBB中的顶点（或反之），那么就称这个图为二分图。 判定二分图有两三种判定方法。染色。如果一个图的所有顶点都可以被指定一个颜色，这个颜色是000或111，且每一条边所连接的两个顶点的颜色都不同，那么这个图就为二分图。奇环定理。一个图是二分图，当且仅当这个图中没有奇环（即经过边数为奇数的环）。证明留作习题算了，这个稍微证明一下。首先，二分图与可以染色的等价性是容易证明的，只要把同色顶点划分到一个集合中去就好了。接着证明奇环定理。这个证明用到了下面的“另一个判定方法”。引理1：如果无权无向图中存在两点(u,v)(u,v)(u,v)，它们之间存在两条长度奇偶性不同的路径，那么这个图存在奇环。证明：设这两条路径分别为u→v,v→uu\\rightarrow v, v\\rightarrow uu→v,v→u，那么u→v→uu\\rightarrow v\\rightarrow uu→v→u的长度为奇数，且构成一个环。证毕。引理2：如果一个无向图无法进行黑白染色，那么这个图中一定存在两点(u,v)(u,v)(u,v)，它们之间存在两条长度奇偶性不同的路径。证明：采用反证法。如果图中不存在两点(u,v)(u,v)(u,v)，使得它们之间存在两条长度奇偶性不同的路径；那么每个连通块任取一个顶点（记为该连通块的111号点），把到111号点路径长度为奇数的点染上白色，到111号点路径长度为偶数的点染上黑色，就完成了黑白染色（这时同色点之间一定无连边）。证毕。结合这两个引理，就很容易证明奇环定理了。补充：带权冰茶姬判断二分图。二分图的另一个判定方法：在无权图中，如果任意两点间的任何路径长度的奇偶性都相同，就说明这个图是二分图。（上面引理用到的条件）证明方法：在有奇环的图中，一个点绕奇环奇数次回到自己的路径长是奇数，走了上述路径后再走路径到达另一点，所走所有路径长之和奇偶性和原来不同。判断方法：对图中每一条边连边，冰茶姬中维护每一个点到根的距离(mod2)\\pmod{2}(mod2)。当连接在同一冰茶姬中的两个点时，若这两个点到根的距离之和为奇数，则满足条件；否则不满足二分图条件。当连接不在同一冰茶姬中的两个点时，在root(x)\\text{root}(x)root(x)和root(y)\\text{root}(y)root(y)之间连边。若把root(x)\\text{root}(x)root(x)并到root(y)\\text{root}(y)root(y)上，则dis(root(x))=dis(x)+1+dis(y)\\text{dis}(\\text{root}(x))=\\text{dis}(x)+1+\\text{dis}(y)dis(root(x))=dis(x)+1+dis(y)（上式中的111指边x→yx\\rightarrow yx→y）。在mod 2\\mod{2}mod2的运算中，加法可以表现为位运算的异或。证明上述方法要点：一条边走两遍不影响dismod 2\\text{dis} \\mod{2}dismod2的值。也可以把“每一个点到根的距离(mod2)\\pmod{2}(mod2)”理解为“这个点是否和根在二分图同一侧”，结合异或的性质可以很容易理解。注意：路径压缩时如何维护dis\\text{dis}dis数组？12345678int ufind(int x)&#123; if (uset[x]==x) return x; int raw_par=uset[x]; uset[x]=ufind(raw_par); dis[x]=dis[x]^dis[raw_par]; return uset[x];&#125; 例题设n∈N∗n\\in \\mathbb{N}^{*}n∈N∗，n≤15n\\le 15n≤15，集合A,BA,BA,B都是I={1,2,⋯ ,n}I=\\left\\{1,2,\\cdots,n\\right\\}I={1,2,⋯,n}的真子集，A∩B=∅A\\cap B=\\varnothingA∩B=∅，A∪B=IA\\cup B=IA∪B=I. 证明：集合AAA或BBB中，必有两个不同的数，它们的和为完全平方数。（《奥数教程 高中第一分册 第1讲 集合的概念与运算 例6》）我们把集合III视作一个图GGG的顶点集，对两个和为完全平方数的顶点连边，那么这道题其实就是证明GGG不是二分图。根据二分图的判定方法2，我们只需证明图中有奇环即可。我们发现1→3→6→10→15→11\\rightarrow 3\\rightarrow 6\\rightarrow 10\\rightarrow 15\\rightarrow 11→3→6→10→15→1是一个奇环，因此GGG不是二分图，证毕。将正整数集N+\\mathbb{N}_{+}N+​分为两个集合使得(1)1∈A1\\in A1∈A(2)AAA中任意两个元素之和都不具有2k+2(k∈N)2^{k}+2(k\\in \\mathbb{N})2k+2(k∈N)的形式(3)BBB也具有性质(2)证明：这样的分划是唯一的。（《奥数教程 高中第一分册 第22讲 集合的分划 练习题7》）一个连通的二分图的分划只有两种，如果指定了某一个元素所属的集合，这样的分划就是唯一的。于是我们只需证明这个图是连通的即可。我们对两个和具有2k+2(k∈N)2^{k}+2(k\\in \\mathbb{N})2k+2(k∈N)的形式的两个顶点连边，经过考察，我们发现这个图不仅是连通图，还是一棵树！（证明方法是，对于每一个x∈N,x&gt;1x\\in \\mathbb{N},x&gt;1x∈N,x&gt;1，有且仅有一个y∈N,0&lt;y&lt;xy\\in \\mathbb{N},0&lt;y&lt;xy∈N,0&lt;y&lt;x，使得x+y=2k+2(k∈N)x+y=2^{k}+2(k\\in \\mathbb{N})x+y=2k+2(k∈N)。我们只要把yyy作为xxx的父亲节点即可。）于是这道题也解决了。这道题被改编为了数学社某次周赛题。 二分图染色用dfs\\text{dfs}dfs和bfs\\text{bfs}bfs均可，时间复杂度为O(n)\\text{O}(n)O(n)。 二分图匹配 致谢下文参考和摘录了Renfei Song’s Blog - 二分图的最大匹配、完美匹配和匈牙利算法这篇文章的内容，在此向原作者表示感谢！ 定义若MMM是二分图GGG的子图，且MMM中的任意两条边都没有公共顶点，那么就称MMM为GGG的一个匹配。“匹配点”指MMM中连边的点，“非匹配点”指GGG中除了匹配点以外的其他点；“匹配边”指MMM中的边，“非匹配边”指MMM中除了匹配边以外的其他边。显然，匹配点的个数vvv和匹配边的条数eee之间存在关系v=2ev=2ev=2e。下面的图3和图4都是二分图匹配的例子，其中红色的边是匹配边。图3中1,4,5,71,4,5,71,4,5,7是匹配点，图4中1,2,3,4,5,6,7,81,2,3,4,5,6,7,81,2,3,4,5,6,7,8是匹配点。一个图所有匹配中，所含匹配边数最多的匹配（当然也可以定义为所含匹配点数最多的匹配），称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（匹配点不可能再多），但并非每个图都存在完美匹配。 匈牙利算法匈牙利算法是利用“增广路”求最大匹配的算法。首先我们来看一下什么是“交替路”和“增广路”。交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边、匹配边…，形成的简单路径叫交替路。增广路：起点和终点均为非匹配点的交替路称为增广路。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。摘录了这么多，为什么可以利用增广路来找最大匹配呢？下面我解释一下。首先，我们要从二分图的集合AAA中找到一个非匹配点（如果找不到，就说明这已经是最大匹配了，算法结束），下面我们的目标就是对它进行匹配。从哪里去找匹配呢？肯定只能从和它连边的顶点去找呀。如果和它连边的顶点中有某一个是非匹配点，那么就匹配成功了。此时找到的这条路正是增广路（既满足交替路的条件，又满足起点和终点都是非匹配点）。如果和它连边的顶点都是匹配点了怎么办？放弃吧！南三科艺楼，一跃解千愁不行呢，要热爱生命（逃）。如果和它连边的顶点都是匹配点，有可能是之前的匹配不合适。如下图，与333顶点连边的都是匹配点，但是我们很容易就能看出来这个匹配不合适，如果把顶点111改成和666匹配，那么顶点333就可以和555顺利匹配了。因此，下一步应该是，让顶点333和顶点111“协商”，请顶点111寻找另一个匹配点。这样问题就转化为了对顶点111进行匹配。这时我们可以理解为先走非匹配边3→53\\rightarrow 53→5，再走匹配边5→15\\rightarrow 15→1；接下来顶点111由于不能继续和原来的配对点555配对，必须走非匹配边1→61\\rightarrow 61→6。而且走环是没有意义的（只会导致死循环）。从而我们证明了，这样一个过程走的是交替路。如果在上述过程中，某一个AAA中的顶点找到了与之相邻的非匹配点，那么显然它就可以改成和这个新找到的非匹配点相匹配，从而之前的假设“更换匹配点”就满足了。这时的路径便是一条增广路。或者按照上文增广路的特点来理解，更换增广路中匹配边和非匹配边的身份，也可以增加匹配数。总之，如果这个点有可能匹配成功，就能通过增广路的方法进行匹配。接下来是一个小优化（效果很好）。“如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。”这是什么意思呢？就是说，如果对BBB中的某个节点，与它匹配的AAA中节点没有办法更换匹配点，那么我们就可以给BBB中的这个节点打上一个“你是我的唯一”不可替代的标记，今后再尝试匹配时就不需要再和BBB中的这个节点进行协调了。上面这一段的内容有问题。如果是递归的某一层（不是顶层）找不到可更换的匹配，可能原因是，这个点其实是可以换匹配的，但是需要和它的上层协调（它的上层当前还没有更换到合适的匹配），而为了防止死循环，我们规定下层不能和上层协调，因此这次会返回失败。当然，如果顶层匹配失败，那就一定没有匹配，可以给这个点打上一个“单身狗”标签（笑）。给一组数据：1234567895 5 81 41 55 53 12 22 51 23 2匈牙利算法的时间复杂度是O(nm)\\text{O}(nm)O(nm)，是不是和SPFA\\text{SPFA}SPFA的时间复杂度一样呢？事实上，匈牙利算法和SPFA\\text{SPFA}SPFA一样，实际运行时间往往并没有理论上的那么糟。 匈牙利算法的实现以P3386 【模板】二分图匹配为例。这道题AAA集合和BBB集合中的顶点编号是重复的，要格外注意。下面是bfs\\text{bfs}bfs版本的代码。(215ms215\\text{ms}215ms，无优化928ms928\\text{ms}928ms)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#define MAXM 1000005#define MAXN 1005#define MAXQ 1005using namespace std;int g[MAXM]; //Graph arrayint fst[MAXN]=&#123;0&#125;,nxt[MAXM]=&#123;0&#125;; //Fore listint prev[MAXN]=&#123;0&#125;; //prev means the last vertex which wanted to matchint ans=0; //Ans means the count of matching edgesint match[MAXN]=&#123;0&#125;; //Match (A-&gt;B)int invmatch[MAXN]=&#123;0&#125;; //Match (B-&gt;A)int que[MAXN]; //Don't use std::queue! It's slow.int visited[MAXN]; //Only for vertexes in Bint unable_stack[MAXN]=&#123;0&#125;; //Store the vertexes (in B) which are going to be unablevoid hungarian(int x);int main(void)&#123; int n,m,e; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;e); for (int i=0;i&lt;e;i++)&#123; int u,v; int edge_num=i+1; scanf(\"%d%d\",&amp;u,&amp;v); if (v&gt;m) continue; //According to the tips //Only connect edges from A to B g[edge_num]=v; nxt[edge_num]=fst[u]; fst[u]=edge_num; &#125; for (int i=1;i&lt;=n;i++) if (!match[i]) //i hasn't found a vertex to match with hungarian(i); printf(\"%d\\n\",ans); return 0;&#125;void hungarian(int x)&#123; int head,tail,st; //Queue head, queue tail, stack top head=tail=0; que[tail++]=x; //Notice: every vertex in que is in A prev[x]=0; //Prev means the vertex which asks i to change its matching vertex st=0; while (head!=tail)&#123; //!q.empty() int nowv=que[head++]; //nowv means the current vertex which wants to change its matching vertex if (head==MAXQ) head=0; //Cycling queue for (int i=fst[nowv];i;i=nxt[i])&#123; if (visited[g[i]]==-1 || visited[g[i]]==x) //The visited array is similar to the \"inq\" tag //visited[x]==-1 means it can't be replaced continue; unable_stack[st++]=g[i]; //Push g[i] to the stack //If this match fails, visited[g[i]] will be set to -1 visited[g[i]]=x; //Notice: the index of visited means vertexes in B if (!invmatch[g[i]])&#123; //If g[i] isn't a matching vertex int nowv_to_match=g[i]; int prev_to_match; ans++; //Find a new matching edge while (nowv)&#123; //Go back in order to update the matching vertexes prev_to_match=match[nowv]; match[nowv]=nowv_to_match; invmatch[nowv_to_match]=nowv; nowv=prev[nowv]; nowv_to_match=prev_to_match; &#125; //Match successfully, return return; &#125; //Ask invmatch[g[i]] (the vertex which matches with g[i]) to change its matching vertex que[tail++]=invmatch[g[i]]; prev[invmatch[g[i]]]=nowv; //Set down the prev if (tail==MAXQ) tail=0; &#125; &#125; //Match failed //Set the visited value of all the vertexes which I have asked to change to -1 while (st)&#123; st--; visited[unable_stack[st]]=-1; &#125;&#125;下面是dfs\\text{dfs}dfs版本的代码（262ms262\\text{ms}262ms，无优化1042ms1042\\text{ms}1042ms）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#define MAXM 1000005#define MAXN 1005using namespace std;int g[MAXM]; //Graph arrayint fst[MAXN]=&#123;0&#125;,nxt[MAXM]=&#123;0&#125;; //Fore listint ans=0; //Ans means the count of matching edgesint rnd=0; //Means the round of dfsint match[MAXN]=&#123;0&#125;; //Match (A-&gt;B)int invmatch[MAXN]=&#123;0&#125;; //Match (B-&gt;A)int visited[MAXN]; //Only for vertexes in Bint hungarian(int x);int main(void)&#123; int n,m,e; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;e); for (int i=0;i&lt;e;i++)&#123; int u,v; int edge_num=i+1; scanf(\"%d%d\",&amp;u,&amp;v); if (v&gt;m) continue; //According to the tips //Only connect edges from A to B g[edge_num]=v; nxt[edge_num]=fst[u]; fst[u]=edge_num; &#125; for (int i=1;i&lt;=n;i++)&#123; if (!match[i])&#123; //i hasn't found a vertex to match with rnd=i; if (hungarian(i)) ans++; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;int hungarian(int x)&#123; for (int i=fst[x];i;i=nxt[i])&#123; if (visited[g[i]]==-1 || visited[g[i]]==rnd) //The visited array is similar to the \"inq\" tag //visited[x]==-1 means it can't be replaced continue; visited[g[i]]=rnd; //Notice: the index of visited means vertexes in B if (!invmatch[g[i]] || hungarian(invmatch[g[i]]))&#123; //If g[i] isn't a matching vertex or its matching vertex has successfully changed match[x]=g[i]; invmatch[g[i]]=x; return 1; &#125; &#125; //Match failed //Set the visited of match[x] to -1 if (match[x]) visited[match[x]]=-1; return 0;&#125;","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"二分图","slug":"二分图","permalink":"https://sweetlemon39.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"}]},{"title":"KMP（MP）小记","slug":"kmp","date":"2018-10-17T00:00:00.000Z","updated":"2018-10-17T00:00:00.000Z","comments":true,"path":"kmp/","link":"","permalink":"https://sweetlemon39.github.io/kmp/","excerpt":"今天写了一遍KMP\\text{KMP}KMP，看来也没有想象中那么难写嘛……","text":"今天写了一遍KMP\\text{KMP}KMP，看来也没有想象中那么难写嘛……首先是next\\text{next}next数组的求法。很多博客里说是“自匹配求next\\text{next}next”，但是我完全不懂。直到看到了知乎上的这篇文章，才终于掌握了求next\\text{next}next的方法。这个回答中的“次优”二字很妙，点破了求next\\text{next}next的真谛。如何更好的理解和掌握 KMP 算法? - 逍遥行的回答 - 知乎下面对next\\text{next}next数组的求法给予简单说明。本文中next[i]\\text{next[i]}next[i]指的是s[0...i]\\text{s[0...i]}s[0...i]这一段中，既是真前缀又是真后缀的最长子串的长度，如在字符串&quot;aaaaa&quot;中，next[4]=4\\text{next[4]}=4next[4]=4。我们假设现在已经求出了next[0]∼next[i-1]\\text{next[0]}\\sim\\text{next[i-1]}next[0]∼next[i-1]，现在想求next[i]\\text{next[i]}next[i]。我们已知s[0]∼s[next[i-1]-1]\\text{s[0]}\\sim \\text{s[next[i-1]-1]}s[0]∼s[next[i-1]-1]和s[i-next[i-1]]∼s[i-1]\\text{s[i-next[i-1]]}\\sim \\text{s[i-1]}s[i-next[i-1]]∼s[i-1]这两段是一样的，如果s[next[i-1]]\\text{s[next[i-1]]}s[next[i-1]]和s[i]\\text{s[i]}s[i]也是一样的，那岂不是很好？如果是这样，next[i]\\text{next[i]}next[i]便等于next[i-1]+1\\text{next[i-1]+1}next[i-1]+1。然而有时候~~（大多数时候）~~事情并没有这么简单。我们悲哀地发现s[next[i-1]]≠s[i]\\text{s[next[i-1]]} \\neq \\text{s[i]}s[next[i-1]]​=s[i]。这时我们怎么去求next[i]\\text{next[i]}next[i]呢？我们经过思考可以发现，s[0]∼s[next[i]-2]\\text{s[0]}\\sim \\text{s[next[i]-2]}s[0]∼s[next[i]-2]和s[i-next[i]]∼s[i-1]\\text{s[i-next[i]]}\\sim \\text{s[i-1]}s[i-next[i]]∼s[i-1]这两段是一样的。那么，这两个公共的前缀及后缀应该也是next[i-1]\\text{next[i-1]}next[i-1]的一个次优解。我们经过探索知道，next[i]\\text{next[i]}next[i]的次优解正是next[next[i]]\\text{next[next[i]]}next[next[i]]。因此，我们的方法是，设一个变量ttt，若s[i]!=s[t]\\text{s[i]!=s[t]}s[i]!=s[t]且t&gt;0t&gt;0t&gt;0，则使ttt不断等于next[t−1]\\text{next[}t-1\\text{]}next[t−1]。直到跳出循环条件，则把next[i]\\text{next[i]}next[i]设为t+1t+1t+1或000。求next[i]\\text{next[i]}next[i]的代码如下。1234567891011121314void get_next(string &amp;s)&#123; int l=s.size(); // l指s的长度 nxt[0]=0; // 0...0没有真前缀/真后缀 for (int i=1;i&lt;l;i++)&#123; //对于[1,l)的每一个字符，计算它的next int t=nxt[i-1]; //t是拟用作next[i]的数据 while (t &amp;&amp; s[i]!=s[t]) //如果t不能用作next[i] t=nxt[t-1]; //就寻找下一个可以用作next[i]的t if (s[t]==s[i]) //这里检查结束循环的原因 nxt[i]=t+1; //如果是因为s[i]==s[t]跳出了循环，就说明t+1可以作为next[i] else nxt[i]=0; //如果是因为t==0跳出了循环，说明next[i]只能是0 &#125;&#125;求next\\text{next}next数组这一最艰巨的任务~~（大雾）已经完成，下面就是比较简单的~~匹配过程了。我们用iii指针代表当前扫描到的主字符串的位置，jjj指针代表当前扫描到的模式串的位置。需要注意的有两点，一是出现失配、jjj指针回退时，一定要注意判断j=0j=0j=0的边界情况，防止死循环；二是如果恰好出现i=len(a),j=len(b)i=\\text{len}(a),j=\\text{len}(b)i=len(a),j=len(b)的情况，应在循环结束后额外判断。最后指出一点，洛谷的模板题实质上是MP\\text{MP}MP算法而不是KMP\\text{KMP}KMP算法，真正的KMP\\text{KMP}KMP还要对next\\text{next}next数组做一些小优化（见这篇题解），但是两者在复杂度上没有差别，因此不再深究。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define MAXN 1000005using namespace std;int nxt[MAXN]=&#123;0&#125;;void get_next(string &amp;s);int main(void)&#123; string a,b; int i,j; int la,lb; cin &gt;&gt; a &gt;&gt; b; get_next(b); la=a.size(),lb=b.size(); i=j=0; while (i&lt;la)&#123; //Ready to match. if (j==lb)&#123; //Match successfully. cout &lt;&lt; i-lb+1 &lt;&lt; endl; j=nxt[j-1]; &#125; //Try to match here! if (a[i]==b[j]) i++,j++; else &#123; if (j) j=nxt[j-1]; else i++; &#125; &#125; //Match successfully at the end. if (i==la &amp;&amp; j==lb) cout &lt;&lt; i-lb+1 &lt;&lt; endl; for (int i=0;i&lt;lb;i++) cout &lt;&lt; nxt[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;&#125;void get_next(string &amp;s)&#123; int l=s.size(); nxt[0]=0; for (int i=1;i&lt;l;i++)&#123; int t=nxt[i-1]; while (t &amp;&amp; s[i]!=s[t]) t=nxt[t-1]; if (s[t]==s[i]) nxt[i]=t+1; else nxt[i]=0; &#125;&#125;等一下，这篇文章还没完！如果KMP\\text{KMP}KMP只能用于字符串匹配，那我还学它干什么！（大雾）KMP\\text{KMP}KMP还有一个重要的应用：求解与恋爱循环有关的问题。假设我们想要求一个字符串的最小循环节，如&quot;abcabcabcabc&quot;的最小循环节是&quot;abc&quot;，“aaaaaaaa&quot;的最小循环节是&quot;a”，朴素的方法应该是进行O(n2)\\text{O}(n^{2})O(n2)的枚举，但是有了KMP\\text{KMP}KMP（的next\\text{next}next数组），O(n)\\text{O}(n)O(n)就可以解决问题！来看一个定理。定理 22.3322.3322.33 恋爱循环定理设一个字符串s[0...n−1]\\text{s}[0...n-1]s[0...n−1]的长度为nnn，如果next[n−1]≠0\\text{next}[n-1]\\neq 0next[n−1]​=0，且(n−next[n−1])∣n(n-\\text{next}[n-1])\\mid n(n−next[n−1])∣n，即n≡0(modn−next[n−1])n\\equiv 0\\pmod{n-\\text{next}[n-1]}n≡0(modn−next[n−1])，那么这个字符串是真循环的（即循环次数大于111），且最小循环节的长度是n−next[n−1]n-\\text{next}[n-1]n−next[n−1]，循环次数是nn−next[n−1]\\frac{n}{n-\\text{next}[n-1]}n−next[n−1]n​。逆命题亦成立，即若一个真循环的字符串s[0...n−1]\\text{s}[0...n-1]s[0...n−1]的最小循环节长度为ttt，则next[n−1]=n−t\\text{next}[n-1]=n-tnext[n−1]=n−t，且有t∣nt\\mid nt∣n。证明：不妨设l=next[n−1]l=\\text{next[}n-1\\text{]}l=next[n−1]，设t=n−lt=n-lt=n−l，设n=kt(k∈N)n=kt(k\\in \\mathbb{N})n=kt(k∈N)。由于l≠0l\\neq 0l​=0，又由next\\text{next}next数组中元素的非负性（即l≥0l\\ge 0l≥0），知t&lt;nt &lt; nt&lt;n。我们又有t∣nt\\mid nt∣n，由整除的性质，我们可以得到n≥2tn\\ge 2tn≥2t，即k≥2k\\ge 2k≥2。由于l=n−t=kt−t=(k−1)tl=n-t=kt-t=(k-1)tl=n−t=kt−t=(k−1)t，我们知道t∣lt\\mid lt∣l。由于ttt是lll和nnn的公因数，我们可以把s[0...n−1]\\text{s}[0...n-1]s[0...n−1]均分成kkk节，每一节的长度都是ttt；也可以把s[0...l−1]\\text{s}[0...l-1]s[0...l−1]（最长公共前缀）和s[n−l...n−1]\\text{s}[n-l...n-1]s[n−l...n−1]（最长公共后缀）均分成k−1k-1k−1节，每一节的长度也都是ttt。下面我们把s[0...n−1]\\text{s}[0...n-1]s[0...n−1]被均分成的kkk节称作a1,a2,⋯ ,aka_{1},a_{2},\\cdots,a_{k}a1​,a2​,⋯,ak​，把s[0...l−1]\\text{s}[0...l-1]s[0...l−1]被均分成的k−1k-1k−1节称作b1,b2,⋯ ,bk−1b_{1},b_{2},\\cdots,b_{k-1}b1​,b2​,⋯,bk−1​，把s[n−l...n−1]\\text{s}[n-l...n-1]s[n−l...n−1]被均分成的k−1k-1k−1节称作c1,c2,⋯ ,ck−1c_{1},c_{2},\\cdots,c_{k-1}c1​,c2​,⋯,ck−1​。由next\\text{next}next数组的定义，我们知道b1=c1,b2=c2,⋯ ,bk−1=ck−1b_{1}=c_{1},b_{2}=c_{2},\\cdots,b_{k-1}=c_{k-1}b1​=c1​,b2​=c2​,⋯,bk−1​=ck−1​。经过仔细比对下标范围~~（其实不那么仔细也可以）~~，我们又发现a1a_{1}a1​和b1b_{1}b1​是同一个字符串（即它们代表着s\\text{s}s字符串中同一个字串，不只是内容相同，位置也完全相同）。经过归纳得出aia_{i}ai​和bib_{i}bi​是同一个字符串，其中i∈{i∈N∣1≤i≤k−1}i\\in \\{i\\in \\mathbb{N} \\mid 1\\le i \\le k-1\\}i∈{i∈N∣1≤i≤k−1}。同理，ai+1a_{i+1}ai+1​和cic_{i}ci​是同一个字符串，其中i∈{i∈N∣1≤i≤k−1}i\\in \\{i\\in \\mathbb{N} \\mid 1\\le i \\le k-1\\}i∈{i∈N∣1≤i≤k−1}。由b1=c1b_{1}=c_{1}b1​=c1​我们知道a1=a2a_{1}=a_{2}a1​=a2​，由b2=c2b_{2}=c_{2}b2​=c2​我们知道a2=a3a_{2}=a_{3}a2​=a3​，由bk−1=ck−1b_{k-1}=c_{k-1}bk−1​=ck−1​我们知道ak−1=aka_{k-1}=a_{k}ak−1​=ak​，因此a1=a2=⋯=aka_{1}=a_{2}=\\cdots=a_{k}a1​=a2​=⋯=ak​。即s[0...t−1]\\text{s}[0...t-1]s[0...t−1]是s\\text{s}s的一个循环节。如何证明这是最小循环节呢？我们考察一个循环字符串，设它的最小循环节为&quot;a&quot;，设&quot;a&quot;的长度为t′t&#x27;t′，那么整个循环字符串可以表示为&quot;aaaa…aa&quot;(kkk个&quot;a&quot;)，则n=kt′n=kt&#x27;n=kt′。容易发现，这个字符串的最长公共前后缀是&quot;aaaa…a&quot;(k−1k-1k−1个&quot;a&quot;)，即l=(k−1)t′l=(k-1)t&#x27;l=(k−1)t′，此时有t=n−l=t′t=n-l=t&#x27;t=n−l=t′，因此我们按照上面的方法计算出的循环节长度ttt和实际最小循环节长度t′t&#x27;t′是相等的，这就说明我们计算出的ttt正是最小循环节长度。循环次数显然为nt\\frac{n}{t}tn​。整理可知，原命题和逆命题都已证毕。下面附一张图以方便理解。现在我们再来解决一个问题。如果一个字符串现在不是真循环字符串，我们现在可以在它的末尾补上若干个字符以使它成为真循环字符串，那么我们至少要补多少个字符呢？这个问题其实也不难。要让它成为真循环字符串，只要让它满足恋爱循环定理的条件即可，即让(n−next[n−1])∣n(n-\\text{next}[n-1])\\mid n(n−next[n−1])∣n成立。很显然，我们应该努力让next[n−1]\\text{next}[n-1]next[n−1]尽量增大，因此我们补的字符应该是最大公共前缀以后的字符，例如&quot;abcabcefgabcabc&quot;的最大公共前缀是&quot;abcabc&quot;，那么我们就应该给它补上&quot;efg&quot;。这么补的结果就是，nnn和lll同时增大相同的数值，于是ttt的值不变。现在问题就转化成：求一个最小的正整数xxx，使得t∣(n+x)t\\mid (n+x)t∣(n+x)。答案很显然，x=t−n%tx=t-n\\%tx=t−n%t。于是我们就知道，至少要补上t−n%tt-n\\%tt−n%t个字符，才能使这个字符串成为真循环字符串。问题解决。总之，KMP\\text{KMP}KMP算法能够快速进行字符串的匹配，而且next\\text{next}next数组也有许多神奇的功能，因此我们应该很好地掌握KMP\\text{KMP}KMP（大雾）。练习KMP\\text{KMP}KMP模板求周期模板题（数据范围比较小，但是可以作为练习）next\\text{next}next数组的应用1（此题使用倍增算法也可以勉强过，这里涉及到一个倍增数组（二维数组）的维数优化技巧。）next\\text{next}next数组的应用2（此题中的周期和上文所述的周期不同。记得开long long\\text{long long}long long！）上述两个next\\text{next}next数组的应用主要是用next\\text{next}next数组遍历所有公共前后缀，即可以把next\\text{next}next数组的内容理解为一棵“公共前后缀树”。","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sweetlemon39.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"KMP","slug":"KMP","permalink":"https://sweetlemon39.github.io/tags/KMP/"}]},{"title":"传递闭包","slug":"transitive-closure","date":"2018-10-16T00:00:00.000Z","updated":"2018-10-16T00:00:00.000Z","comments":true,"path":"transitive-closure/","link":"","permalink":"https://sweetlemon39.github.io/transitive-closure/","excerpt":"什么叫传递闭包“传递闭包”这个名字听起来很吓人，其实它不难理解。给定一个有向图GGG，那么“传递闭包”就是指“图上一点iii能否到达另一点jjj”。","text":"什么叫传递闭包“传递闭包”这个名字听起来很吓人，其实它不难理解。给定一个有向图GGG，那么“传递闭包”就是指“图上一点iii能否到达另一点jjj”。“传递”二字概括了“传递闭包”的意义：描述具有传递性的性质，比如小于关系具有传递性、两非零向量平行（或线性相关）具有传递性，等等。 Floyd\\text{Floyd}Floyd求传递闭包Floyd\\text{Floyd}Floyd是极其著名的最短路算法。既然是最短路算法，那就也可以用来求传递闭包。使用时要把图存在邻接矩阵里。另外要注意循环顺序是k,i,jk,i,jk,i,j。时间复杂度O(n3)\\text{O}(n^3)O(n3)。1234567void floyd(void)&#123; for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (g[i][k] &amp;&amp; g[k][j]) g[i][j]=1;&#125; Floyd\\text{Floyd}Floyd判环这是很懒的一种做法，只需求一遍传递闭包，然后看一看有没有自环既可。时间复杂度O(n3)\\text{O}(n^3)O(n3)。（当然，用dfs\\text{dfs}dfs可以O(n+m)\\text{O}(n+m)O(n+m)，只不过码量稍稍大一点。）123456789101112bool floyd(void)&#123; //Return 1 if circles exist. for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (g[i][k] &amp;&amp; g[k][j]) g[i][j]=1; for (int i=1;i&lt;=n;i++) if (g[i][i]) return 1; return 0;&#125;","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"floyd","slug":"floyd","permalink":"https://sweetlemon39.github.io/tags/floyd/"}]},{"title":"扩展欧几里得算法","slug":"exgcd","date":"2018-08-16T00:00:00.000Z","updated":"2018-08-16T00:00:00.000Z","comments":true,"path":"exgcd/","link":"","permalink":"https://sweetlemon39.github.io/exgcd/","excerpt":"用途求解裴蜀方程ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)的一组解，其中a,b∈N+a,b\\in \\mathbb{N_{+}}a,b∈N+​。","text":"用途求解裴蜀方程ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)的一组解，其中a,b∈N+a,b\\in \\mathbb{N_{+}}a,b∈N+​。 基本原理扩展欧几里得算法基于这样一个原理：若a=bq+r (q∈Z,r∈[0,b)∩Z)a=bq+r\\ (q\\in \\mathbb{Z},r\\in [0,b) \\cap \\mathbb{Z})a=bq+r (q∈Z,r∈[0,b)∩Z)，且有bx′+ry′=(b,r) (x,y∈Z)bx&#x27;+ry&#x27;=(b,r)\\ (x,y\\in \\mathbb{Z})bx′+ry′=(b,r) (x,y∈Z)，则有x=y′,y=x′−qy′x=y&#x27;,y=x&#x27;-qy&#x27;x=y′,y=x′−qy′满足ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)。证明如下：∵bx′+ry′=(b,r) ,(a,b)=(b,r)\\because bx&#x27;+ry&#x27;=(b,r)\\ , (a,b)=(b,r)∵bx′+ry′=(b,r) ,(a,b)=(b,r)∴bx′+ry′=(a,b)\\therefore bx&#x27;+ry&#x27;=(a,b)∴bx′+ry′=(a,b)∵a=bq+r ,x=y′,y=x′−qy′\\because a=bq+r\\ ,x=y&#x27;,y=x&#x27;-qy&#x27;∵a=bq+r ,x=y′,y=x′−qy′∴ax+by=(bq+r)y′+b(x′−qy′)=bx′+ry′\\therefore ax+by=(bq+r)y&#x27;+b(x&#x27;-qy&#x27;)=bx&#x27;+ry&#x27;∴ax+by=(bq+r)y′+b(x′−qy′)=bx′+ry′∴ax+by=(a,b)\\therefore ax+by=(a,b)∴ax+by=(a,b) 计算过程先执行欧几里得算法的一般过程，得到b=0b=0b=0的一步时有平凡解x=1,y=cx=1,y=cx=1,y=c（ccc为任意整数），再依次回代计算xxx和yyy即可。值得注意的是，随着ccc取值的变化，计算出的一组解也会变化。算法的时间复杂度为O(log2n)O(log_{2} n)O(log2​n)。 具体例子aaabbbqqqrrrxxxyyy(a,b)(a,b)(a,b)方程 ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)123451234512345678678678181818141141141101101101−1839-1839−183933312345×101+678×(−1839)=312345\\times 101+678\\times (-1839)=312345×101+678×(−1839)=3678678678141141141444114114114−21-21−21101101101333678×(−21)+141×101=3678\\times(-21)+141\\times101=3678×(−21)+141×101=3141141141114114114111272727171717−21-21−21333141×17+114×(−21)=3141\\times 17+114\\times (-21)=3141×17+114×(−21)=3114114114272727444666−4-4−4171717333114×(−4)+27×17=3114\\times (-4)+27\\times 17=3114×(−4)+27×17=3272727666444333111−4-4−433327×1+6×(−4)=327\\times 1+6\\times (-4)=327×1+6×(−4)=36663332220000001113336×0+3×1=36\\times 0+3\\times 1=36×0+3×1=33330001110003333×1+0×0=33\\times 1+0\\times 0=33×1+0×0=3上述表格的前444列a,b,q,ra,b,q,ra,b,q,r是自上而下计算的，x,y, (a,b)x,y,\\ (a,b)x,y, (a,b)是由下而上递推的。上述a=12345,b=678a=12345,b=678a=12345,b=678的例子中，不断改变ccc的取值，计算出的x,yx,yx,y的值如下表。cccxxxyyy−3-3−3779779779−14184-14184−14184−2-2−2553553553−10069-10069−10069−1-1−1327327327−5954-5954−5954000101101101−1839-1839−1839111−125-125−125227622762276222−351-351−351639163916391333−577-577−577105061050610506上表相邻两行xxx的差为226226226，恰为678(12345,678)\\frac{678}{(12345,678)}(12345,678)678​；yyy的差为411541154115，恰为12345(12345,678)\\frac{12345}{(12345,678)}(12345,678)12345​。 解的特征下面分析ccc的取值对解的影响。可以证明，若令取c=0c=0c=0时计算出的一组解为(x0,y0)(x_{0},y_{0})(x0​,y0​)，且辗转相除过程中进行除法运算的次数为nnn，则计算出的解为x=(−1)n+1cb(a,b)+x0,y=(−1)nca(a,b)+y0x=(-1)^{n+1}c\\frac{b}{(a,b)}+x_{0},y=(-1)^{n}c\\frac{a}{(a,b)}+y_{0}x=(−1)n+1c(a,b)b​+x0​,y=(−1)nc(a,b)a​+y0​。再来看解的符号。x0x_{0}x0​的符号和(−1)n(-1)^{n}(−1)n相同，y0y_{0}y0​的符号和(−1)n+1(-1)^{n+1}(−1)n+1相同。当c&lt;0c&lt;0c&lt;0时，x,yx,yx,y的符号分别和x0,y0x_{0},y_{0}x0​,y0​相同；当c&gt;0c&gt;0c&gt;0时，x,yx,yx,y的符号分别和x0,y0x_{0},y_{0}x0​,y0​相反。 程序代码下面程序中取c=0c=0c=0，即上表的情形。实际编写程序时只需使用工具函数exgcd(a,b,x,y)即可。12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y);int main(void)&#123; int a,b,d,x,y; cin &gt;&gt; a &gt;&gt; b; d=exgcd(a,b,x,y); cout &lt;&lt; \"裴蜀方程\" &lt;&lt; a &lt;&lt; \"x+\" &lt;&lt; b &lt;&lt; \"y=\" &lt;&lt; d; cout &lt;&lt; \"的一组解是\" &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; \"y=\" &lt;&lt; y &lt;&lt; endl; return 0;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; int xx,yy,d,q,r; //xx是x',yy是y',d是(a,b) if (b==0)&#123; x=1,y=0; return a; &#125; q=a/b,r=a%b; //a=bq+r d=exgcd(b,r,xx,yy); x=yy,y=xx-q*yy; return d;&#125;","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"gcd","slug":"gcd","permalink":"https://sweetlemon39.github.io/tags/gcd/"}]},{"title":"朝花中学OI队的奋斗历程——浅谈单调队列","slug":"monotonous-queue","date":"2018-07-15T00:00:00.000Z","updated":"2018-07-15T00:00:00.000Z","comments":true,"path":"monotonous-queue/","link":"","permalink":"https://sweetlemon39.github.io/monotonous-queue/","excerpt":"问题背景朝花中学是市里有名的OI强校，每年朝花中学都要选一名队员代表学校参加市里的OI联赛，这名参赛队员可从初一到高二的所有选手中选拔（高三不能比赛……）。校队教练nomelteews想要给这些高手更好的培养机会，于是决定成立朝花集训队，给予集训队里的选手以特殊指导，并直接从集训队中选队员参加联赛。","text":"问题背景朝花中学是市里有名的OI强校，每年朝花中学都要选一名队员代表学校参加市里的OI联赛，这名参赛队员可从初一到高二的所有选手中选拔（高三不能比赛……）。校队教练nomelteews想要给这些高手更好的培养机会，于是决定成立朝花集训队，给予集训队里的选手以特殊指导，并直接从集训队中选队员参加联赛。为了保证教学效果，nomelteews要始终让集训队的总人数最少，但每年比赛时又必须从队里挑出全校最强的队员参赛。nomelteews每年只能从初一新生中选拔集训队新队员，那么，应吸纳哪些人入队呢？ 问题思路nomelteews每年对申请入队的初一新生进行一次综合能力测评，以测评成绩作为判断OI能力强弱的依据。下面是部分测评成绩表。年份姓名成绩2012evets4502013ayohs4202013ugoul5202013anuzan3502014ikat5002014xela4602015okohs4802015repeerc4002016ahustim4802016umier4402017amnem4702017natnij4302018ukim4602018ilib450最简单的想法就是——让所有人入队！但是这显然不能满足总人数最少的要求。进一步的想法是，让每年成绩最好的人入队。例如2013年的3名选手中，ugoul的成绩最好，就在这三人中选ugoul入队。理由是，只要是ayohs和anuzan能参加的比赛，ugoul也能参加；而ugoul的能力比ayohs和anuzan都强，所以有理由淘汰ayohs和anuzan。那么按这个思路，剩下的人就是：年份姓名成绩2012evets4502013ugoul5202014ikat5002015okohs4802016ahustim4802017amnem4702018ukim460这样队里最多同时有5人，每年最早入队的人会退役，参加比赛时只要从5人中找出能力最强的人就好了，看起来效率相当不错。那么，队的人数能不能更少呢？一个大胆的想法是，只留当前遇到的最强的队员在队里！那么队里的情况就是：年份队员成绩2012evets4502013-2017ugoul5202018ukim460然而，如果按这个标准选拔，由于最强的ugoul必须在2017年末退役，因此2018年的比赛只能由当年最强的ukim（460分）来比赛。按照上一个方案，2018年的比赛可以由ikat（500分）参赛，显然如果采用这个方案，最强的队员退役后会造成尴尬局面。还有什么办法吗？大自然的法则——优胜劣汰也许能给我们一点启示。我们来一年一年看。2012年，只有evets申请入队，无疑只能让evets一人进队。那么2012年的比赛当然就由他来参加啦！入队年份队员成绩参赛(*)2012evets450*2013年，当年最强的是ugoul。此时，我们可以淘汰evets。为什么呢？2013年以后，evets只能参加20132016年的比赛，而ugoul却能参加20132017年的比赛，也就是说凡是evets可以参加的比赛，ugoul都可以参加；而ugoul又比evets强，因此淘汰evets。当年的比赛由ugoul参加。入队年份队员成绩参赛(*)2013ugoul520*2014年，当年最强的是ikat。ikat没有ugoul强，他能不能入队呢？我们来看：ugoul能参加20142017年的比赛，而ikat能参加20142018年的比赛，ikat能参加的比赛比ugoul多，因此仍要接纳ikat入队。事实上，根据我们先前的判断，2018年的比赛是要由ikat参加的。但是2014年的比赛还是要由队里最强的ugoul参加。入队年份队员成绩参赛(*)2013ugoul520*2014ikat500 2015年，类似以上讨论，okohs可以入队。而当年的比赛仍然由ugoul参加（队霸大佬）。入队年份队员成绩参赛(*)2013ugoul520*2014ikat500 2015okohs480 2016年，ahustim（480分）入队。她要淘汰okohs，因为okohs她虽然能力和ahustim相同，但是比ahustim早退役（还是那句话，凡是okohs能参加的比赛ahustim都能参加），因此okohs只好提前退役了。当年的比赛由ugoul参加。入队年份队员成绩参赛(*)2013ugoul520*2014ikat500 2016ahustim480 2017年队里的情况如下：入队年份队员成绩参赛(*)2013ugoul520*2014ikat500 2016ahustim480 2017amnem470 到了2018年，队里的情况有变——ugoul退役了！这样当年的比赛就要让ikat参加了。当年情况如下：入队年份队员成绩参赛(*)2014ikat500*2016ahustim480 2017amnem470 2018ukim460 问题总结仔细观察这些表格，我们发现，这些表格具有以下特点：①每年只有一人入队；②队里队员的成绩总是随着年份的增加而单调递减；③每年总是由最老的队员（当然也是最强的）参赛；④每年只有最多1人——最老的队员退役。这个集训队其实具有类似（双端）队列的结构——每年新队员加入时从队尾淘汰，从队尾入队；每年参赛时取队头；每年退役时只有队头退役；而它又具有单调递减的特殊性，因此我们把这样的队列称为单调队列。单调队列有什么作用呢？它可以解决下面被称为“滑动窗口”的问题。如下图，给出一个长度为n的序列A，求A中所有长度为m的连续子序列的最大值。下图中假设n=7，m=3。这题只需枚举每个连续子序列，使用单调队列得出最大值即可。我们看看单调队列是怎么工作的。这个集训队每年在做的事情就是单调队列的操作。入队/滑动窗口右滑。每年选拔新队员时，淘汰比这名新队员弱的老队员。对于单调队列，就是插入新元素时，把先前存在的比当前元素小的元素弹出（从队尾退队）。退役/滑动窗口右滑。只需判断最老的队员是否需要退队。对于单调队列，只需判断队头是否已经超出滑动窗口范围，若超出，则从队头退队。参赛/查询滑动窗口最大值。直接派最老的队员参赛/直接返回队头元素。我们手工模拟一下这个单调队列的工作过程吧（如下表）！时刻入队元素入队后队列最大值155-235 3-325 3 25413 2 13502 1 0267777888分析单调队列的时间复杂度，每个元素最多入队1次、出队1次，且出入队都是O(1)的，因此这是一个总时间O(n)的算法。这样相对高效的算法，能为我们解决动态规划问题提供有力的优化，例如NOIP 2017普及组的第4题就可以使用单调队列，此处不再叙述，如果有兴趣可以在理解单调队列的概念后看一看题解。 代码实现单调队列可以用STL的deque实现，也可以手写数组实现。由于每个元素最多入队一次、出队一次，手写数组的大小只要和原数组一样就可以了（也就是和元素总数相等即可）。下面分别给出deque实现和数组实现的C++代码，输入输出格式见单调队列模板题P1440 （当然这题也有其他不错的解法）。与上述讨论不同的是，本题输出的是滑动窗口内的最小值。两种实现效率比较：总时间 deque 1660ms，deque(O2) 1100ms, 手写数组实现 908ms。看来有时还是需要手写数组的！12345678910111213141516171819202122232425262728293031323334353637383940//deque实现#include &lt;cstdio&gt;#include &lt;queue&gt; // 提供deque#define MAXN 2000005using namespace std;struct Num&#123; int index,x;//需要记录单调队列内每个数的入队时间(index)和大小(x)&#125;;int a[MAXN]; //原数组deque&lt;Num&gt; q; //单调队列 int main(void)&#123; int n,m; //n表示序列长度，m表示滑动窗口长度 Num t;//保存当前元素 //输入 scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); //问题解决 for (int i=1;i&lt;=n;i++)&#123; //先输出数a[i]前的最小值 if (q.empty()) //q空，即a[i]前没有元素 printf(\"0\\n\"); else &#123; //否则判断队头是否需要出队并输出范围内的队头 if (q.front().index+m&lt;i) //队头已经超出滑动窗口范围 q.pop_front(); // 弹出队头 printf(\"%d\\n\",q.front().x); //此时队一定非空（想想为什么） &#125; while ((!q.empty()) &amp;&amp; q.back().x&gt;=a[i]) //当队列非空时，不断弹出队尾比当前元素大的元素 q.pop_back(); t.index=i; t.x=a[i]; q.push_back(t);//将当前元素入队 //注意：当前元素无论如何都会入队（想想为什么） &#125; return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041//数组实现#include &lt;cstdio&gt;#define MAXN 2000005using namespace std;struct Num&#123; int index,x;//需要记录单调队列内每个数的入队时间(index)和大小(x)&#125;;int a[MAXN]; //原数组Num q[MAXN]; //单调队列 int main(void)&#123; int n,m; //n表示序列长度，m表示滑动窗口长度 int front,back; //front,back分别表示队头、队尾位置 //输入 scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); //问题解决 front=1; back=0;//初始化队头队尾位置，队头&gt;队尾表示队空 for (int i=1;i&lt;=n;i++)&#123; //先输出数a[i]前的最小值 if (front&gt;back) //q空，即a[i]前没有元素 printf(\"0\\n\"); else &#123; //否则判断队头是否需要出队并输出范围内的队头 if (q[front].index+m&lt;i) //队头已经超出滑动窗口范围 front++; // 弹出队头 printf(\"%d\\n\",q[front].x); //此时队一定非空（想想为什么） &#125; while (front&lt;=back &amp;&amp; q[back].x&gt;=a[i]) //当队列非空时，不断弹出队尾比当前元素大的元素 back--; back++; q[back].x=a[i]; q[back].index=i;//将当前元素入队 //注意：当前元素无论如何都会入队（想想为什么） &#125; return 0;&#125; 练习与最后的废话涉及单调队列的题目直接在洛谷搜索就可以找到一些,这两题（P1886 滑动窗口和P1440 求m区间内的最小值）是模板题。（但是“P2952 牛线”不是单调队列的题目！）其实多重背包问题（有nnn种物品，每种物品有aia_{i}ai​个，每种物品的价值为wiw_{i}wi​，每种物品的体积为viv_{i}vi​，现有一个容量为CCC的背包，要求装进背包里的物品的总体积不超过CCC，求装入背包的物品的总价值的最大值）的优化也可以用到单调队列，使用后时间复杂度变为O(VN)。可参考这篇文章。其实朝花中学有必要考虑换个教练了～大家有没有发现，这个教练有两个问题：其一，进队后队员的水平并没有得到提升，和刚进队时完全一样；其二，招来的队员水平在单调递减……相比之下，我们都是幸运的。朝花中学队员们的水平在入队后就无法改变，而我们在加入了OIer的队伍后，依然可以通过学习，不断提高自己的知识水平。因此，我们真的要珍惜学习的机会啊！最后还是祝愿大家成为像ugoul一样的队霸大佬！","categories":[{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法浅解","slug":"算法浅解","permalink":"https://sweetlemon39.github.io/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"},{"name":"单调队列","slug":"单调队列","permalink":"https://sweetlemon39.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"曾经的离别","slug":"retirement-speech","date":"2018-04-01T00:00:00.000Z","updated":"2018-07-08T00:00:00.000Z","comments":true,"path":"retirement-speech/","link":"","permalink":"https://sweetlemon39.github.io/retirement-speech/","excerpt":"若洛谷是一条优美的山谷，百花盛开，姹紫嫣红，百鸟齐鸣，悦耳动听，我愿永远徜徉在山谷里，享受美好的Coding life，像其他世界的朋友们一样，永远微笑，把手伸向碧蓝的天空……","text":"若洛谷是一条优美的山谷，百花盛开，姹紫嫣红，百鸟齐鸣，悦耳动听，我愿永远徜徉在山谷里，享受美好的Coding life，像其他世界的朋友们一样，永远微笑，把手伸向碧蓝的天空……而现在，我要暂时离去，希望这美丽的山谷永远印在我的脑海里，刻在我的心上。明年六月，愿我们重逢！Your sincerely,Sweetlemon","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"退役","slug":"退役","permalink":"https://sweetlemon39.github.io/tags/%E9%80%80%E5%BD%B9/"}]},{"title":"那个世界的你，比这个世界的我，更重要……","slug":"you-are-more-important","date":"2018-01-07T00:00:00.000Z","updated":"2018-01-07T00:00:00.000Z","comments":true,"path":"you-are-more-important/","link":"","permalink":"https://sweetlemon39.github.io/you-are-more-important/","excerpt":"序幕不知什么时候，感觉自己好像已经来到了另一个世界中呢~","text":"序幕不知什么时候，感觉自己好像已经来到了另一个世界中呢~ 绪端梦里，朦胧的是你的身影；早晨，湛蓝的是你的天空；黄昏，灿烂的是你的晚霞；深夜，轻笑的是你的明月。每个世界都有许多相似之处，或许，正是那个世界的你来到了我身边吧！眼前的一切，与梦中重合……走在城市中央，房屋高耸；望向宁静远方，山峦连绵；凝视深邃夜空，繁星闪耀。身边的一切，与梦中重合……我在奔跑，你也在奔跑；我在改变，你也在改变；我在寻找，你也在寻找。 幸运的我们那个世界很美好，你很幸运。你幸运，你是善良的，总能平和对待身边的一切；你幸运，你是坚毅的，从不畏惧任何困难与挫折；你幸运，你是乐观的，恒以微笑欣赏自己和伙伴。你幸运，你有一群并肩奋斗的挚友，你珍惜爱。这个世界也很美好，我同样很幸运。我幸运，我拥有一个健康的身体，能够欣赏眼前的多彩（即使不是特别清晰），能够聆听耳边的妙音，能够充满活力地奔跑。我幸运，我生活在一个美好的家庭，不需要为生存而忧愁，能够让我拥有良好（至少是较好吧）的品格，能够让我看到梦想和未来。我幸运，我生活在一个安全的环境，没有突如其来的灾难，同伴们可以和谐共处，我心中充满爱。我幸运，我生活在一个强大的祖国，我能够坦然地面对历史，没有沉重的负担，我能够自豪地看待现实，没有恐惧和慌张，我能够充满希望地憧憬未来。这个世界，不，一切世界，至少在这个时代，没有不幸，只有幸运和另一种幸运。假如生活欺骗了你，这一定是个善意的谎言。如果你遇到困难，如果我遇到困难，笑笑吧；你会给我力量，我也会给你力量。 与你相遇你和我，生活在不同的世界里，也许如异面直线，永远不会相交，也许却处处都是你的投影。每当我获得赞美，每当我遇到困难，或喜或悲，想想那个世界的你，我的这些又算得了什么呢？你依旧在那里，笑着，等着我。是的，那个世界的你，比这个世界的我，更重要……而我呢？我会努力奋斗，我会坚强奔跑，我会追逐梦想，在这个世界上留下灿烂的印迹；到了那时，只要你一笑，我便满足了。 在你身边你，在身边，微笑地看着我；我，在路上，等着你的笑容。","categories":[{"name":"穿透世界边缘的呐喊","slug":"穿透世界边缘的呐喊","permalink":"https://sweetlemon39.github.io/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/"}],"tags":[{"name":"世界间绪论","slug":"世界间绪论","permalink":"https://sweetlemon39.github.io/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E7%BB%AA%E8%AE%BA/"}]},{"title":"《你的名字。》影评——初见的时候","slug":"your-name-review","date":"2017-02-19T00:00:00.000Z","updated":"2018-01-07T00:00:00.000Z","comments":true,"path":"your-name-review/","link":"","permalink":"https://sweetlemon39.github.io/your-name-review/","excerpt":"原题：好片，推荐！仔细揣摩人物形象和故事情节原发布时间：2017-02-19 10:59:01原文链接：君名影评原文","text":"原题：好片，推荐！仔细揣摩人物形象和故事情节原发布时间：2017-02-19 10:59:01原文链接：君名影评原文归档注释：这是我近一年前的心血。一年前，在我还不认识你的时候，你来看我了吧！珍惜我们初见的时候。小标题为归档时所加。 序·我与君名我看一些电影，看完总是会意犹未尽，非常羡慕电影中的主人公。比如看《2012》，就想像着自己也是驾驶诺亚方舟的一人；看《火星救援》，就想玩火箭发射游戏；这回，我便十分欣赏电影中主人公的纯洁情感(我在故意避开某个词，因为我觉得，用它来叙述不符合影片主调)……开学前看的电影，看完总有点“陶醉”，前天早上看完后晚上又看了一部分，昨天早上终于看完了第二遍。每一次看完，总觉得，生活真美好！但又有了不知何处而来的忧郁。昨天晚上，躺在床上，想着，如果交换的事情发生在我身上，会怎样？我是不是不够勇敢、不够坚强……终于困难地入睡了。然而，今天凌晨4:00，我又醒了。一醒来，满脑子都是君名里的事。看着那城市里无尽的夜，无法重新睡着，便反复回想电影里的情节和人物。终于熬到早上(中间无数次,恐惧袭来)，打开电脑，有感而发，于是有了这篇影评。看着这部电影时，我真的没有哭。可是回想着情节，竟有眼泪流出。这部电影在我心中久久不去，不给五星真的不可能。 原来，你是这样先分析一下人物形象吧。泷是一名普通中学生。他其实:很可爱(也许不是通常的意思,我指的是令人、使人喜欢,特别是当我看到他和三叶在暮色中(实在想不起那个专有名词了)相遇时,他因为身体接触(具体略)而道歉的场景,还有他对着给他便当的司机的车鞠躬的场景)；很纯洁(我看到他(她?)说,“我这样对她不太好吧”,便以为他真的不会这么做了,可惜他还是忍不住…唉,不希望这样的事情反复发生啊~这点也许只是我对他的期盼罢了…)；很勇敢(他在雷雨中上山,描画着地图,当时我就很怕他会被雷击,但我想他不怕;他来到彼岸(underworld),进入(用词也许不妥)神体,想要用三叶的齿酿酒救三叶;还有最后,那一声&quot;Hey&quot;,讲笑,如果没有这一点,我们要寄刀片了(其实我有点笑不出来,沉浸……))；很坚毅(为了一个梦,为了拯救梦中的你,不放弃任何希望)；很勤奋(在电车上背英语……)；很帅气(呃,这个是真的,但是没有什么意义是吧~)。综上所述，我做不到。但是，他确实可以激励我！三叶也是一名普通中学生。她其实：很坚强(受着种种不公的待遇,被无数次嘲笑,却能忍着;在摔倒时,看了看手心,即使不知道梦中的你的名字,但是,不会放弃)；情感丰富(她帮泷追奥寺,想到他们能见面,“他真幸运啊”,却默默流泪;到东京去找2013年的泷,却不被那时的泷认出,下车那一刻真感人!不过这是一个时间的无限循环,如果泷没有绳结,就不能和三叶会面,这解释不通的,只能说是缘分了!)；很坚贞(没想到其他合适的词,语文白学了;当然,这是指她长达8年的等待和8年的泪水…想想都心酸,假设人均寿命80岁,那8年可是生命的十分之一啊!)很漂亮(呃,这个也是真的,但还是没有什么意义是呵?)综上所述，我做不到。但是，她确实也可以激励我！(此处注:做不到是指优良品质,不是别的,这里没有矛盾。)两人的共同特点,都深爱,都敢爱!爱，是影片的主题。爱能穿越一切,时间、空间、甚至两者…… 关于名字“名字”是影片的线索，政治课本上说过，名字是区分人和人的文字符号，是人格的标志。可是，我们可能都有疑问:为什么泷和三叶在相遇后都忘记了对方的名字呢?为什么泷只写了“我喜欢你”却没有写上自己的名字呢？前一个问题，我的倾向是，由于进入了underworld，要想回到人世就必须留下自己最重要的东西，在此时，他们心中最重要的(重要的、不想忘记的、不能忘记的)就是对方的名字了，因此无疑会失去。这印证了两人对彼此的爱之深，在此处染上了一层悲情色彩，十分令人感动。后一个问题，我认为，也许泷已经知道，名字是无法留住的。他要帮助三叶树立信心，拯救三叶，就必须抓住这个机会，表白自己心中的情感。这一点也在后来三叶摔倒后毅然爬起得到印证。如果写的只是名字，她或许没有这么充满希望。当然，从艺术角度来讲，这当然是要一波三折，牵动观者心弦。 关于相遇也许整部影片，最感人的莫过于暮色相遇和三叶的奋斗了。错过。等待。从细节总能看出，他们两人虽然don’t remember,can’t remember(忘记了,没能记住)对方的名字，但是，他们都没有忘记对方！开头他们的流泪(当在等待的5/8年中)，5年后穿着西装的泷仍然看了看右手，还有那一次又一次的电车上目光相遇……还有最后再楼梯上重逢的那一刻。两人同时问对方，“你的名字是……”，同时镜头抬高，摄向蔚蓝的天空；片名再次出现，片尾曲响起。这里是片末点题，虽然也许能猜得到，但是还是收获了出人意料的感人效果。相隔那么多年，终于……影片没有继续下去，我想足够了。也许接下去会有更甜蜜的内容，也是我们所期盼的，但是，在这里戛然而止，恰到好处，更引起了我的无尽遐想。 Time Fliers的时间影片的时间线很乱。这一方面由于这里涉及到众多穿越时空的内容，另一方面又是由于这样更能娓娓道来，让情感由浅入深，渐渐推向高潮。如果你没有看懂，建议可以看网上一些朋友们整理的时间线，并反复看影片，多暂停(虽然这样情感效果不好,但是可以增强理性效果)，相信你会明白的。 文化背景影片当中提到了不少日本的传统文化。看完影片后有不少人购买了这些周边，当然我不反对(尽管我没有计划买)，这是自己对影片中主人公喜爱的自然流露，但是，我们如何对待自己的传统文化？引人深思。影片的背景音乐很不错，无论是歌曲还是纯音乐，对气氛的渲染、情感高潮的形成帮助很大。另外推荐一首Minecraft歌曲《Find the Pieces》，也是讲寻找的故事的，很感人，感兴趣可以去B站看看，它的歌词简直可以套进君名里。 再提我与君名整个人简直迷乱，也许这就是传说中的“毒”吧。从前总觉得这种影片不值得一看，春节时说要去看电影，还特意避开这部；一个同学说这里面有些关于时空的内容，我便感兴趣看了，没想到如此震撼。理性的东西没能吸引到我，但是很明显，我的感情被深深影响了。唉，真不可貌相啊！看来，我真的欠一张电影票。这样，可不就无法弥补了吗？影评思路很乱。原谅我罢，我的心也很乱啊！这就是“此中有真意，欲辨已忘言”吧。 你来了，告诉我……最后，谈谈我的体会。一是，很多时候要大胆，错过的机会，很有可能就不会再来了(指结尾)。我甚至想出了一个悲剧式结局，两人在楼梯错过了，当天晚上做了梦，在梦中忆起对方的面容，惊问：“你的名字是？！”却得不到回答，只剩眼泪……二是，珍惜生活！珍惜现在！我们生活的城市/乡村至少现在还存在着，也许在我们心中还是有纯真的感情，那么，珍惜吧！——谨以此影评送给开学几小时前的自己。愿生活美好。 最后的补充P.S. 本来挺想PS一下电影的海报的，可是看了之后再也没有了这念头。P.P.S 很犹豫是否要让父母知道我看了这部影片。因为确实有感欲发，却又担心。一是内容、情感，二是某些身体接触情节。P.P.P.S 真的是非常激动了，刚刚去Word一看，飙了两千五百多字。唉，心中有梦，诉说吧！但愿我还能够坚持自己，过自己的生活。 跋·君名与我解决一下正文中的一些问题吧，毕竟近一年前的文章了……上述对人物形象的分析显得很粗拙，毕竟是缺乏讨论的，很多地方有待商榷。还有，我与父母一同观看了这部影片，他们似乎不为所动，但是，或许这已经唤醒了他们年少时的梦呢？真的很怀念那种初见的感觉啊！","categories":[{"name":"穿透世界边缘的呐喊","slug":"穿透世界边缘的呐喊","permalink":"https://sweetlemon39.github.io/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/"}],"tags":[{"name":"世界间评论","slug":"世界间评论","permalink":"https://sweetlemon39.github.io/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E8%AF%84%E8%AE%BA/"},{"name":"你的名字","slug":"你的名字","permalink":"https://sweetlemon39.github.io/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/"}]}]}