{"meta":{"title":"Sweetlemon 的异世界","subtitle":"原来你也在这里啊","description":"","author":"Sweetlemon","url":"https://sweetlemon39.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-03-03T14:21:31.416Z","updated":"2020-03-03T14:21:31.416Z","comments":true,"path":"404.html","permalink":"https://sweetlemon39.github.io/404.html","excerpt":"","text":"404非常抱歉，这个页面落在世界的缝隙里"},{"title":"关于","date":"2020-03-03T14:21:31.420Z","updated":"2020-03-03T14:21:31.420Z","comments":true,"path":"about/index.html","permalink":"https://sweetlemon39.github.io/about/index.html","excerpt":"","text":"Sweetlemon标签苟延残喘的高二狗不务正业的 OIer杂牌数竞生碎叶愿你在那个世界安好！我在这里等你。多对这个世界笑笑吧，世界也会对你笑呢~"},{"title":"所有分类","date":"2020-03-03T14:21:31.420Z","updated":"2020-03-03T14:21:31.420Z","comments":true,"path":"categories/index.html","permalink":"https://sweetlemon39.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-03T14:21:31.420Z","updated":"2020-03-03T14:21:31.420Z","comments":true,"path":"comments/index.html","permalink":"https://sweetlemon39.github.io/comments/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-03-03T14:21:31.420Z","updated":"2020-03-03T14:21:31.420Z","comments":true,"path":"friends/index.html","permalink":"https://sweetlemon39.github.io/friends/index.html","excerpt":"朋友们的博客链接。","text":"朋友们的博客链接。"},{"title":"所有标签","date":"2020-03-03T14:21:31.420Z","updated":"2020-03-03T14:21:31.420Z","comments":true,"path":"tags/index.html","permalink":"https://sweetlemon39.github.io/tags/index.html","excerpt":"","text":""},{"title":"常用站导航","date":"2020-03-01T00:00:00.000Z","updated":"2020-03-02T00:00:00.000Z","comments":true,"path":"useful-links/index.html","permalink":"https://sweetlemon39.github.io/useful-links/index.html","excerpt":"","text":"Online Judge洛谷Codeforces（主站）Codeforces（m2）Codeforces（镜像）UOJLOJAtCoderBZOJdarkBZOJVJudge比赛CCF NOIUSACOCOCI资料OI Wiki洛谷日报（2018） 洛谷日报（2019） 洛谷日报（2020）"}],"posts":[{"title":"THUWC 2020 游记","slug":"THUWC-2020","date":"2019-12-25T00:00:00.000Z","updated":"2019-12-25T00:00:00.000Z","comments":true,"path":"THUWC-2020/","link":"","permalink":"https://sweetlemon39.github.io/THUWC-2020/","excerpt":"THUWC 2020 (2019?) 游记","text":"THUWC 2020 (2019?) 游记Day $-?$THUWC 恰好在学考后一周，因此考完学考就进入了紧张的准备摸鱼中。停了两天课，还错过了学校里 IMO 二度金牌爷的讲座。停课前打 USACO，在一道区间 dp 上卡了 3 h，最后交了一个假做法强行把那道题过了，剩下的就没有时间写了；后来发现 T2 是一道还比较可做的树上问题，没写有点亏了。停课的时候打了 Codeforces 的一场 Virtual Contest，感受了很神奇的暴力；又做了 COCI 的 Contest 3，感觉比去年的 COCI Open 难多了，竟出现了代码极长的淀粉质，直接放弃实现了。感觉写的题目还是不够多，似乎本来可以写更多的题的。Day $-1$为了机票便宜先到 TJ 中转。零下的温度感觉确实比较冷，但是也没有预想中那么冷？需要穿的衣服居然没有超过 $3$ 件。飞机上凭印象写了 NTT，居然默写正确了。总感觉休息不足，非常困的样子。Day $1$Day 1 要从 TJ 出发，体验了一下复兴号的城际列车，确实比 D 字头的车快了不少。接着乘地铁去报到，发了一个有花纹的布制品，本以为是格子衫，仔细一看，“精品围巾”。嗯，说实话出于某种原因我还是比较想要红色的围巾（bushi。报到完就试机，这回是在系里的实验室考，电脑的系统似乎是 XUbuntu，不支持 Ctrl-Alt-T 打开终端似乎有些不习惯。看了看电脑里奇怪的软件，似乎只有 GIMP, Golden Dict 这两个，考虑到去年刚考图像，难道这回要考嘤语？桌面上还有 en.cppreference，难道要考毒瘤语言特性？反正根据这些信息，暂时猜不到 Day 3 考什么。注：题意简述可以在 ouuan 的博客 找到。试机试机 T0 是 A+B，打了快读把它过了。T1 是一个有点奇怪的题目，大概是说有 $n$ 个 A 类物品，权值分别为 $a_1,a_2,\\cdots,a_n(a_i\\in \\mathbb{Z})$；有 $m$ 个 B 类物品，权值分别为 $b_1,b_2,\\cdots,b_m(b_j\\in \\mathbb{Z})$。现在请你把这些物品从左到右排列成一排，计算总权值如下：对于每一个物品，如果它左边的物品与它同类，那么它对总权值的贡献即为 $a_i$ 或 $b_j$；否则它对总权值没有贡献。特别地，最左边的物品对总权值没有贡献。要求总权值的最大值。似乎是一个奇怪的贪心，花了一些时间想，最后玄学地通过了。T2 好像是一道奇怪的树上计数题，模数是 $998244353$，而且旁边的选手还嚷嚷着让他的同学帮他调 NTT……看来这题不可做，直接跳了吧。T3 是一道字符串，给一个字符串 $A$ 和 $q$ 个字符串 $B_i$，要把 $B$ 插入到 $A$ 的某一个地方（比如 $A=abc,B=de$，那么可以得到 $deabc,adebc,abdec,abcde$ 这些），求插入到哪里时得到的字符串字典序最小。照例是不会做，所以直接用 string 打了暴力，居然拿了 $40$ 分？虽然试机有好多不会，但是反正也不太在意吧，所以也没有影响心态。中午急忙吃完饭，就回去合影和开幕式了。合影意外地没有拖太久，开幕式也进行得极快，“讲 $8$ 点”值得好评。于是就到考场就位，略作等待之后，Day 1 就正式开始了。Day 1 T1一道很有意思的题目。首先写了暴力，交上去拿点分爽一爽。因为觉得题目情景不复杂，所以便思考正解。我思考的点是“预处理当前工资计划是 $i$ 时，最终的工资计划应该是什么”，由于 $k$ 很小，因此对每一个员工弄了一个单调队列，在单调队列上二分。后来发现这样确实可以通过，而且预处理时怎么做，查询时也相应地怎么做。于是花了约 $1 \\mathrm{h}$ 愉快地通过了。Day 1 T2一道比较恶心的题目。首先把比较容易的分数写了，接下来的却没有可以快速实现的思路了，于是决定去写 T3。Day 1 T3首先把送的 $8$ 分拿到了，接着又陷入了长时间而无效的思考中……据说北方冬天开了暖气的室内比较催眠，这是真的。再加上昨天晚上不适应这里的环境没有睡好，所以真的是越想越想睡。强行去洗了洗脸，好不容易清醒了。回来看看还剩下的许多时间，决定回去写 T2。T2 有一个“树”的 $13$ 分，似乎可以用树剖暴力地解决掉。再看一眼时间，写吧。于是开始写树剖、线段树。时间过得很快也很慢，我不停地写啊写啊，简直都不知道自己在写什么。dfs1, dfs2, build_tree, pushdown, … 终于似乎是写完了，我甚至都不想再看代码，直接跑样例。修改了一点小的错误后，过了样例。直接交！猛按几下 F5 过后，那个测试点旁边显示出了 Accepted 的文字。什么？我默写的树剖就这么通过了？我不放心地再浏览了一遍代码，找不出明显的问题，才终于判定——树剖应该是写完了。这是我 OI 生涯中至今考场上写的最长的代码了吧，总长度近 $400$ 行，大小近 $10 \\mathrm{KB}$，可惜不能带回去纪念。还剩大约半个小时，剩下的点似乎怎么也过不了，T3 也毫无思路。最后在玄学修改程序中度过消磨了最后半个小时。Day 1 总结Day 1 的话题目确实超出了我的水平范围吧，不过好在我在 $2.5\\mathrm{h}$ 时放弃 T3，并决定去写树剖，否则后半段真的要一无所获了。Day 2早上早起到西郊宾馆吃了早餐，种类还算比较丰富，大吃一顿后上了大巴。大巴上照例听了 Euphoria。同样稍作准备后就开考了。Day 2 T1一道比较神奇的题目。有 $n(1\\le n\\le 15)$ 个函数 $f_1,f_2,\\cdots,f_n$，每个函数形如 $f_i(x)=a_i\\vert x \\vert+b_ix+c_i$，给定初始值 $x$，你需要安排函数复合的顺序，使得最终函数值最大；也就是你需要给出 $1\\cdots n$ 的一个排列 $p_1,p_2,\\cdots,p_n$，使得 $f_{p_n}(f_{p_{n-1}}(f_{p_{n-2}}(\\cdots(f_{p_1}(x)))))$ 最大。$x,a_i,b_i,c_i\\in [-15,15]$，允许使用 __int128。首先还是写了 $n\\le 10$ 的枚举暴力。接着注意到 $n$ 很小，回想到我在 THUSC 2019 吃的亏，考虑状压 dp。状压 dp 要满足子问题最优特性，为了满足这一点，我在草稿纸上画了一下函数的图象，发现 $f_i$ 一定是拐点在 $y$ 轴上的一条折线，在 $y$ 轴两侧都是单调的。因此，使得 $f(x)$ 最大的 $x$ 只有四种可能：最大的正数、最小的负数、最大的负数、最小的正数，也就是 $\\pm \\infty$ 的极限和 $0$ 的左右极限。因此就有了一个很诡异的方法：把状态记为已经复合的函数的集合，也即 $p_1,p_2,\\cdots,p_k$ 的集合；对每一个状态维护可能达到的“最大的正数、最小的负数、最大的负数、最小的正数”这四个值，转移的时候把前驱状态的所有结果塞到函数里，排个序，再把最小值、最大值、$0$ 的前驱和后继全部塞到新状态的 vector 里面就好了。没想到这种看上去十分暴力的解法居然过了，不过其实它的复杂度似乎是正规的 $O(2^n\\cdot n\\log n)$。Day 2 T2还是照例先写暴力，接着总觉得“部分分好像都可做”，然后去打部分分。首先是把 $a=1$ 的 Subtask 4 写了，然后发现自己欠考虑了，连稍大的样例都没过。接着就强行打补丁，把漏考虑的情况写了写，终于过了这个 Subtask。其他的 Subtask 好像也有些可做，我甚至还写了 Subtask 3 的程序，可惜是个假做法。想要打补丁，可越想情况越复杂，但写了代码又舍不得放弃，况且 T3 的劝退模数又让我不禁接着想 T2……换题的时间到了，我最终还是放弃了其他 Subtask，把过了 Subtask 1,4 的代码重新交了上去。Day 2 T3写了暴力，结果暴力超时了，只拿到送的 $1$ 分……实在是太自闭了，在本地一看，$n=10$ 的预处理就要跑好久好久……根本过不了啊。看来纯暴力是不行了。我再想了想，可以不用处理 $A_{10}^1+A_{10}^2+\\cdots+A_{10}^{10}$ 种排列，只需要处理 $1!+2!+\\cdots+10!$ 种，最终把诸如 $3,9,1$ 这样的排列映射（离散化）成 $2,3,1$ 就好了。加了这个小优化，尽管本地跑得还是很慢，但是交上去居然过了？旁边的同学其实给我一定压力，他不停地（真的是不停）大声（真的很大声）击打（真的是击打）键盘，嗯……在想到“排列映射”的时候，我有了一个偷懒的想法：会不会“满足某种特征”的排列，它们的答案是一样的呢？如果找到这种“特征”，那我就不用写映射了。事实上，只要找到了“特征”，再加以打表，就可以告别暴力了！于是我走上了漫长的打表之路。首先根据冒泡排序的特征，第 $k$ 轮后，第 $k,k+1,\\cdots,n$ 大值一定是已经归位的；因此如果没有归位，答案一定是 $0$。接着，我观察到，顺序排列 $1,2,\\cdots,n$ 的值很有特点；而其他排列就是在部分重复顺序排列的答案！只是重复的不太一样，有的重复的是 $n-1$ 的，有的重复的是 $n-2$ 的。是什么决定了它重复的是哪里的呢？我首先试了逆序数，因为题面里提示了“逆序数不断减少”，但是并不对；我又尝试了“$n-1$ 的位置”、“$1$ 的位置”等奇奇怪怪的指标，发现都不对。还剩一个小时，真是自闭啊。更神奇的是，旁边的同学还小声喊了一句，“我找到了”（之类的话）……最终鬼使神差，我找到了规律——把这个排列做一轮冒泡排序（只做一轮！），这一轮中交换了 $k$ 次，那重复的就是 $n-k$ 的顺序排列的前几个答案。真是……神奇啊。然后就是写咯，知道规律了就能多拿好些分，但是更复杂的 Subtask 由于我不知道如何维护信息所以也写不了，最后还有约二十分钟的时候算是结束了所有可得分代码的书写。Day 2 总结Day 2 的启示主要就是要放弃吧，要是我不停地肝 T2 那恐怕是什么结果也没有。然后就是要坚持打表，即使一时找不出规律也要硬着头皮找（大雾）。Day 3 (Day 2+)Day 2 考完回去好好睡一觉，其实没有睡多长时间，就到 THU 的食堂体验了一下。THU 的食堂真的非常超值，$4$ 元的排骨简直有 nnsz 两倍的量，这也许就是我们在那里买饭卡只能使用 70% 金额（充 20 可用 14）的原因吧，专项补贴挺多的。由于 THU 的食堂太超值了，所以我吃不完，在还有不到半小时开考的时候骑车赶去考场。到了考场发现笔不见了，我只有一支笔啊啊啊，这还是学习题，要做笔记的啊啊啊……最后强行镇定下来，决定用 gedit 做笔记。进场拿密码条，看到了“简单 Cache 系统实现”的标题，然后就在脑内回想，“关于 Cache 你有什么印象”，答案是什么印象都没有（雾），只知道这个东西和卡常数有关。然后开考了。开考发现学习手册不知道在哪里，以为是我没找到，结果大家都没有。监考说“大家先看题吧”，结果这题没有学习手册根本看不懂，什么“Cache 一致性协议”，“MESI”？但是我“因祸得福”地看到了 T2 的一句话“这些算法的实现难度不一，请选手自行选择”，就明白了一定要做好放弃的准备。终于发学习手册了，并且考试结束时间延迟 $5\\mathrm{min}$。后来发现这 $5\\mathrm{min}$ 可能让我多拿了几十分。先花了约半个小时看了学习手册，并且认真地用 gedit 做了提纲（没有 Typora，不能写 Markdown，不能看着左边的“大纲”，真不爽）。看学习手册的时候有意识地跳过了“伪最近最少使用”和某名字特别复杂需要参考论文的算法。可是看到最后的“Cache 一致性协议”就非常难受，不停地有“看不懂”的感觉，不过还是硬着头皮扫了扫，发现后来都是技术性内容，所以就跳过了。看第一题，就是 Cache 一致性协议。而且就是要实现那些技术性内容。好吧好吧，我写我写。把状态编了数字编码，然后照着状态转移的表格写了下去，由于以为后面的题目还要用到这个程序，我稍微注意了一下接口的实现（虽然还是一个很丑陋的过程式接口，没有 OOP）。写完照着样例调了调，发现出入还挺大，最终发现是我把不需要打印的 Flush 事件也打了出来。调整之后，就通过了。第一题就把学习手册最后的内容给写了，那后来岂不是要很难？结果看了第二题，发现考的是前面的“Cache 替换算法”。呃，这个不是很简单的数据结构的应用么——除了被我放弃的“伪最近最少使用”部分（这个比较难写的部分拥有其他部分两倍的分数）。再看一眼范围，$n\\le 16$，本来都把堆的头文件引入了，干脆暴力了吧。暴力写完调一调，发现过不了样例？最终发现是自己被 T1 惯坏了，没有理解好“块”的概念，于是又重读 Cache 映射方式一节。经过几次尝试终于把“块”处理好了，这段处理“块”的代码也在之后的几道题一直沿用。接着看 T3，只读 Cache 实现？充分利用 T2 的代码，似乎不难写好。原来 T1 那些复杂的东西在后面的题目都没有用啊。还有一点时间，写一写 T4——读写 Cache 实现？似乎也不难吧，不就是要处理一下“脏”数据（没有与主存同步的数据）嘛。认真思考了一下，一个数据只有在写 Cache 的时候才有可能被标记为脏，只有在从 Cache 写入内存的时候才能消除脏标记，因此在这些时候对应维护好脏标记就行了。写完发现不对，检查了输入数据的部分，发现脏数据部分要先读后写。改成先读后写之后还是错了，还剩几分钟，确实有些紧张，想着“也许这个调不出来了”。后来重新审读了那一段代码，发现问题是，改成“先读”之后读的数据把原来的脏数据覆盖了，“再写”的时候写的就不是那份脏数据了。于是把脏数据用临时变量存一下，就解决了。交上去发现“$0$”和“$1$”的部分过了，“$0,1$”混合的部分却没过。仔细想了想，大概是因为“伪最近最少使用”出现了的缘故吧。T5 是“某算法”实现？看上去完全不可做，但是它的题目和 T4 基本相同？想着出题人可能会放一点水，我把 T4 的程序交了上去，结果过了好几个 Pretest，也许白得了几十分啊。最后还剩不到一分钟，就把我写的大纲交到 T6 “期待你的声音”上面去了。比赛结束后看了看“伪最近最少使用”，其实也不是特别难写，但是要是我真的写了这种算法怕是要少几十分。又看了一眼“某算法”的论文，十几页英文论文。。比学习手册还长不少。我知道 Golden Dict 是什么用的了。虽说我那几天停课也曾看过几眼嘤文论文，是一篇“$O(n)$ 点分治”的（把树分成 $O(\\frac{n}{\\log n})$ 块之类的，一看就觉得常数很大）；但是这么长的，实在是……Day 3 总结感觉这场发挥非常好，应该是我目前学习题的极限了吧。做大纲这一点应该挺好的，这样我对整个学习手册的内容就有一个把握；另外“想好什么东西在什么时候会改变”应该也挺重要。还有就是调试要有一定的信心，不要总想着自己会写错很多地方。此外要学会放弃！停课那几天写了 CyaRon 语言（虽然是用 Python + regex 水过去的）、时间复杂度、LOGO 语言这些题目，也算是增加了学习题的信心吧。今后还可以把宝牌一大堆给补了。面试与宣讲考完机试还挺有信心，觉得这回应该能进面试了吧。结果从 7:50 等到 8:10，一直没有电话。8:10 我去吃饭，在西郊宾馆餐厅等到 8:40，还是没有电话……心里想着“我哪里写炸了呢”，然后又考虑早上去哪里玩。结果 9 点左右突然接到我妈电话，说我爸刚刚接到电话。不是说好的 7:50~8:40 通知面试吗？然后我问“什么时候要去？”——“现在。”还好我早餐吃得差不多了——要是我决定去北京三环内玩，那我岂不是已经赶不回来了？整理了一下仪容仪表——在此特别感谢我爸出发前帮我剪的头发——就去会议室报到了。之前有看 ouuan 的博客了解到大概的注意事项，所以就在等候的时候写自我介绍。在手机上写了 900 多字，又请我妈提意见，删到了 700 多字，于是就被叫到门外等候了。等候的时候把稿子读了两遍多，就进场了。没想到的是自我介绍只有 $1\\sim 2\\mathrm{ min}$，我只好在说的时候自动删除内容。自我介绍的时候我还有一些紧张，不过强行调整过来了。自我介绍完毕是面试官就自我介绍中的内容进行提问，居然问了“文化课成绩如何”、“你们学校多少人”、“每年多少个清华北大”之类的问题，之后就问了“你的嘤语怎么样”，自然过渡到嘤语阅读了？而且还要求出声朗读，感觉自己哑巴嘤语被发现了。文章里面大量出现 LBS(Location Based Services)，还有 privacy，根据嘤语老师教授的嘤语阅读技巧——画框架，我算是大概理解了文章的 structure。之后面试官问我“What’s the passage mainly about”（事实上，是用中文问的），我就抓住了这两个词。似乎面试官还比较满意？此后就问我开发的小程序的主要架构啊，还有我无意提到的 FFT 的原理啊什么的，感觉我回答得自己还算满意。接着计时器“嘀嘀嘀嘀”地响了，就顺势结束了。感觉表现得还算满意吧，估计也是了解了大概流程的原因吧。下午的宣讲居然没有讲题，差评。一开始的关于 THU 科研生活的宣讲还比较有收获，再次说明了我和强省学生在综合能力上的差距。后面的宣讲就显得主题不突出，十分催眠了。据说今年发的纸非常多，那想必也是没有什么用的。休闲娱乐和后续晚上去了一趟国图，TP 的书真的非常多（比数理化加起来的两倍还多），可能是因为这个阅览室是面向大众的吧。然后各种大学教材特别多，不禁让人怀疑是否应该留更多的空间给专著，毕竟各种教材的内容都基本相近嘛。第二天没做什么，下午就回校了。早上还有幸看到了一次小雪，不过雪粒就像碎屑一样小，也没有特别壮观……一上文化课才知道，化学已经上到了“不认真学就会导致选修 4 完蛋”的化学平衡了，看来选 4 要完蛋了～（逃致谢这次首先要感谢父母的陪伴，让我在 BJ 都方便了很多。接着要感谢老师同学们的鼓励，让我更有信心。最后还是给 Hanakiko~希望这篇流水帐一样的游记也能给今后去 THUWC/THUSC 的同学一点帮助吧。","categories":[{"name":"总结","slug":"总结","permalink":"https://sweetlemon39.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"THUWC","slug":"THUWC","permalink":"https://sweetlemon39.github.io/tags/THUWC/"}]},{"title":"CSP 2019 集训 数学","slug":"CSP2019-math","date":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-math/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-math/","excerpt":"数学","text":"数学$\\gcd$定义与证明定义：$\\gcd(a,b)$ 定义为最大的 $d$，使得 $d\\mid a,d\\mid b$。$\\gcd(a,b)=\\gcd ( b,a % b )$ 的证明：设 $a=bq+r$。假设 $d\\mid b$，则可以由上式证明 $d\\mid a$ 等价于 $d\\mid r$。证毕。CQOI 2014 数三角形用（简单）容斥原理，用三点组的个数减三点共线情况的个数。如何计算三点共线情况的个数呢？回忆这个定理：定理 $2.33$ 设 $A(0,0),B(n,m)(n,m\\in \\mathbb{N}_{+})$，那么线段 $AB$ 上整点的个数即为$\\gcd(n,m)+1$。（——能量采集）只要暴力找出所有直线即可。$\\mathrm{exgcd}$算法证明根据数论基础知识，$ax+by=\\gcd(a,b)$（$a,b$ 是给定正整数，$x,y\\in Z$）有无数组解。并且，如果我们可以在欧几里得算法的过程中维护这个方程的解，那么就能在计算出 $\\gcd$ 的同时把解也算出来。首先，当 $b=0$ 时，这个方程的解就是 $(x,y)=(1,0)$。接着，假设 $a=bq+r$，设 $bx’+ry’=g$，我们需要找出一组使得 $ax+by=g$ 的 $(x,y)$。把 $a=bq+r$ 代入上面的式子得 $bqx+rx+by=g$，也就是 $b(qx+y)+rx=g$。把这个式子与 $bx’+ry’=g$ 比对即得 $qx+y=x’,x=y’$，也就是 $(x,y)=(y’,x’-qy’)$。青蛙的约会随便推一下式子就可以得到 $t(n-m)+sL=x-y$，其中只有 $s,t$ 是整未知数。先把两边都除以 $\\gcd(n-m,L)$，标准化之后用 $\\mathrm{exgcd}$ 求解就行了。小凯的遗憾 疑惑证明起来似乎挺长的，还是要注重打表找规律。快速幂 ($\\mathrm{kasumi}$) 与费马-欧拉定理费马小定理费马小定理：$p$ 是质数，那么 $\\forall a\\in [1,p),a^{p-1}\\equiv 1\\pmod{p}$。当然可以用“元素的阶整除群的阶”证明。这里提供一个使用二项式定理的证明方法。$(a+1)^p=a^p+\\mathrm{C}^1_pa^{p-1}+\\mathrm{C}^2_pa^{p-2}+\\cdots+\\mathrm{C}^{p-1}_pa+1$。由于 $p$ 是质数，因此 $\\mathrm{C}^1_p,\\mathrm{C}^2_p,\\cdots,\\mathrm{C}^{p-1}_{p}$ 的分母都没有 $p$ 因子，分子有 $p$ 因子，因此这些数都是 $p$ 的倍数。因此 $(a+1)^p\\equiv a^p+1$，从 $0^p\\equiv 0$ 即可归纳出 $a^p\\equiv a$。移项得 $a(a^{p-1}-1)\\equiv 0$。由于 $a\\in [1,p)$，因此两边除以 $a$（乘以 $a$ 的逆元）即得 $a^{p-1}\\equiv 1$。逆元如何求逆元呢？可以用 $\\mathrm{kasumi}$ 配合费马-欧拉定理，也可以用扩展欧几里得。这里提供两种 $O(n)$ 线性推逆元的方法。第一种是经典方法。设 $p=aq+r\\ (0&lt;r&lt;a)$，那么 $aq\\equiv -r$，$a^{-1}\\equiv -qr^{-1}$。这种方法仅适用于 $p$ 是质数的情况。第二种利用了阶乘。我们可以在 $O(n)$ 时间内计算出 $1!,2!,\\cdots,n!$。接着我们用某一种方法计算出 $(n!)^{-1}$，并递推 $((n-1)!)^{-1}\\equiv n\\times (n!)^{-1}$。于是 $x^{-1}\\equiv (x-1)!\\times (x!)^{-1}$。这个方法也许比经典方法快，而且适用于 $p$ 不是质数的情况（但是 $n$ 必须小于 $p$ 的最小质因子）。而且由 $(n!)^{-1}$ 递推 $((n-1)!)^{-1}$ 的方法也可以用于分段打表计算阶乘的逆元。计算系数 组合数问题这两道题都涉及 $\\mathrm{C}$ 的计算。可以灵活地运用定义式和杨辉三角递推式，在合适的场景使用合适的式子简化计算。也就是，如果 $n$ 只有 $2000$，那么使用杨辉三角就足够了。中国剩余定理如果 $p_1,p_2,\\cdots,p_n$ 互质，那么下面方程组$$\\begin{cases}x \\equiv a_1\\pmod{p_1}\\\\ x\\equiv a_2\\pmod{p_2}\\\\ x\\equiv a_3\\pmod{p_3}\\\\ \\vdots\\\\ x \\equiv a_n \\pmod{p_n}\\end{cases}$$在 $\\mod{p_1 p_2 \\cdots p_n}$ 意义下有唯一解。如何求这一组解呢？这里有一个神奇构造。令 $M=\\Pi p$，则 $M_i=\\Pi^{i-1}{j=1} p_j \\times \\Pi^{n}{j=i+1} p_j$，于是 $t_i$ 是 $M_i$ 在 $\\mod{p_i}$ 意义下的逆元。那么令 $x=\\sum_{i=1}^n a_iM_it_i$ 即可。如果考场上不记得神奇构造了，那就可以用 $\\mathrm{exCRT}$。主要应用还是合并同余方程。各种筛Violet 5 樱花求不定方程 $\\frac{1}{x}+\\frac{1}{y}=\\frac{1}{n!}$ 的正整数解数量。令 $m=n!$。由于每一个 $x$ 唯一对应一个 $y$，因此我们可以把 $y$ 用 $x$ 表示，得到 $y=\\frac{xm}{x-m}$。接着用分母换元法，令 $x-m=t$，$y=\\frac{(m+t)m}{t}=\\frac{m^2}{t}+m$。于是 $y$ 为整数的充要条件为 $t\\mid m^2$。同时，对 $m^2$ 的每一个因子 $t$，都可以唯一确定一组 $(x,y)$。因此只需要求 $m^2$ 的因子数，这只需要把 $n!$ 质因数分解就可以了。因此对于这样的题目，进行必要的数论变换是非常重要的。高精度不要写错。LLH邀请赛 大数计算器求 $\\mathrm{C}^r_n$ 的前 $3$ 位和去除所有末尾 $0$ 后的后 $9$ 位。后 $9$ 位相当于模 $10^9$，直接用 泳装 一题的方法，把因子 $2$ 和因子 $5$ 分开处理即可。前 $3$ 位怎么做呢？long double 信仰过？太大了，连 long double 都会爆啊。取一个 $\\ln$ 然后相加减，最后 $\\exp$ 吧。在对精度要求不高的时候，取对数也是不错的方法。解方程枚举是不是解的时候在模意义下进行，判断是不是真的解的时候用高精。当然也可以凭信仰，选取几个模数，把所有系数也取模，在这几个模意义下都进行运算，如果都满足方程就“认为”这个数真的是解了。容斥原理（经典型）Cirno 的完美算数教室暴力容斥，暴力出奇迹，记得加剪枝。HAOI 2008 硬币购物这个背包很有特点，物品种类很少，但是背包容量和物品数量很大，肯定不能 $\\mathrm{dp}$ 或搜索。那么我们就用数学方法。设第 $i$ 种硬币用了 $x_i$ 枚，那么 $c_1x_1+c_2x_2+c_3x_3+c_4x_4=s$，限制是 $0\\le x_i\\le d_i$。假如没有限制，那么这题就是一个简单的隔板法，把定义域下界上调到 $1$ 就行了。那么现在有了限制，就计算出各种“不符合限制”的情况，用容斥原理计算就行了。具体地，用“总方案数”减去“至少某一种硬币不符合限制”的方案数，加上“至少某两种硬币不符合限制”的方案数，减去“至少某三种硬币不符合限制”的方案数，最后加上“四种硬币都不符合限制”的情况。博弈论取石子游戏 1 ——理解必胜和必败态只有一堆石子，每次拿 $[1,k]$ 个，不能拿的输。画状态图可以发现 $0,k+1,2(k+1),\\cdots$ 都是先手必败，其余都是先手必胜。接下来归纳证明即可。取石子游戏 2 ——组合游戏和 SG 函数有 $n$ 堆石子，每次可以在一堆石子中拿任意多个，不能拿的输。这个东西不用 SG 做实在不太行啊。关于组合游戏和 SG 函数、SG 定理的理解，详见在学军的笔记。Nim 是经典模型，$\\mathrm{SG}(x)=x$。如果针对 Nim 游戏，那么可以比较简单地对“异或方法”的可行性进行证明。取异或值的最高位。由于这一位是最高位，因此一定存在一堆石子，它的石子数这一位为 $1$。令这一堆留下来的石子数恰好使得异或值为 $0$，那么留下来的石子数在那一位是 $0$，于是留下的石子数少于原来的石子数，也就是这种取的方案是一定可行的。这样异或值非零一定能转移到异或值为零的状态。而异或值为零的状态只能转为异或值非零的状态，且终态异或值为零。于是证毕。取石子游戏 3 ——游戏 1 和游戏 2 的结合有 $n$ 堆石子，每次可以在 $[1,k]$ 堆石子中拿任意多个，不能拿的输。考虑 $k=1$，那么就是游戏 2；若 $a_i=1$，那么就是游戏 1。因此这一个游戏是这两个游戏的结合。又来一个神奇操作。把每一堆都用二进制表示，计算每一个二进制位","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"CSP 2019 集训 搜索和数据结构","slug":"CSP2019-search-and-ds","date":"2019-11-14T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-search-and-ds/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-search-and-ds/","excerpt":"解题技巧","text":"解题技巧打表完美数输出区间完美数数量。判断一个数是不是完美数是容易的。要求区间完美数数量，其实就是要快速算出前缀和。前缀和……是不是类似于阶乘？分段打表！打表间隔 $10^6$ 就可以了。搜索剪枝虫食算从低位向高位搜索，因为低位没有未确定的进位。确定了一列的值之后马上验证。枚举整数的顺序的话……比较玄学地从大到小？另外据说这题的正解是高斯消元？整数分解重点是“不同正整数”。被分解的数一定是 $n$ 的约数，先把约数数组 $O(\\sqrt{n})$ 搞出来。接着从小到大枚举约数，dfs(tn,tk,tp) 表示剩余的数是 $\\mathrm{tn}$，还需要分解成 $\\mathrm{tk}$ 个数，当前已经在约数表中使用了前 $\\mathrm{tp}$ 个数。剪枝是如果可选的最小的 $\\mathrm{tk}$ 个数都超过 $\\mathrm{tn}$ 就剪掉。综合深搜技巧骑士精神不超过 $15$ 层，还是有迭代加深的道理的。另外使用一个简单的乐观估价函数进行剪枝。另外既然已经有乐观估价函数了，也可以 A*。（类似送礼物的）背包问题背包，物品数 $\\le 40$，体积 $\\le 10^9$。$40$ 这个数字太敏感了，马上 Meet in the Middle。集合划分“相等”的限制条件让我们想到，枚举两个集合 $A,B$，若 $A\\cup B=\\varnothing$ 且 $\\sum A=\\sum B$，则 $A,B$ 为一组合法划分方案。由于 $A\\cup B=\\varnothing$，因此上面的方法比较冗余——会产生大量的重复集合。我们有更好的避免重复的方案：令 $C$ 是前 $\\frac{n}{2}$ 个数组成的集合的划分方案（决定每个数在 $A$ 中、在 $B$ 中、都不在）， $D$ 是后 $\\frac{n}{2}$ 个数组成的集合的划分方案，这样 $A\\cup B=\\varnothing$ 就自然成立了。$C,D$ 各有 $3^{\\frac{n}{2}}$ 种。并且，设一种划分方案的权值是 $\\sum A-\\sum B$，那么两种权值互为相反数的方案合起来可以构成一种合法方案。但是注意！题目求的不是合法的划分方式数量，而且合法的能被划分的集合数量；也就是 $A\\cup B$ 的数量。因此，我们还要记录 $C,D$ 中 $A\\cup B$ 的值，设为属性 $s$。下面我们的任务就是，对右半的所有 $(w,s_r)$ 对，找出左半中所有的 $(-w,s_l)$ 对，并标记 $\\mathrm{visited}[s_l \\cup s_r]$。我们可以想到一个简单的做法：把左半按 $w$ 排序，接着对于右半里的每一种划分，二分找出左半中所有的 $(-w,s_l)$ 对，一一标记即可。还有一个小优化，左右半都可以排序后 unique 一下，即 $w$ 和 $s$ 都相等的对，只保留一个。这样做的复杂度怎么分析呢？对于每一个 $s_r$，它的所有不同的 $w$ 的总扫描长度（即扫描左半数组的长度）不会超过 $3^{\\frac{n}{2}}$，也就是最多把左半数组扫完；二分查找复杂度 $O(\\log {3^{\\frac{n}{2}}})$，因此总计算量大概是 $O(2^{\\frac{n}{2}}\\times 3^{\\frac{n}{2}}+3^{\\frac{n}{2}}\\times \\log 3^{\\frac{n}{2}})\\approx O(6^{\\frac{n}{2}})\\approx 6\\times 10^{7}$。当然还有一个不需要二分查找的方法。把右半以 $s$ 为第一关键字、$w$ 为第二关键字排序，再按 $s$ 分成小块，每个小块内 $w$ 是单调的，这样就可以在左半用双指针单调移动，去除掉这个 $\\log$。当然，扫描的复杂度可能也不小，因此这个优化可能差异不大。总之，当 $n$ 比较小，你的算法没有很好地利用限制（“相等、不等、不交”）时，可以考虑 Meet in the Middle，从而更好地利用限制。$n$ 皇后用二进制优化哪些地方可选即可加快速度。广搜八数码有明确的目标局面，可以使用双向广搜。有简单的估价函数，可以使用 A*。也可以写 IDA*。我原先写的 fake A* 不知道怎么过去的。华容道考虑搜索的状态是 $(s_x,s_y,b_x,b_y)$，分别表示目标棋子的位置和空白的位置。空白的位置这个状态很浪费啊——空白只有在目标棋子的四连块处，目标棋子才能移动。因此移动可以分为两类：目标棋子的移动——与目标棋子的起点和终点有关空白格的移动，即非目标棋子的移动——与空白格的位置、目标棋子的位置和空白格在目标棋子的方向有关。这种移动的目的是，把空白格移到目标棋子四连块的某一位置，从而使目标棋子移动。这两类的变量不太一样，我们考虑分开处理。由于第二类与输入关系较小，因此先预处理第二类移动情况。设 $g[s_x][s_y][b_x][b_y][d]$ 表示把 $(b_x,b_y)$ 处的空白格移动到 $(s_x,s_y)$ 处的目标棋子的 $d$ 方向的最短距离，移动的过程中目标棋子不能动。在计算 $g$ 的过程中，我们只需要把目标棋子临时标记为不可动，状态只记空白格子的位置即可。预处理了第二类的移动情况，实际上总的移动就变成了：空白格移动到目标棋子四连块——目标棋子移动——空白格移动——目标棋子移动——空白格移动……不妨枚举最开始时空白格在目标棋子的哪一个方向，再把状态记为 $(s_x,s_y,d)$，表示目标棋子的位置和空白格的方向。这样……就是一个图了！图上的边有两类——当然是空白格移动（边权根据 $g$ 可得）和目标棋子移动（边权为 $1$）啦。最后就是一个图上最短路问题了，点数 $4n^2=3600$，边数上界 $4n^2+3\\times 4n^2=13n^2=11700$，用 SPFA 就可以满足需要。指数计算数组里初始时只有 $1$，每次可以从数组中取出两个（可以相同的）数，把它们的和或差加入数组（但是要求差必须为正），求最少需要操作多少次才能得到 $n$。最少需要操作多少次？直接 IDA* 解决吧。乐观估价函数设为 $\\log (n-x)$，其中 $x$ 是数组中最大的数。还有一个玄学的搜索顺序优化，优先选大的进行扩展。ABCDEF这个式子很奇怪，进行一些移项后两边每一边都是三个数。这样就可以 Meet in the Middle 了。说实话这道题时间限制很危险，似乎要用哈希表才能过得去。测试 1帽子谜题奇妙的“数学”题。考虑实际上有多少种颜色的帽子，设这个数为 $x$。那么戴着独特帽子（只有他一人戴着这种颜色的帽子）的人的 $a_i$ 就是 $x-1$，戴着不独特帽子的人的 $a_i$ 就是 $x$。因此 $a_i$ 最大值和最小值的差不大于 $1$，并且最大值不大于 $n-1$。下面分两种情况讨论。一是所有人帽子颜色不同，那么 $\\forall 1\\le i\\le n,a_i=n-1$。特判掉就好了。二是所有人帽子颜色不全相同，这样必定有人戴着非独特的帽子。这时 $a_i$ 的最大值就是 $x$，最小值就是 $x-1$。设有 $p$ 人的帽子颜色独特，有 $q$ 人的帽子颜色不独特，那么 $p+q=n$；并且恰有 $p$ 种独特的颜色。再设有 $r$ 种不独特的颜色，那么 $p+r=x$。由假设“所有人帽子颜色不全相同”，则 $r&gt;0$。又由“不独特”至少有 $2$ 人，因此 $q\\ge 2r$。这两个不等式整理一下就可以得出“合法”的条件了。旅途一道有意思的搜索题。对于没有补给的情况，任意点都不会访问两次，因此只要建图跑最短路即可。对于有补给的情况，就需要搜索了。我用的是分阶段搜索。每领到一个补给，就进入一个新的阶段；同一阶段任意点都不会访问两次，搜过去即可。标程的方法更为巧妙。如果经过一个点，使得生命值和经过的泥潭数都没有发生变化，那么一定是在闲逛！因此我们可以把 $(x,y,w,\\mathrm{ans})$ 作为状态（$w$ 是生命值），这样就可以避免闲逛了。但是这样似乎还不能加 visited？比如这一组数据1234563 5 5SMMM.M###CMM...M####ME###好像就不太行的样子……魔术挺不错的计数题。暴力方法当然是直接搜。优化过的暴力就是从“独特”的字符开始搜，尽量减少不可能状态。看这个数据范围，似乎只要 Meet in the Middle 就可以过呢。可是……Meet in the Middle 如何快速合并呢？要求不能重复……要是直接记录，状态空间过大，复杂度无法承受啊。那怎么办呢？使用封印的秘法：容斥原理！容斥原理复 (yu) 习 (xi)容斥原理是一个很迷的东西，可以处理各种东西。容斥原理：有一个全集 $U$，并且有若干个对 $U$ 中元素定义的谓词（bool 函数）$p_1,p_2,\\cdots,p_n$，设满足谓词 $p_i$ 的元素集合为 $P_i$。设 $A_t$ 为恰好满足 $t$ 个谓词的元素的集合，如 $A_0$ 为 $\\overline{P_1 \\cup P_2 \\cup \\cdots P_n}$。现在想要求一个值 $W=w_0\\vert A_0 \\vert + w_1 \\vert A_1 \\vert+\\cdots+w_n \\vert A_n \\vert$，其中 $w_0,w_1,\\cdots,w_n$ 是任意给定的系数。也就是，每个元素对最终答案的贡献只与它满足的谓词个数有关，那么就可以使用容斥原理进行转化。容斥原理是把“$\\vert A_0\\vert,\\vert A_1\\vert,\\cdots,\\vert A_n\\vert$”这些不易求的量（可能需要枚举所有元素才能计算）转化为求另一些量。对于谓词的集合 $S$，设 $f(S)$ 为“满足集合 $S$ 中所有谓词的元素个数”（也就是“至少能满足 $S$ 中所有谓词的元素个数”），那么我们只需要对所有 $S$ 求出 $f(S)$，再把 $f(S)$ 赋予适当的“容斥系数”$s_j$，就能计算出 $W$ 了。注意这里的容斥系数 $s_j$ 仅与 $\\vert S\\vert$ 有关，也就是 $s_j$ 是 $\\vert S\\vert$ 的函数；谓词集合对答案的贡献也只与它的大小（所含的谓词的个数）有关。总结一下，容斥原理转化是将求“恰满足 $t$ 个谓词的元素个数”转化为“对于每一个谓词的集合，计算至少满足这个集合中所有谓词的元素个数”，从“枚举元素，数满足的所有谓词个数”变成了“枚举谓词的集合，数满足该集合中所有谓词的元素个数”。如何求“容斥系数”呢？“容斥系数”一定存在么？假设任选的某个元素 $x$ 恰满足 $t$ 个谓词，那么这个元素对 $W$ 的贡献应该是 $w_t$。下面我们从“容斥”角度考虑它对答案的贡献。如果用容斥原理计算答案，那么要考虑“它满足哪些谓词的集合中所有的谓词”——考虑这 $t$ 个谓词的集合 $B$，那么上面引号中条件的充要条件就是“这个谓词的集合是 $B$ 的子集”。因此只有 $B$ 的子集中才会出现 $x$ 的贡献。也就是说，$x$ 只要想要对答案作出贡献，就必须作为某个“满足某个谓词集合中所有谓词的元素”，而这些谓词集合都是 $B$ 的子集；因此只需要对于 $B$ 的所有子集 $C$，计算出“把 $x$ 作为满足 $C$ 中所有谓词的元素”时作出的贡献，再把这个贡献求和，就能得到“容斥法计算出的 $x$ 对答案的贡献”。考虑 $B$ 的一个 $j$ 元子集 $C$，那么 $x$“作为满足 $C$ 中所有谓词的元素”时对答案的贡献就等于容斥系数 $s_j$。$B$ 一共有 $\\mathrm{C}^{j}_{t}$ 个 $j$ 元子集，因此 $x$ 的总贡献就是 $s_0 \\mathrm{C}^0_t+s_1\\mathrm{C}^1_t+s_2\\mathrm{C}^2_t+\\cdots+s_t \\mathrm{C}^t_t$。这个值应该与定义法算出来的 $w_t$ 相等，也就是 $s_0 \\mathrm{C}^0_t+s_1\\mathrm{C}^1_t+s_2\\mathrm{C}^2_t+\\cdots+s_t \\mathrm{C}^t_t=w_t$。上述方程涵盖了所有“满足 $t$ 个谓词的情况”。要涵盖所有元素的情况，也就是涵盖满足 $0,1,2,\\cdots,n$ 个谓词的情况，我们就需要列 $t=0,1,\\cdots,n$ 时的方程，并把这些方程联立起来求一组解。如果能求出解，那么“容斥系数”存在，并且我们也就求出了“容斥系数”。这些方程是：$$\\begin{align}\\begin{cases}s_0 \\mathrm{C}^0_0&amp;=w_0 \\ s_0 \\mathrm{C}^0_1+s_1 \\mathrm{C}^1_1&amp;=w_1\\ s_0\\mathrm{C}^0_2+s_1 \\mathrm{C}^1_2+s_2 \\mathrm{C}^2_2&amp;=w_2\\ \\vdots &amp;= \\vdots \\ s_0\\mathrm{C}^0_n+s_1 \\mathrm{C}^1_n+s_2 \\mathrm{C}^2_2+\\cdots+s_n\\mathrm{C}^n_n&amp;=w_n \\end{cases}\\end{align}$$可以看到，一共有 $n+1$ 个未知数（$s_0,s_1,\\cdots,s_n$）和 $n+1$ 个方程，而且未知数的系数矩阵是下三角矩阵，下三角矩阵的下三角部分全都非零（因为都是组合数嘛），因此是一定有唯一解的。具体地说，$s_0=w_0$，$s_j=\\frac{w_j-s_0\\mathrm{C}^0_j-s_1\\mathrm{C}^1_j-\\cdots-s_{j-1}\\mathrm{C}^{j-1}j}{\\mathrm{C}^{j}{j}}=w_j-s_0\\mathrm{C}^0_j-s_1\\mathrm{C}^1_j-\\cdots-s_{j-1}\\mathrm{C}^{j-1}_j$，直接递推就可以 $O(n^2)$ 求出所有容斥系数。如果想要更快呢？我们整理一下式子，把式子写成求和号的形式：$$s_j=w_j-\\sum^{j-1}_{k=0}s_k\\mathrm{C}^k_j$$把组合数拆开：$s_j=w_j-\\sum^{j-1}_{k=0}s_k\\frac{j!}{k!(j-k)!}$像数列一样把变量的形式调整得更相似：$\\frac{s_j}{j!}=\\frac{w_j}{j!}-\\sum^{j-1}_{k=0}\\frac{1}{(j-k)!}\\times \\frac{s_k}{k!}$令 $T_j=\\frac{s_j}{j!}$，$Q_{j-k}=\\frac{1}{(j-k)!}$，$L_j=\\frac{w_j}{j!}$（变量名都是乱选的，不要打我）（这些都是可以 $O(n)$ 转化为答案或 $O(n)$ 计算出来的），那么：$$T_j=L_j-\\sum_{k=0}^{j-1}T_k Q_{j-k}$$这是一个典型的卷积型式子，已经可以用分治 FFT 在 $O(n\\log n\\log n)$ 的时间内解决了。还可以做得更好吗？这个式子里面有卷积以外的求和，很讨厌。不妨把式子重新移项整理成更整齐的形式：$$\\sum_{k=0}^{j-1}T_kQ_{j-k}+T_j=L_j$$由于 $Q_0=1$，因此左边可以整理成很漂亮的形式：$$\\sum_{k=0}^{j}T_kQ_{j-k}=L_j$$标准卷积出现了！下面我们把它改成多项式。设 $F(x)=\\sum_{i=0}^{\\infty} T_ix^i$，$G(x)=\\sum_{i=0}^{\\infty} Q_ix^i$，$H(x)=\\sum^{\\infty}_{i=0}L_ix^i$，那么$$F\\times G=H$$也就是$$F=H\\times G^{-1}$$于是就可以用多项式求逆 $O(n \\log n)$ 解决了！另外注意一个细节，$G(x)=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}=e^x$，因此 $G^{-1}$（是逆元，不是反函数）就是 $e^{-x}$！那还求什么逆呢？$e^{-x}=\\sum^\\infty_{i=0}\\frac{(-x)^i}{i!}=\\sum^\\infty_{i=0}(-1)^i\\frac{x^i}{i!}$。下面我们研究一下经典的容斥。$w_0=1,w_1=w_2=\\cdots=w_n=0$ 当属最经典的容斥——求不满足任何一个谓词的元素个数。此时 $H(x)=1$，$F(x)=e^{-x}$，也就是 $T_i=\\frac{(-1)^i}{i!}$，得到 $s_i=(-1)^i$。这和我们用经典方法得到的结果一致，也就是加上偶数的、减去奇数的。那如果是 $w_0=w_1=\\cdots=w_{k-1}=w_{k+1}=\\cdots=w_n=0,w_k=1$——求恰好满足 $k$ 个谓词的元素个数呢？此时 $H(x)=\\frac{x^k}{k!}$，$F(x)=\\frac{x^k}{k!}e^{-x}=\\sum^{\\infty}{i=0}(-1)^i\\frac{x^{i+k}}{k!i!}=\\sum{i=k}^{\\infty}(-1)^{i-k}\\frac{x^{i}}{k!(i-k)!}$，$T_0=T_1=\\cdots=T_{k-1}=0$，$T_i=\\frac{(-1)^{i-k}}{(i-k)!}$，$s_i=i!T_i=(-1)^{i-k}\\frac{i!}{k!(i-k)!}=(-1)^{i-k}\\mathrm{C}^k_i$。阅读上面这段推导过程的时候一定要明确 $T,Q,L,F,G,H$ 各自的定义！或者，如果撇开 $T,Q,L$，$F,G,H$ 分别可以看成是 $s,1,w$ 的 EGF（注意不是 OGF！）。如果是 $w_0=w_1=\\cdots=w_{k-1}=0,w_k=w_{k+1}=\\cdots=w_n=1$——求至少满足 $k$ 个谓词的元素个数呢？如果觉得用多项式直接做有困难，可以尝试用一下乘法分配律（从组合意义上说是加法原理）——把“至少 $k$ 个”拆成“恰好 $j(k\\le j\\le n)$ 个”的和。这样 $s_t=\\sum {j=k}^{t}(-1)^{t-j}\\mathrm{C}{t}^{j}$。这个和式有点像朱世杰恒等式的形式，可以试着用 $\\mathrm{C}^r_n=\\mathrm{C}^{r-1}{n-1}+\\mathrm{C}^{r}{n-1}$ 变形，变形的结果是 $s_t=(-1)^{t-k}\\mathrm{C}^{k-1}_{t-1}$。当然，对于大多数非经典的容斥问题，可以先在纸上画表找规律，说不定就能求出来了呢。实在不行还可以使用暴力求系数或多项式算法。用容斥原理解本题回到本题，我们想要处理的就是“如何选出交集为空的前后状态”。设前半段有 $n$ 个字符。如果我们以“前半段”为思考主体，对于某一个确定的前半段选择方案，取 $n$ 个谓词，其中第 $i$ 个谓词为“后半段是否选到了前半段的第 $i$ 个字符”。我们想要的是“不满足任意谓词的后半段个数”，那么根据上面经典容斥的第一个模型，容斥系数是 $(-1)^t$。也就是，对于字符的 $t$ 元集合 $S$，“至少取到 $S$ 中所有字符的每一个后半段”要对答案有 $(-1)^t$ 的贡献。于是，我们可以枚举前半段选择方案，再枚举它所选的字符集合的子集 $S$，求出“至少取到 $S$ 中所有字符的后半段”的个数（设这个数是 $u$），再给答案累加上 $(-1)^{\\vert S \\vert}u$。如何求出“至少取到 $S$ 中所有字符的后半段”的个数呢？这个条件的充要条件就是“$S$ 是这个后半段所选字符集合的子集”，因此我们对于每一个后半段，枚举它的子集，在子集处累加 $1$ 即可。另外注意，由于前半段和后半段要能连起来，也就是断点处的字符必须是一样的，因此我们要先枚举断点，然后由断点向两边分别枚举后半段和前半段，累加计算答案。总结一下，本题的解题框架是：先枚举断点；从断点往右找后半段，在找出的每一个后半段的子集处标记；从断点往左找前半段，枚举找到的前半段的每一个子集，累加答案。线性数据结构链表哈希表 (Hana’s Table!)对于一个字符串或大整数，可以把它模 $\\mathrm{mod}$（大质数）的值作为“特征值”，把它模 $p$（小质数）的值作为“哈希索引值”；每次按照索引值查找，如果找到特征值，那么就认为这个对象存在。栈, 队列蚯蚓发现“单调”的结论很重要，当然也可以直接感性理解、略去证明。单调栈, 单调队列什么是单调性思想？简单地说，就是“如果一个 OIer 比你小，还比你强，那你就打不过他了”！稍形式化地说，这类问题中的元素有时效性（转移的能力）和价值（值的优劣性），如果一个元素的转移能力和价值都超过了另一个，那么它就总可以替代另一个，于是另一个就不必被保存。单调性数据结构主要有，单调队列、单调栈、二分单调栈、单调性 set 等。Print Article状态转移方程 $f[i]=\\min(f[j]+(s[i]-s[j])^2)+M$，其中 $s$ 数组单调递增。观察一下——这个东西具有决策单调性！为什么？考虑设 $w_j(x)=(x-s[j])^2+f[j]$，那么 $f[i]=\\min(w_j(s[i]))+M$。$w_j$ 是二次函数，而且所有 $w_j$ 都可以通过互相平移得到。考虑两个这样的二次函数（不重合），它们的差是一个一次函数——一次函数是单调的，因此一旦一个函数变得优于（从劣于变到优于）另一个，它就永远优于另一个了。而且由于这些二次函数的对称轴单调右移，因此后面的状态最终都会比前面的状态优。或者我们也可以拆式子。$w_j(x)=(x-s[j])^2+f[j]=x^2-2s[j]x+s^2[j]+f[j]$。可以发现这是一个以 $-2s[j]$ 为斜率的一次函数，斜率是随时间（计算顺序）单调递减的，后面总比前面优。因此可以使用单调队列维护当前直线（“上/下凸壳”），发现队头变劣就弹掉；加入新直线时，如果发现新直线与队尾直线的交点小于队尾直线与队尾前一条直线的交点，即新直线的生效点在队尾直线的生效点以前，新直线完全覆盖了队尾直线，就把队尾直线弹掉。注意这样的斜率 dp 与“函数平移”型决策单调性 dp 的区别——这里的入队比的是生效点，就像用 set 的普通斜率优化 dp 比较“作用范围元组”一样；而很多“函数平移”型 dp 只需要比较“在当前点的大小”。弹队头和入队时弹队尾都是单调队列正确性的保证。关于决策单调性简单的决策单调性，斜率如果随时间单调变化，可以用单调队列或单调栈。困难的决策单调性，没有明显的斜率，可以使用二分单调队列或二分单调栈。困难的斜率优化，斜率不按时间单调变化，可以用 set 维护。极为困难的决策单调性！既没有明显的斜率，函数又不便计算的……考虑用 CDQ 分治（整体二分）！单调队列优化多重背包具有决策过期性质，可以用单调队列维护。Little Bird每个状态具有位置、高度两个属性，这两个属性都具有单调特点。等等，高度没有范围，劳累值有范围——考虑反转值域，把位置（树的序号）和劳累值作为定义域，高度作为值域。这样还有天然的好处——类似 LIS 的福利，每次转移只差 $1$！或者说这题就和 LIS 非常相像吧。但是这个“双单调”怎么办呢？我们可以用单调数组（类似 LIS）套单调队列解决。单调数组中每一个数就对应一个单调队列，单调队列维护位置属性，单调数组维护高度属性。Blocks求最长的均值不小于 $k$ 的子段。每个数减去 $k$ 后变为求最长的和非负的子段。考虑枚举区间右端点，也就是对每一个 $r$，要在 $O(1)$ 时间求出一个最小的 $l$，使得 $S_l\\le S_r$。考虑单调覆盖性质。一个状态的转移能力由 $S$ 决定，$S$ 越小，转移能力越强；价值由位置决定，位置越靠左，价值越大。如果一个状态的 $S$ 比另一个大，位置还在另一个的右边，那就会被“另一个”覆盖。因此可以维护一个不被覆盖的反链——$S$ 与位置反向变化的东西，因为询问的高度不单调，因此每次在反链中二分寻找即可。二分？这怎么 $O(1)$？其实右端点也有单调覆盖性质！右端点的 $S$ 越大，转移能力越强；位置越靠右，价值越大。因此右端点也在一个反链里！这样我们可以把左边的反链和右边的反链都做出来，这样枚举右端点的时候 $S$ 就是单调变化的了！既然是单调变化的，那么左端点那边的反链就可以单调删除元素，转移能力得以真正体现！你要问我“反链”用什么维护？当然是单调栈啦！综上，当前后状态都按照转移能力的单调顺序（前状态的转移能力越来越强，后状态的转移能力越来越弱）给出时，我们便可以用单调队列或单调栈 $O(1)$ 解决；如果没有完全按这个顺序给出，但是具有单调的（偏序）覆盖性质的话……我们就取反链，反链就是单调的啦！另外……反链总是包含了”无敌状态“——转移能力最强的零状态。树形数据结构并查集简单题$n$ 点 $m$ 边无向图，一旦一个点的度为 $1$，这条边就会自动消失。求至少要人工删除多少条边，使得这个图中没有边。如果一个图有环，一定不能变成无边状态。因此图一定要删到无环的状态。考虑一棵树，我们都知道树有 Prufer 序列对吧？树的 Prufer 序列其实就是一个类似上面的过程，因此树一定可以变成无边状态。综上，我们只需要把每一个连通块都变成树即可。那么要删的边数就是（每个连通块） $m-(n-1)$。例题给定一个无边的 $n$ 点图，在线维护这个图，每次操作连接两个点或询问这两个点连通的最早时刻。可以用“边带权”的并查集解决，边权就是操作的时刻。合并时按秩合并即可保留树的结构，ufind 的时候顺手计算一下边权的最大值即可。题目可以改成“给定图上两点，询问它们之间所有路径上‘边权最大值’的最小值”。按边权从小到大加边即可。类银河英雄传说 (Cube Stacking)每次有 merge 和查询到根距离两种操作，merge 时指定方向。不能按秩合并，那就路径压缩。边权记为到父亲距离。黑白点（[HEOI2016/TJOI2016]树）有一棵树，初始时只有根节点是黑的，每次操作染黑一个点或询问一个点的最近黑色祖先。染黑一个点就相当于把这个点的子树与它的父亲断开，查询最近黑色祖先就是查所在子树根节点。如果正着做就是断开，不好做；于是把操作离线，倒序处理，就变成了连接（merge），就可以用并查集了。如果强制在线怎么办？用类似树链剖分的方法——这回不需要维护树上两点路径，因此直接按 dfs 序即可——建立线段树，这回有区间上推（如果小于 $x$ 就改成 $x$）的修改操作，打上标记即可。ST 表与倍增ST 表求 LCA对每个节点，每次访问到就在数组中记录一次（这叫做欧拉序）。比如 $1$ 有 $2,3,4$ 三个孩子， $2$ 有 $5,6$ 两个孩子，那么这棵树的欧拉序就是 $1,2,5,2,6,2,1,3,1,4,1$。考虑欧拉序的记录方法，来到一个节点的时候记录一次，每遍历完一个子节点记录一次——因此长度为 $n+m=2n-1$。现在把欧拉序中记录的每个节点的编号改成记录每个节点的深度，接着再记录一下每个节点在欧拉序上的开始位置和结束位置（$\\mathrm{op,ed}$？），这样对两个点，只要查它们 $\\mathrm{op,ed}$ 之间的最小深度就可以了。这个深度欧拉序有什么特征么？相邻两个点的深度只会变化 $1$，也就是数列中每两个数的大小要么差 $1$，要么差 $-1$！这就是——$\\pm 1$ RMQ我们怎么求 $\\pm 1$ RMQ 呢？这里有一种玄学的分块方法，可以做到 $O(n)$ 预处理、$O(1)$ 查询！考虑把整个数列分成大小为 $\\lfloor \\frac{\\log n}{2} \\rfloor$ 的块（取整符号下略），那么总共就有 $\\frac{2n}{\\log n}$ 块。我们把每一块的最小值都求出来。现在把每一块看作一个整体，组成一个“块的数列”——长为 $\\frac{2n}{\\log n}$。对这个数列作 RMQ，使用 ST 表，复杂度为 $O(\\frac{2n}{\\log n}\\times (\\log (2n)-\\log\\log n))\\approx O(n)$。查询时怎么办呢？分块的思想是“整体使用预处理信息，局部暴力”。起点和终点之间部分的最小值可以直接用“块的数列”的信息得到，但是起点和终点所在块的最小值呢？这个要是暴力，查询可就不是 $O(1)$ 的了！这时候就要用到性质了。首先，如果一个区间的差分数列是确定的，那么这个区间的区间最值的位置也就是确定的。接着，由于是 $\\pm 1$ RMQ，因此每一块内部的差分数列也就只有 $2^{\\frac{\\log n}{2}}=\\sqrt{n}$ 种，暴力枚举这所有的块内差分可能性，对每一种可能性，都算出它所有子段（有 $\\mathrm{C}^{2}_{\\frac{\\log n}{2}}\\approx \\log n\\log n$ 种）的最值位置，这个过程的总复杂度是 $O(\\sqrt{n}\\log n\\log n)&lt;O(n)$。查询时就直接根据当前块的差分数列种类，查看相应种类、相应区间的最值表，就可以做到 $O(1)$ 查询了！看起来这样树上 LCA 就可以很快地完成了！但实际上——笛卡尔树假如我说树上 LCA 可以转为 $\\pm 1$ RMQ，那么你是相信的。假如我说一般的 RMQ 可以转为 LCA，你信么？不管你信不信，这确实是可以 $O(n)$ 做到的。笛卡尔树是一棵满足堆性质和 BST 性质的二叉树：父节点的值大于 / 小于子节点的值，也就是值满足堆性质；左节点的下标小于父节点，右节点的下标大于父节点，也就是下标满足 BST 性质。是不是和 Treap 有点像？当然，它们的作用还是有很大差别的。事实上，笛卡尔树上两点的 LCA 正是这两点形成区间的 RMQ！（稍加模拟，我也不想证明。）那么现在的问题就是怎么建立笛卡尔树了。考虑从左到右一个一个地把数加入到笛卡尔树中。最后加入的数一定在树的右儿子-右儿子-右儿子这一条链上，也就是一定是在最右边。我们选这样一条从根节点一直往右走的路径作为树的主链，把主链中的点插入一个栈中，把左儿子“挂”在主链上。那么最后加入的树一定要插入栈中。根据堆性质，如果这个数比栈中所有数都大 / 小，那么我们就可以把这个点直接放在栈顶。否则，假如这个数只比栈中的前 $l$ 个数大 / 小，那么我们就把后面的树整体拿出来，作为这个点的子节点。实际操作时不断弹栈，直到栈为空或栈顶节点满足堆性质，再把刚才最后一个弹出的节点作为这个点的左儿子，最后入栈即可。可以看出，上述建树过程是 $O(n)$ 的。因此只要我们先建出笛卡尔树，再根据笛卡尔树的欧拉序做好 $\\pm1$ RMQ 的预处理，我们就可以做到 $O(n)-O(1)$ RMQ 了！当然读入一个数是 $O(\\log_{10} x)$ 的，所以实际上作用也不是很大……但是可以过由乃救爷爷这一题。倍增与 Floyd$n$ 点 $m$ 边有向图，边有边权。问从 $1$ 号点开始，最少需要走多少条边才能使得经过的边的边权之和不小于 $s$。首先可以想到动态规划，$f[i][j][k]$ 表示从 $i$ 走 $k$ 条边、来到点 $j$ 的最大边权和，$f[i][j][k]=\\max(f[i][t][k-1]+w[t,j])$。这个方程看上去不是很均衡，左边是 $k-1$，右边是 $1$……考虑用倍增优化：设 $f[i][j][k]$ 是从 $i$ 走 $2^k$ 条边、来到点 $j$ 的最大边权和，$f[i][j][k]=\\max(f[i][t][k-1]+f[t][j][k-1])$。这样我们就能在 $O(n^3\\log k)$ 的时间完成 dp 方程的计算。下面考虑如何计算答案。考虑倍增求答案。从大到小枚举 $k$，如果所有 $f[i][j][k]$ 都小于 $s$，就把答案加上 $2^k$，同时记录一个 $g[i]$，表示走了 $\\mathrm{ans}$ 步，到达点 $i$ 后的最大边权和，$\\mathrm{ans}[i]=\\max(\\mathrm{ans[j]+f[j][i][k]})$，又是一个 $O(n^2 \\log k)$，就可以完成了。最后答案别忘了额外加 $1$，道理和倍增 LCA 相同。ST 表与并查集[SCOI2016]萌萌哒：求满足 $m$ 个形如”$[l_1,r_1]$ 到 $[l_2,r_2]$ 两个区间内的数字对应相等“的限制条件的没有前导零的 $n$ 位数的数量，模 $10^9+7$。考虑暴力怎么写。用并查集维护“相等”的条件，每次暴力连边，最后统计连通块的数量，有一个（包含最高位的那一个）连通块有 $9$ 种选择，其余连通块都有 $10$ 种选择，直接计算即可。这个并查集 merge 操作显然太多了，怎么办呢？我们需要一种高效的区间 merge 的方法。我们能不能给区间打个标记，标记意味着这个区间整体和另一个区间 merge 了呢？这样我们就要考虑把区间拆成若干个小区间——ST 表就可以，因为重叠也没关系。每次合并的时候就把 $[l_1,l_1+2^k-1]$ 与 $[l_2,l_2+2^k-1]$ 合并，相应地把第二个区间合并。再考虑如何得到连通块的个数。其实很简单，把 $\\mathrm{LC}(x)$ 与 $\\mathrm{LC}(\\mathrm{ufind}(x))$ 合并、$\\mathrm{RC}(x)$ 与 $\\mathrm{RC}(\\mathrm{ufind}(x))$ 合并即可，其中 $\\mathrm{ufind}(x)$ 指的是 $x$ 在并查集上的根。线段树诡异的线段树线段树与区间色数[POI2015] KIN：选取一个连续的区间，使得区间中只出现一次的数的种类最多。考虑枚举区间右端点，维护右端点在此位置时不同左端点的答案变化情况，并直接取 $\\max$ 即可。怎么维护呢？考虑新加入的数 $x$ 对答案的影响。设 $x$ 上一次、上上次出现的位置分别为 $l_1,l_2$，那么在区间 $(l_2,l_1]$ 中，$x$ 从只出现一次变为了出现多次，答案减一；在区间 $(l_1,\\mathrm{cur}]$ 中，$x$ 从不出现变为了只出现一次，答案加一。因此发生答案改变的左端点是一个区间，可以用线段树的区间加操作实现；求 $\\max$ 也可以用线段树解决。因此，这题只需要用线段树就可以了！于是，我们找到了用线段树维护（持续维护、可以维护所有区间）区间色数的方法。此外，某些区间色数问题还可以用双指针解决——求最短的至少包含 $k$ 种颜色的区间，若枚举左端点，左端点右移，则右端点单调右移。树上的色数问题可以用 $\\mathrm{dfs}$ 序或树链剖分转为序列区间色数问题。线段树与区间上下推这是一道 IOI 原题。给定一个初始全 $0$ 序列，有两种操作：对某区间内的所有数 $x$，令 $x=\\max(t,x)$（$t$ 是操作参数）对某区间内的所有数 $x$，令 $x=\\min(t,x)$求最后的序列。这道题与“萌萌哒”类似，如果每次区间操作都暴力地对区间内每一个数都进行调整，那么复杂度将无法承受。我们需要选择一种数据结构，直接对“区间”进行操作。“萌萌哒”这道题中，操作之间互不影响，而且操作区间可以重叠，因此可以直接使用 st 表（若操作区间不可重叠，同样可使用 st 表，但操作区间要被二进制拆分成为 $O(\\log l)$ 个）。但是在这道题中，不同的操作前后会有影响，因此我们可以使用线段树。线段树的每一个点维护“已经对这个区间进行、但还没有对这个区间的孩子应用 (apply) 的限制”——如果我们把我们的数想象成一排金属球，那么 1 操作可以想象成用一块钢板从下往上推区间内的球，一直推到高度 $t$，使之不低于 $t$；2 操作可以想象成用一块钢板从上往下压，一直压到高度 $t$。于是“每个区间的限制”有两种，一种是向下压的板到达的最小高度，一种是向上推的板到达的最大高度。初始时长度大于 $1$ 的区间都没有限制——向下压的板的最小高度（记为 $n$）为 $\\infty$，向上推的板的最大高度（记为 $m$）为 $0$；可以认为初始时长度为 $1$ 的区间的 $n$ 和 $m$ 都是 $0$。现在考虑对一个区间进行 1 操作。用一块自下而上的上推钢板推这个区间，会有什么变化呢？如果原来的下界钢板低于 $t$，当然会被推到 $t$ 位置，否则不变；上界同理。因此，这个操作对这个区间的变化是 $m=\\max(m,t),n=\\max(n,t)$。再考虑 2 操作，类似地，$m=\\min(m,t),n=\\min(n,t)$。由于有些操作之间会相互影响，因此如果有一个要应用到孩子、但不应用到父亲区间的操作，就必须先把标记下传。标记下传也就是把之前 lazy tag 延迟应用的操作应用到孩子上，也就是对孩子进行 $1\\ m,\\ 2\\ n$ 这两个操作——这两个操作的顺序无关紧要，因为在维护父节点的两个标记的时候，已经保证了这两块钢板 $m\\le n$，因此这两个操作之间不会相互影响。输出的时候直接输出叶子节点的 $m$ 或 $n$ 即可。由于上述过程中，叶子节点的 $m,n$ 始终相同——夹着单个球的板总是紧密合在一起的，因此输出哪一个都可以。动态开点线段树与线段树合并对于权值线段树，如果要像普通线段树那样静态建树、开点，空间将是非常非常大的，完全——无法承受啊！于是有了动态开点的操作。对于一个线段树节点，都像平衡树一样记录它的左子和右子，需要时再开点记录。可以用“引用”来优化实现。对于一个长度为 $n$ 的区间，动态开点线段树只需要 $2n$ 的空间就足够了。动态开点线段树还有一个好处——可以快速合并两棵结构相同的线段树！所谓“结构相同”指的就是“维护的区间（长度）相同”，这样它们对区间的划分就是相同的。合并的方法是，同时遍历这两棵线段树，如果两棵树当前节点都为空，那么合并后的树当前节点也为空；如果两棵树中只有一个当前节点为空，那么合并后的树直接使用另一棵树中的当前节点；如果两棵树当前位置上都有节点，那么递归合并；如果到了叶子节点，就把信息合并为一个节点，插入即可。合并的复杂度是多少呢？每次递归就相当与删除了一个节点，因此复杂度不会超过删除所有节点的复杂度——也就相当与把所有曾经做过的插入操作重新做一遍嘛——当然这是一个上界。大多数时候，线段树合并还是非常高效的。线段树合并与逆序对[POI2011]ROT-Tree Rotations：给定一个 $n$ 个叶子的二叉树，每个非叶节点都有两个孩子，可以交换任意非叶节点的左右子树，求交换后树的叶子遍历序列（按先序 / 中序 / 后序中任意一种方式遍历树，把遇到的叶子的权值依次记录）的逆序对数的最小值。我们首先可以注意到，交换某个非叶节点的左右子树，只影响这个非叶节点左右子树对应的两个子段之间的逆序对数量，不会影响两个子段之内以及其他位置的逆序对数量。因此，我们每次只需要比较两个子段之间的正序对和逆序对数，若逆序对数多则交换，否则不换即可。如何统计两个序列之间的逆序对数量呢？我们当然可以用归并排序的方法统计，但是归并排序每次归并是 $O(n_1+n_2)$ 的，如果我们的树极度不均衡，在一条主链上，每个主链节点都外挂一个儿子的话……自然就被卡到接近 $O(n^2)$ 了吧。怎么办呢？想一想求逆序对还有什么办法？当然是利用树状数组了——这里当然要“应景”地改为利用权值线段树。这样，我们的“归并”过程不久变成了线段树合并么？在线段树合并的过程中，如何统计逆序对数量呢？考虑左半部分一个较大的数和右半部分一个较小的数，记他们在合并后的树中的 LCA 为 $t$，那么在合并前的两棵树中，它们分别在左半部分节点 $t$ 的右子树和右半部分节点 $t$ 的左子树中，反之亦然。因此这是一个一一对应关系，我们只需要维护线段树每一个节点的 size，合并的时候对应相乘相加就好了。复杂度是比较优秀的，当然常数还是稍大……注意卡常以及用垃圾分类回收卡空间。线段树灵活反转值域还记得反转值域吗？哪个维度方便、哪个维度范围小，就把哪个维度作为定义域；把不方便、范围大的维度作为值域！CF911G Mass Change Quries：给定一个长度为 $n$、值域为 $[1,100]$ 的序列，每次操作把特定区间中的所有 $x$ 改为 $y$（$x,y$ 都在值域内），求所有操作完成后的序列。就像不能把 12 岁以下儿童放在副驾驶座上一样，看到 $x,y$ 这么小，你忍心把她们放在值域上吗？倒是 $n$ 比较大，可以放进值域里。好了，我们决定照顾儿童，把 $x,y$ 作为定义域。对每个数值（$x$），建立一棵权值线段树，向线段树中插入这个数值所在的所有位置。比如说第 $1,3,4$ 个数是 $2$，就向 $2$ 的线段树中插入 $1,3,4$。对于每一次修改操作，我们只需要把 $x$ 线段树中这个区间相应的节点“剪切”下来，“粘贴”到 $y$ 线段树中就可以了！怎么“剪切”、“粘贴”呢？这又不是 Splay……不是 Splay 就不能快速分裂合并了吗？用类似线段树合并的方法，遍历到需要剪切的区间的时候就把节点指针“递给”需要粘贴的线段树。这就是一种很不错的做法了。其实还有一种更暴力的做法，每个节点维护“这个区间的 $x$ 都变成了什么”，注意每一次都要暴力更新标记。记住“父节点的标记比子节点的标记时间要晚”。线段树与区间覆盖[NOI2016] 区间：给定 $n$ 个区间，要从中选出 $m$ 个区间，使得这 $m$ 个区间的交非空。定义一个区间的长度为右端点减左端点，定义一种选择方案的代价为所有被选区间长度的极差，求代价的最小值。这里首先用一个贪心的“选择扩充”——在不影响答案的情况下，要尽量多选，使得一个原先不满足题意的方案变得满足题意。（另一种常用的贪心策略是“选择压缩”——在保持选择方案满足题意的情况下，尽量少选，使得答案变优。两种贪心思想要综合运用。）怎么扩充呢？当然是“如果把区间按长度排序，最终方案所选的区间的长度是连续子段”咯——毕竟最长和最短区间之间的所有区间都可以贪心地选上嘛。这样就可以枚举两个区间端点暴力了。再多想一想，这个枚举可以优化么？观察到，最短区间长度增加时，最长区间长度不减——“单调移动”性质！这样就可以用双指针解决了。还有一个问题！如何判定当前所选的这些区间是否满足题意？“快速判定”也是单调枚举算法的重要环节啊。当然是要用到线段树。对每个被选区间，在线段树相应的区间中每个点加 $1$，然后查询全值域的最大值，如果最大值不小于 $m$，那么符合题意——如果真的要选出 $m$ 个区间，我们就选“覆盖了这个点的所有区间中的任意 $m$ 个”就行了嘛！还有一个小问题——区间端点数值太大，达到 $10^9$！哎呀这算什么问题呀，直接离散化就好了。这样，我们就在 $O(n \\log n)$ 的时间内解决了问题。线段树优化 dpCF834D The Bakery（此题洛谷无）：有 $n$ 个数字，要把它们分隔为 $k$ 个部分，统计每个部分的色数，再把这些色数全部加起来作为答案。问答案最大是多少。$n\\le 35000,\\ k\\le 50$。看到这个，当然考虑 dp 了。设 $f[i][j]$ 表示把 $[1,i]$ 分成 $j$ 个部分的最大答案，那么 $f[i][j]=\\max(f[t][j-1]+\\mathrm{color}[t+1…i])$。这样就可以 $O(n^2k)$ 暴力了。考虑优化上面的 dp 式子。还记得上面的“线段树与区间色数”吗？线段树可以高效地维护所有区间的色数，这样我们就可以用线段树高效地维护上面 $f[t][j-1]+\\mathrm{color}[t+1…i]$ 这个式子（实质是区间色数加一个与右端点无关的常数）了，维护后区间 $\\max$ 即可。扫描线扫描线求矩形面积每碰到一个矩形，就把矩形对应的区域加 $1$，查询所有最小值为 $1$ 的子区间长度即可。扫描线维护区间信息UVA1608 不无聊的序列 Non-boring sequences：如果一个序列的任意连续子段都存在只出现了一次的元素，就称这个序列是不无聊的。请判断给定的序列是否无聊。这里又出现了“区间色数”之类的东西！完全可以用“线段树与区间色数”中的想法，维护区间“独特元素数”，右端点右移时维护线段树并查询区间最小值即可。当然我们还有另外的解法。考虑某个数 $x$ 在序列中的出现，设它的出现位置依次为 $y_1,y_2,\\cdots ,y_k$，那么任意左端点在 $[1,y_i]$，右端点在 $[y_i,y_i+1)$ 范围内的区间都是有独特元素的。反之，对任意有独特元素的区间，都存在一个数 $x_0$，使得这个区间的两端点满足上述条件。因此这是一个“充要条件”。我们考虑类似线性规划的方法，把区间的左右端点作为两个维度，区间化作点画在 $\\mathbb{R}^2$ 上。那么一个“充要条件”就相当与把条件的区域用矩形覆盖，最后就检查是否所有区间都被覆盖即可。这就可以用扫描线处理了。综上，对于“区间”、“限制条件”的问题，我们也可以用线性规划的方法，把限制条件和所求点标到 $\\mathbb{R}^2$ 上，用扫描线维护。树状数组树状数组维护各种区间修改，重点是推式子、交换求和号——可以画图辅助理解。此外树状数组还有单点修改、维护区间最值；充当平衡树等诡异功能，常数小，编码简单，值得一学(bei)。TrieTrie 的主要作用是处理位运算，特别是异或。$\\mathrm{mex}$（全局）异或对 Trie 的改变，就是如果这一位为 $1$，那么这一层的所有左右儿子反转；如果这一位为 $0$，那么没有影响。例题：给定一个长度为 $n$ 的自然数序列 $A$，每次操作全局异或一个数 或者 求 $\\mathrm{mex}$。由于异或具有结合律，因此把异或过的所有数维护到一个数，表示“之前所有异或操作的等效”，这样根据上面“全局异或对 Trie 的改变”一节，只需要根据这一影响，在每一位讨论是“尽量往左走”还是“尽量往右走”即可。如果在走的过程中遇到了期望方向没有儿子的点，那么就已经找到了；如果走的时候发现期望方向是满的，那就要往非期望方向走。特别地，如果整棵树都是满的，那么就输出 $2$ 的一个幂。51nod 1601 完全图的最小生成树计数这里肯定要用贪心咯。怎么求最小生成树？最小生成树是尽量取边权小的边构成生成树。边权？考虑贪心。最高位是 $1$ 的边有没有必要选呢？假如我们不连任何最高位是 $1$ 的边，那么“最高位是 $0$ 的点集”和“最高位是 $1$ 的点集”之间就没有边了，它们之间不连通，这肯定不是最小生成树。因此这样的边必须连一条。能不能只连一条呢？只要上述两个点集自身都是树，那么连一条边就可以把这两棵树合并起来了。尽可能少地选边权大的边，就是尽可能多地选边权少的边，这是符合最小生成树的求法的。因此我们的策略就是，把点按点权分成“最高位是 $0$ 的点集”和“最高位是 $1$ 的点集”，递归求解点集内部的生成树，再选择一条边权最小的“跨接边”就好了。如何选“跨接边”呢？把这两个点集中的点放在同一棵 Trie 中，在分叉后尽量地往相同方向走，如果 $0,0$ 和 $1,1$ 都存在，那么就两种都试一试。这么做，复杂度有保证么？考虑每一个数，它会被分到 $\\log v$ 个集合中，在每个集合中它最多会被遍历到一次，遍历一次的复杂度是 $\\log v$，因此每一个数对复杂度的贡献是 $O(\\log v\\log v)$，总复杂度就是 $O(n\\log v\\log v)$，可以通过。方案数怎么统计呢？方案数当然是所有跨接边的选择数之积了！只要在找跨接边最小值的时候顺便数一下方案数即可。最后还有一个细节。如果最后遍历到了叶子节点，叶子节点不止一个数怎么办呢？跨接边当然是可以乱选，这些“跨接边”的代价都是 $0$。但是方案数……$n$ 个节点的有标号无根树数量是 $n^{n-2}$，乘上这个数就好了。异或粽子这道题……我确实有一个复杂度玄学但是跑得很快的分治做法。正解是怎么做的呢？可持久化 Trie当然先转化为前缀异或，这样就转化为了两两异或前 $k$ 大。怎么办呢？还记得另一道题么？有 $m$ 个有序序列，求这些序列合并起来后的前 $k$ 大。只要用一个最大堆，插入每一个序列的最大候选值。然后每次取堆顶，再把堆顶所在的序列的下一个候选值放进堆，取 $k$ 次就好了。如果我们枚举左端点，那么就能快速求出这个左端点异或的“后继”——次优解。于是就像上面这样建一个堆，每次取堆顶、插入候选即可。这题其实主要考的还是“前 $k$ 大”的处理方法吧。分治核心思想：缩小问题规模。求第 $k$ 大有两个有序序列，如何在 $O(\\log n)$ 的时间求出合并后的第 $k$ 大数？想到“缩小问题规模”这个思想了吗？如果我们能每次把区间大小缩小到一半，就可以达成目标时间复杂度了。既然要每次缩小一半，那肯定和区间中点有关嘛。我们不妨取某一个区间的中点，然后怎么办呢？我们可以在另一个序列中查找这个中点的值所在的位置，这两个位置把两个区间分别分为“前段”和“后段”。如果“前段”中的数的个数大于 $k$，那么可以删除“后段”；如果“前段”中的数的个数不足 $k$，那么可以删除前段并把 $k$ 减掉前段中数的个数。如果我们每次都选较长的区间，那么这两个区间的长度的最大值在两次查找后一定会折半，结合二分查找，总复杂度 $T(n)=T(\\frac{n}{2})+O(\\log n)$。要粗略地解这个递推式，假设 $n=2^t$，那么 $T(n)=1+2+\\cdots +t=O(t^2)$，于是复杂度是 $O(\\log n\\log n)$，还没有达到要求。怎么办呢？瓶颈当然是二分，于是我们不能用二分。每次取两个序列的中点 $a_i$ 和 $b_j$，不妨设 $a_i\\le b_j$。如果 $i+j\\le k$，那么第 $k$ 大一定不在 $a$ 的后半；否则第 $k$ 大一定不会在 $b$ 的前半，并且 $k$ 要减去 $b$ 前半的长度。每一次至少有一个区间长度减半，经过两次长度的最大值必定减半，$T(n)=T(\\frac{n}{2})+O(1),\\ T(n)=O(\\log n)$，满足要求。Ants据说这是一道网络流？当然也可以用分治配合计算几何技巧（极角排序）解决。这里就不多说了（因为我不会计算几何(bushi）。平面最近点对这道题在进阶指南题目总结里有很好的总结，这里略。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"搜索","slug":"搜索","permalink":"https://sweetlemon39.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sweetlemon39.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"CSP 2019 集训 贪心和动态规划","slug":"CSP2019-greedy-and-dp","date":"2019-11-13T00:00:00.000Z","updated":"2020-02-02T00:00:00.000Z","comments":true,"path":"CSP2019-greedy-and-dp/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-greedy-and-dp/","excerpt":"贪心","text":"贪心简单贪心排队接水用邻项交换的方法可以证明，是从时间短到时间长排序。区间选取每次尽量选早结束的区间。选点覆盖区间每一个区间用尽量靠右的点覆盖。删数字从最高位开始，如果后一个数字比前一个数字小，那么就删去这个数，删够 $k$ 个为止。数位乘积注意到如果把末尾的一些数字改成 $9$，乘积可能会变大。枚举要把末尾的多少位数字改成 $9$，求 $\\max$ 即可。进阶贪心均分纸牌像网络流一样，每个点最后的净流入/出是一定的，而且端点的流入/出只有一个方向。因此只需要进行那一次净流入/出就可以了。环形均分纸牌Usaco 2012 Mar Haybale Restacking设 $1$ 与 $n$ 的流量为 $x$，就变成一堆绝对值之和的函数了。合并果子参照哈夫曼树。ONTAK 2010 Creative AccountingBZOJ 3544.给定数列 $A$ 和一个模数 $p$，找一段区间，使得区间和模 $p$ 最大。使用前缀和转化，对每一个 $S_r$，都找一个 $S_l(1\\le l&lt;r)$，使得 $S_r-S_l$ 模 $p$ 最大。分成两段，用 set 维护就可以了。反悔型贪心专题概述使用贪心算法的一个条件是“局部最优可得出整体最优”，但是很多时候，这是不成立的。但有些情况下，我们可以通过“反悔”操作，修改局部最优解的一个或几个操作，使得局部最优解导出全局最优解。EXPEDI - Expedition拿到题目，如果我们不敢用贪心怎么办呢？如果是 dp，那么状态数实在是爆炸啊。所以在考虑 dp 状态优化的时候，我们想到了贪心。有一种贪心策略是，只加油最多的加油站。但是这样的问题是，可能在到达好的加油站之前，车子已经没油了。考虑“子问题”。设“子问题”是走到第 $i$ 个加油站，油箱容量一直非负的情况下，最少的加油次数。下面要从第 $i$ 个加油站走到第 $i+1$ 个加油站，要是车子目前油足够还好说，直接更新油量即可；若是油不够呢？我们先前已经对“每个加油站加不加油”作出了决策，现在发现油不够了，是要反悔了没有？怎么反悔？“唉，要是我们在之前那个加油站加过油就好了。”可以在之前没有加过油的、油量最多的加油站加一次油。由于我们是迫不得已才加油，因此加油次数是最少的。把经过的加油站的油量放进堆里，每次取堆顶即可。数据备份同样是一道反悔的贪心。由于相邻两个数不能同时取，因此我们设置一个“自动反悔”的机制，即若 $a,b,c$ 相邻，选了 $b$ 后把三者删除，加入 $a+c-b$。今后如果选了 $a+c-b$，就意味着反悔了。这样就能平衡局部最优与全局最优的矛盾。Cow Coupons先考虑简单的情况：如果钱很少，没买完优惠的牛就花完了呢？那当然是直接贪心取优惠价最低的若干头牛，也就是取 $C_i$ 最小的一段。那么如果把 $k$ 张优惠券用完了，还剩有钱呢？这时候就有牛需要按原价购买了。我们原先选的牛价格低，但是优惠幅度不一定大，在钱比较多的情况下买它们不一定划算。怎么办呢？我们考虑反悔，也就是调换优惠券的使用对象，原先买的牛不用优惠券，现在买的新牛使用优惠券。于是代价就是 $C_j+(P_i-C_i)$。还可以从另外的角度考虑这个问题。为什么 $C_i$ 前 $k$ 小的牛一定要买呢？不妨假设某头 $C_i$ 前 $k$ 小的牛 $\\alpha$ 没有买，那么一定有一头 $C_i$ 较大（不是前 $k$ 小）的牛 $\\beta$ 使用了优惠券；把牛 $\\beta$ 调换成牛 $\\alpha$，答案不会变劣。因此 $C_i$ 前 $k$ 小的牛是一定要买的，但是不一定使用优惠券，因为可能有其他的牛优惠幅度更大。因此上述反悔型贪心的算法是正确的。综上，反悔型贪心可以着重考虑“局部最优解”如何转化为“全局最优解”，通过转化使得贪心算法变得正确。动态规划递推与动态规划斐波那契, LIS。动态规划的使用条件最优子结构整个问题的最优解蕴含子问题最优解。无后效性下一时刻的状态仅与当前状态有关，与前面的状态无关。如果不满足就要扩充状态才行。动态规划的一般做题方法设计状态设计转移，注意转移方向注意初值计算复杂度动态规划的分类线型动规背包问题区间动规树形动规状态压缩动规记忆化搜索特定的动态规划优化方法：决策单调性、斜率优化线型动规LIS, LCS (子段/子序列)背包问题01 背包、多重背包、完全背包、分数背包。其实还有有依赖的背包、分组背包等。区间动规石子合并设 $f[i][j]$ 表示区间 $[i,j]$ 全部合并的最小代价，枚举分割点（最后一次合并的位置）。环形石子合并环形问题要么考虑断环成链，要么倍长环。这题可以考虑倍长环，在得到的链中取所有 $n$ 长区间的最小答案即可。能量项链据说只是把 $+$ 变成了 $\\times$。[CQOI 2007] 涂色设 $f[i][j]$ 表示区间 $[i,j]$ 都被涂好的最小代价。每个区间肯定不会被涂超过一次，而且涂的区间“重叠而不覆盖”没有意义。（“重叠而不覆盖”指的是两个区间交集非空但不是子集关系。）下面把所有涂色方案分类。考虑涂的过程中有没有涂 $[i,j]$ 这个区间。如果没有涂这个区间，那么一定可以找到一个点 $k$，使得不存在一次涂色，同时涂了 $k$ 和 $k+1$。这个是由“不存在重叠而不覆盖的两个区间”性质保证的。于是我们枚举断点 $k$，令 $f[i][j]=\\min(f[i][j],f[i][k]+f[k+1][j])$。如果涂了这个区间，那么一定是因为这个区间的头和尾是一样的，我们想要先涂满这个区间，再在其上覆盖。因此这种情况仅当 $a[i]=a[j]$ 时才会发生。如果我们强制不能涂这个区间呢？那么头和尾都必须单独着色，着色次数会多 $1$，且情况转换为“没有涂这个区间”。于是像上一种情况那样转移。但是，实际上我们是涂了 $[i,j]$ 这个区间的，因此实际上着色次数要减 $1$，转移完成后减 $1$ 即可。综上，$f[i][j]=\\min(f[i][k]+f[k+1][j])-(a[i]==a[j])$。程序实现很简单，但是想出情况的转化还是有难度的。树形动规没有上司的舞会由于每个点选不选对它的父亲有影响，因此要记录到状态中。骑士刚才那道题的基环树版本。对于环，我们可以断环成链，也可以倍长环。由于环上的点外面还挂有东西，因此不方便倍长环。于是可以选择断环成链。如何断环成链呢？我们找到环上的某一条边，把它断开，再人工考虑断开边的影响——我们强制边上的某一个点不可选。强制当然可以直接特判，但这里有一个比较神奇的方法。直接把禁用的点的权值设为 $0$ 即可！（当然如果不放心，可以设为 $-\\infty$）。POI 2008 STA这道题才是换根 dp 的模板吧。换根的影响非常简单，子树内的点深度减 $1$，子树外的点深度加 $1$。USACO 2008 Jan 手机网络树上最小支配集。每个点可能被自己、父亲或孩子控制，需要分别讨论一下。类似的题目有“消防局的设立”，不过那个控制的范围更广一些。DAG 动规HAOI 2016 食物链裸题。状压动规疾病管理$f[i][j]$ 表示前 $i$ 头牛，疾病集合为 $j$，直接转移即可。另外还有更简单的贪心做法：枚举最终的疾病集合（所含疾病个数不超过 $k$），对每一个集合，扫描所有牛，统计有多少牛的疾病是当前集合的子集。混乱的奶牛记录最后一头奶牛和当前已选的奶牛。送外卖由于是环，因此一个环会被算 $n$ 次，非常不划算。我们强制环从 $1$ 开始，这样就只需要记录当前环上点的集合和最后的点即可。互不侵犯按行选择，记录当前选了几行、放了几个国王、当前行的状态即可。概率动规SGU495 Kids and Prizes概率论解法：考虑每一个盒子，它没有被任何人选到的概率自然是 $(1-\\frac{1}{n})^m$，于是可以计算出它被选的概率，也就是它被选的期望。把所有盒子的期望加起来（其实就是乘以 $n$，或者说是独立观察量）就得到答案了。概率 dp 解法 1：设状态是 $i$ 人，选了 $j$ 个礼物的概率。进行一些变换可以得到更好的递推式。概率 dp 解法 2：设状态是第 $i$ 个人得到礼物的概率。如果上一个人没有得到礼物，那么这个人得到礼物的概率和上一个人一样；如果上一个人得到了礼物，那么这个人得到礼物的概率少了 $\\frac{1}{n}$。同样化简可以变得更好。记忆化搜索可以简化实现，甚至可以剪枝。经典动规算法Floyd$f[i][j][k]$ 表示允许经过点 $[1,k]$ 中转的前提下 $i,j$ 的最短路，$f[i][j][k]=\\min(f[i][k][k-1]+f[k][j][k-1],f[i][j][k-1])$。第三维度滚动压掉。理解这个意义很重要，有专门考这个的题。动态规划的优化琪露诺很明显的单调队列优化。LIS有两种数据结构的优化方法。一种是反转值域后用单调数组，比较巧妙。另一种是令 $f[a[i]]$ 表示以 $a[i]$ 结尾的 LIS 的长度，然后利用动态开点线段树或离散化+树状数组就可以了。动态规划的 NOIP 例题加分二叉树因为有了序列，所以不是树形 dp，是区间 dp。注意考虑边界情况。合唱队形把 LIS 和 LDS 合并起来就行了。过河离散化后单调队列（？）。金明的预算方案由于附件很少，因此直接枚举附件的选取情况。如果附件比较多，先对每一棵树做一次背包，然后分组背包即可。传纸条由于两个路径不能相交，而相交的两个点到起点的路径长度一定相同，因此只要保证两条路径在距离起点相等的地方不相交即可。这样我们对两条路径同步走，$f[i][j][k]l$ 表示两条路径分别到达 $(i,j),(k,l)$ 的方案数。另外由于 $i+j=k+l$，因此可以压掉一维 $l$。乌龟棋由于当前位置和用过的四种卡片的数量是线性相关的，因此可以压掉当前位置。花匠考场上估计会写 $O(n\\log n)$ 的树状数组/线段树/set 优化 dp。当然这题还有一个更巧妙的方法，结合贪心，直接考虑与上一个的联系，如果这一个比上一个小，那么要么把上一个作为峰、这一个作为谷，要么不选这一个——因为上一个作为峰肯定比这一个作为峰更好。经过一番神奇 dp，就可以 $O(n)$ 得到答案。另外还有直接贪心构造解的办法。动态规划的高级应用最大半连通子图 (Part)裸题？别忘了只是一个部分分。如果使用记忆化搜索，就不需要拓扑排序了。Treats for the Cows因为是双端队列，所以就只能 dp 了，而且是区间 dp。另外这题实际上可以按区间长度滚动数组。Round Subset有二维属性的背包？值域上不可能有两个数，因此可以把其中一个数拿到定义域里。$f[i][j][k]$ 表示前 $i$ 个数、选了 $j$ 个、其中有 $k$ 个 $5$ 因子时 $2$ 因子的最多个数。计算量有点大，但毕竟是 CF 评测机嘛，信仰过。New Year Santa Network又是树上点对 / 点组的问题，确实不能考虑以点组作为计数主体，一定会 TLE 的。因此我们考虑计算边的贡献。我们发现，树上三个点之间的三对距离经过一条边要么是 $0$ 次，要么是 $2$ 次——如果三个点分布在这条边的两侧（一边 $1$ 个、一边 $2$ 个），那么贡献是 $2$ 次；否则贡献是 $0$ 次。贡献为 $2$ 次的情况数当然是 $\\mathrm{C}^2_p\\times \\mathrm{C}^1_q+\\mathrm{C}^1_p\\times \\mathrm{C}^2_q$。修改边的时候用贡献乘以 $\\Delta w$ 即可。树上染色如果我们两两考虑点对，那肯定是要超时的。如果我们考虑树边对答案的贡献如何呢？一条树边对答案的贡献应该是“子树内外黑点数量之积”加上“子树内外白点数量之积”再乘以边权。接下来做一个树上背包就可以了。关于复杂度，有一个参考证明。Outer Space Invaders拿到这道题，好像没有什么思路？每个外星人都有出现时间和消失时间，贪心似乎不太能做……我们先把外星人抽象成区间 $[a_i,b_i]$，画在高度 $d_i$ 上——也就是一条从 $(a_i,d_i)$ 到 $(b_i,d_i)$ 的线段。每次操作就是选取一个点 $(x_i,y_i)$，表示在 $x_i$ 时间进行一次半径为 $y_i$ 的攻击，这次攻击可以消灭所有在时刻 $x_i$ 存在的、半径不大于 $y_i$ 的外星人，也就是消除所有与线段 $(x_i,0),(x_i,y_i)$ 相交的线段。似乎还是没有什么思路？这里有一种“极限思考法”——没有思路的时候，考虑“最 xx”这样的特殊的元素。我们考虑半径最大的外星人，我们肯定需要一次半径为 $y_i$ 的攻击来消灭它，但是在什么时刻攻击还不确定；并且，这一次攻击能够消灭此时存在的一切外星人。也就是，如果我们按照半径从大到小考虑所有外星人，那么我们就不需要收到“半径”的限制，已消灭的外星人就是若干个连续的区间——可以区间 dp！虽说是“区间”，但是我们还是没有搞清楚呐……想一想记忆化搜索吧。假设我们枚举“最强外星人”在时刻 $t$ 被消灭，那么还剩下哪些外星人需要被消灭呢？当然是还剩“时刻 $t$ 之前消失的外星人”和“时刻 $t$ 之后出现的外星人”了。于是子问题就变成了“消灭时刻 $t$ 之前消失的外星人”和“消灭时刻 $t$ 之后出现的外星人”。假设“在时刻 $t$ 之前消失的外星人”中，我们枚举“最强外星人”在时刻 $t’$ 被消灭。那么剩下的外星人当然是“在时刻 $t$ 之前消失的外星人”和“在时刻 $t’$ 之后出现、但在时刻 $t$ 之前消失的外星人”。终于找到规律了吗？我们的子问题其实是“在时刻 $l$ 之后出现、但在时刻 $r$ 之前消失的外星人”，原问题是“在时刻 $0$ 之后出现、但在时刻 $n+1$ 之前消失的外星人”。于是这个区间 dp 终于定义完全了！转移方程也随之而来——$f[i][j]=f[i][k-1]+f[k+1][j]+g[k]$，其中 $g[k]$ 表示在时刻 $k$ 存在的所有外星人的半径的最大值。这个转移表示“在时刻 $k$ 进行一次消灭在场所有外星人”的操作，其合理性已在上面论述。因此，很多时候记忆化搜索可以作为思考的切入点（“脚手架”），当然也可以作为实现的方式。Problem a这些信息很多，怎么整理成容易处理的形式呢？我们要为每一个人安排一个准确的分数吗？好像非常困难啊。再思考一下每一个人说的话是什么意思。“有 $a_i$ 个人比我分数高，有 $b_i$ 个人比我分数低”其实对“比我分数高”的人和“比我分数低”的人这两部分都没有要求，叙述的只是“把所有分数排序后， $(a_i,n-b_i]$ 这一个区间是一个极大连续相等的段，并且我是其中的一个元素”。我们把每一个人说话的区间整合起来，把区间相同的人进行合并。如果同一个区间 $(a_i,n-b_i]$ 的人数超过了 $n-a_i-b_i$，那么多出的人一定在说假话。接下来就是处理数轴上不同的区间了。如果两个不同的区间相交，就会出现矛盾，这是因为相等是等价关系，具有传递性，不同的极长连续相等区间是不可能相交的。因此问题变成了在数轴上选若干个不相交的区间，使得它们的权值和最大。把每一个区间的左右端点记为 $L_i,R_i$，按 $L_i$ 排序依次处理，$f[i]$ 表示前 $i$ 个区间（必选第 $i$ 个）的最大权值和，那么 $f[i]=\\max(f[j])+w[i]\\ (R_j&lt;L_i)$。这个东西可以用线段树或者树状数组优化到 $O(n\\log n)$，于是问题解决。这题告诉我们要如何抽象处理信息。庆典求把正整数 $n$ 写成 $m$ 个不同正整数的和的方案数，$n\\le 10^5$。“不同正整数”启示我们可以把整数从小到大排序，接着如果使用差分数组就可以很好地描述这个数列的性质——差分数组的每一项都为正。差分数组中第 $i$ 位的数对答案的贡献是 $(m-i+1)d_i$，按照这个 dp，设状态 $f[i][j]$ 是前 $i$ 个数、对和的贡献为 $j$ 的方案数，那么 $f[i][j]\\rightarrow f[i+1][j+(m-i)d_{i+1}]$ ，其中 $d_{i+1}$ 是所枚举的差分数组第 $i+1$ 位的值。状态总数是 $O(nm)$ 的，转移好像又不止 $O(1)$……感觉不太行的样子。不过可以用记忆化搜索 + 强剪枝搞掉不可能状态，也许有一定希望。但是！转移其实是可以 $O(1)$ 的。这其实就是一个完全背包——每一个位置上的数的体积分别是 $m,m-1,\\cdots,m-i+1,\\cdots,1$，都有无穷多个，求把背包装满的方案数是多少。实际做的时候，我们不需要枚举 $d_{i+1}$，只要像完全背包一样顺序枚举 $j$，并从本行转移（$f[i+1][j]\\rightarrow f[i+1][j+(m-i)]$，并滚动数组）即可！因此，熟悉经典的背包模型，对解题还是很有帮助的。差分数组也是处理单调递增 / 递减问题的好方法。注：上述方法有缺漏。这个和完全背包有区别，因为完全背包某个物品可以不选，但是这里不能不选。因此需要对完全背包的方程进行一些改动，变成 $f[i][j]=f[i-1][j-(m-i+1)]+f[i][j-(m-i+1)]$。这里又提供两种方法。一种方法是，先把差分数组的每一个数设为 $1$，计算这些 $1$ 的总贡献。剩余的贡献要给差分数组里的某些数一点点加 $1$，给每个位置的数作调整对答案的贡献都不一样。接下来就考虑“给前 $i$ 个位置加了 $1$，总贡献是 $j$”即可。另一种方法是，构造一个每一个数都不相同的集合，可以有两种操作：给集合中所有数加 $1$、给集合中所有数加 $1$ 后再加入一个 $1$——也可以从差分数组的角度理解。注：这里有一个可以提交的类似的题目：51nod 1201 整数拆分，但是这道题没有限定拆成多少个数。这样怎么办呢？没有确定的 $m$，我们又应该如何计算差分数组每个数的贡献呢？这里有一种办法：把差分数组倒过来，每个位置存储“这个位置的数比下一个数大多少”，那么第 $i$ 个位置的数对和的贡献就是 $i$ 了。于是就可以对所有的 $m$ 都进行计算了。集合选数这是一个有向无环图上独立集的计数问题，我们可以先把图画一画。在纸上稍微画一画就会发现，这是一个网格图森林！这是因为，$2x$ 的三倍和 $3x$ 的二倍都是 $6x$。而且网格图的宽不会很大，只有 $\\log_{3}n\\approx 10$。于是就可以在网格图上按列做状压 dp，最后把不同的网格图的答案乘起来就可以了。这道题的关键还是发现图的性质。Eden 的新背包问题有 $n$ 个物品，每个物品有若干个。有 $Q$ 次询问，每次询问用 $V_i$ 的背包能装下的物品的最大价值，但是要求不能用物品 $D_i$（每次询问给定一对 $V_i,D_i$）。$n,V_i\\le 1000,\\ Q\\le 1000$ 怎么做？那当然是做一个前后缀背包然后简单合并一下就好了。如果 $Q\\le 3\\times 10^5$ 怎么办？这时候就不能每次查询都合并了！我们考虑离线之后进行 CDQ 分治或者线段树分治。（怎么想到的？区间太多大概是需要分治的吧(bushi)。联系分治 FFT。）Hotel求树上三元点集 ${u,v,w}$ 的数量，要求三个点两两等距。$n\\le 5000$。考虑三个点的中间点（必定有这样一个点），它到三个点等距。把这个点作为根，变成了计算来自三个不同子树、深度相等的点的个数。这个应该不是很难进行树形 dp。Osu! Easy这题比 osu! 一些图的 Easy 难多了……我们需要详细定义随机变量，这样有利于理解。注意，下面的几段都还没有引入期望。随机变量的推导可以认为是涵盖了各种可能情况时的推导。再次提醒，这里还没有期望！$L_i$ 表示以第 $i$ 个点击结尾的 combo 的长度。对于 x，$L_i=0$；对于 o，$L_i=L_{i-1}+1$，也就是不论 $L_{i-1}$ 如何，$L_i$ 总是等于 $L_{i-1}+1$。对于 ?，情况比较复杂，$L_i$ 有 $\\frac{1}{2}$ 的概率等于 $L_{i-1}+1$，有 $\\frac{1}{2}$ 的概率等于 $0$。$F_i$ 表示假如在第 $i$ 次点击后游戏意外退出（这个说法好牵强），此时的得分（或者可以理解为进行到第 $i$ 次点击时游戏界面显示的分数，打过 osu! 也大概知道吧(大雾)）。考虑如何从 $F_{i-1}$ 计算 $F_i$ 呢？这当然是考虑第 $i$ 次点击对分数有多少贡献啦。假如第 $i$ 次点击 miss 了，那么 $F_i$ 当然等于 $F_{i-1}$。但是如果成功了，那么 combo 加长了 $1$，分数增加了多少呢？由于 $(x+1)^2=x^2+2x+1$，也就是 $(x+1)^2-x^2=2x+1$，于是 combo 增长 $1$ 对答案的增加量应该是 $2L_{i-1}+1$。因此，对于 x，$F_i=F_{i-1}$；对于 o，$F_i=F_{i-1}+2L_{i-1}+1$；对于 ?，上述两个等式成立的概率各为 $\\frac{1}{2}$。或者，我们可以定义随机变量 $\\Delta_i=F_i-F_{i-1}$。对于 x，$\\Delta_i=0$；对于 o，$\\Delta_i=2L_{i-1}+1$；对于 ?，上述两个等式成立的概率各为 $\\frac{1}{2}$。这些可都是随机变量的分布啊，我要它干什么呢？算期望确实要用到概率，接下来我们开始了！由于期望的线性性，$\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1}+\\Delta_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(\\Delta_i)$。因此，我们只需要想办法计算出 $\\mathrm{Ex}(\\Delta_i)$，就可以很容易地递推出 $\\mathrm{Ex}(F_i)$ 了（其实就是 $\\mathrm{Ex}(\\Delta_i)$ 的前缀和嘛）。对于 x，由于 $\\Delta_i$ 恒等于 $0$，因此 $\\mathrm{Ex}(\\Delta_i)=0$。对于 o，由于 $\\Delta_i$ 恒等于 $2L_i-1$，由期望的线性性，$\\mathrm{Ex}(\\Delta_i)=\\mathrm{Ex}(2L_{i-1}+1)=2\\mathrm{Ex}(L_{i-1})+1$。对于 ?，我们要根据分布列计算 $\\mathrm{Ex}(\\Delta_i)$，也就是把两种情况下的取值与概率相乘，加权相加——这应该算是全期望公式的应用吧。由于 $\\Delta_i$ 取上述两种式子的概率各为 $\\frac{1}{2}$，因此 $\\mathrm{Ex}(\\Delta_i)=\\frac{1}{2}(0+2\\mathrm{Ex}(L_{i-1})+1)=\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}$。上面的三个式子中有两个出现了 $\\mathrm{Ex}(L_{i-1})$，因此我们在计算 $\\mathrm{Ex}(\\Delta_i)$ 的同时也要计算 $\\mathrm{Ex}(L_i)$。对于 x，由于 $L_i$ 恒等于 $0$，因此 $\\mathrm{Ex}(L_i)=0$。对于 o，由于 $L_i$ 恒等于 $L_{i-1}+1$，由期望的线性性，$\\mathrm{Ex}(L_i)=\\mathrm{Ex}(L_{i-1}+1)=\\mathrm{Ex}(L_{i-1})+1$。对于 ?，我们还是要根据分布列计算 $\\mathrm{Ex}(L_i)$。由于 $L_i$ 取上述两种式子的概率各为 $\\frac{1}{2}$，因此 $\\mathrm{Ex}(L_i)=\\frac{1}{2}(0+\\mathrm{Ex}(L_{i-1})+1)=\\frac{1}{2}\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}$。这样我们所需的所有递推式都全了，可以整理如下：$$\\begin{cases}\\begin{align} &amp;\\mathrm{Ex}(L_i)=0,&amp;a_i=\\mathrm{x} \\ &amp;\\mathrm{Ex}(L_i)=\\mathrm{Ex}(L_{i-1})+1,&amp;a_i=\\mathrm{o}\\ &amp;\\mathrm{Ex}(L_i)=\\frac{1}{2}\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}, &amp;a_i=\\mathrm{?} \\end{align}\\end{cases}$$$$\\begin{cases}\\begin{align} &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1}),&amp;a_i=\\mathrm{x} \\ &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+2\\mathrm{Ex}(L_{i-1})+1,&amp;a_i=\\mathrm{o}\\ &amp;\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(L_{i-1})+\\frac{1}{2}, &amp;a_i=\\mathrm{?} \\end{align}\\end{cases}$$初始值是 $F_0=L_0=0$。我们已经把辅助变量 $\\Delta_i$ 处理掉了。注意一个要点！$F_i$ 的式子里不要出现 $L_i$，因为这样在应用全期望公式的时候会出问题。简单地说，就是全期望公式里面已经在讨论这个 ? 是否 miss 的这两种可能性了，但是 $\\mathrm{Ex}(L_i)$ 里面同样包含了这个 ? 是否 miss 的讨论，一个事件重复讨论就会导致问题；或者说，在全期望公式里，已经假设（或者说在……的条件下）了这个 ? 是否 miss，因此应该代入的是已经确定下来的上一个状态，而不是代入目前这个状态。如果不好理解，可以试着把 $\\mathrm{Ex}(F_i)=\\mathrm{Ex}(F_{i-1})+\\mathrm{Ex}(L_i)-\\frac{1}{2},\\ a_i=\\mathrm{?}$ 代入 ? 这个序列计算，就会发现问题。所以这道题就不用数组解决了。话说这题二次方是道蓝题，还有一道三次方的是一道紫题，真是不可理喻(bushi。Vasya and Binary String此题略（大雾）。POI2004 PRZ不是特别困难的状压 dp。BZOJ3791 作业首先我们可以把连续的语文作业或数学作业累积在一起，这样序列就变成严格语数交错的了。下面有一个结论：$k$ 次操作可以生成所有不超过 $2k+1$ 块的序列。所谓“块”是指极长的连续 $0$ 或 $1$。可以用数学归纳法证明，要点是“在一段 $1$ 中间选一个区间变为 $0$，会变成 $101$，一次操作可以多产生 $2$ 个区间”。于是就可以 dp 了。$f[i][j][d]$ 表示第 $j$ 段的末尾是 $i$，变成了 $d\\ (d\\in{0,1})$ 序列时的最大收益，考虑上一段在哪里就可以了。百度之星 最强密码给出一个只含小写字母的字符串 $A$，求最短的只含小写字母的字符串 $B$，使得 $B$ 不是 $A$ 的子序列（子序列可以不连续）。求 $B$ 的长度和方案数。$\\vert A \\vert\\le 10^5$。我们怎么判断一个序列是不是另一个的子序列呢？先在 $A$ 中找 $B_1$ 第一次出现的位置 $i_1$，在 $i_1$ 之后找 $B_2$ 第一次出现的位置 $i_2$，在 $i_2$ 之后再找 $B_3$ 第一次出现的位置 $i_3$……因此“$B_j$ 匹配到 $A_i$”的 $i$ 和 $j$ 是重要的状态。设 $f[i]$ 表示匹配到 $A_i$ 的最小的 $j$，那么我们枚举 $B_j$ 的下一个字符 $c$，找到 $A_i$ 之后第一个为 $c$ 的字符 $i’$（找不到则为 $n+1$），更新 $f[i’]=\\min(f[i’],f[i]+1)$，同时统计方案数即可。找 $i’$ 的过程可以用一个数组维护，这样转移变为 $O(26)$。The Minima Game每个人都会从大到小取数，进行 min-max dp 即可。Treasure Chest状态不难想，但是卡空间怎么办呢？dp 压空间，当然是用滚动数组啦。如果按长度顺序转移，那么 $l$ 只会由 $l-1$ 转移到，所以只记录左端点就可以描述状态了。花仙子的魔法这题的 dp……很难理解吧。实在不行就找规律 + 大力拉格朗日吧。严格 $n$ 元树不错的题目。如果设状态为“深度为 $i$ 的严格 $n$ 元树的数量”，那么子节点的深度怎么限制呢？可以有至多 $n-1$ 个儿子深度小于 $i-1$，但是必须有一个儿子深度为 $i-1$……难道要用容斥？似乎容斥也是可以的——$f[i]=(f[0]+f[1]+\\cdots+f[i-1])^n-(f[0]+f[1]+\\cdots+f[i-2])^n$，初始条件 $f[0]=f[1]=1$。当然这里有更巧妙的办法。设 $g[i]$ 表示深度不超过 $i$ 的严格 $n$ 元树数量，那么 $g[i]=1+g[i-1]^n$——怎么理解呢？考虑严格 $n$ 元树的深度，可以是 $0$（这时只有 $1$ 种），可以大于 $0$（这时根节点的每一棵子树都是深度不超过 $i-1$ 的严格 $n$ 元树）。因此，很多时候放松限制条件也是 dp 状态设计的一种方法。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"贪心","slug":"贪心","permalink":"https://sweetlemon39.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sweetlemon39.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"CSP 2019 集训 图论","slug":"CSP2019-graph","date":"2019-11-10T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-graph/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-graph/","excerpt":"图论","text":"图论NOIP 欢乐 赛和注意到模意义下有乘法群，因此 $n$ 的范围可以放到 $m$。如果直接暴力当然是可以拿到 80 分，但是带个 $\\log 10^{18}$ 肯定不能过 $3\\times 10^6$。于是这里有一个把指数变小的小优化——扩展欧拉定理。$a^{b}\\equiv \\begin{cases}\\begin{align} &amp;a^{b% \\varphi (p)}, &amp; a\\perp p \\ &amp;a^{b},&amp;\\gcd(a,p)&gt;1,b&lt;\\varphi(p)\\ &amp;a^{b%\\varphi(p)+\\varphi(p)},&amp;\\gcd(a,p)&gt;1,b\\ge \\varphi(p) \\end{align}\\end{cases}$总之就是如果 $b\\ge\\varphi(p)$，$a^b\\equiv a^{b% \\varphi (p)+\\varphi (p)}$。为什么呢？证明有一定的难度，就先咕咕。可以参考这篇文章。可是 $\\log k$ 和 $\\log m$ 其实差距不大。因此该 T 还是 T。怎么办呢？考虑我们是怎么计算 $\\varphi,\\mu$ 这些函数的？它们是积性函数，因此我们可以用线性筛计算。这里也是一样。我们对于每一个质数调用线性筛计算 $p^b$，对于合数直接根据已经算好的 $p^b$ 得到 $a^b$。这样的时间复杂度就是 $O(n+\\log n\\log m)$，可以通过本题。三角形三元环计数题啊……正统的三元环计数方法是由度数大的点向度数小的点连边（反之亦可，度数相等的点按编号顺序）。然后对于每一个点 $x$，标记它所有（出边的）邻点 $u$，标记完成后再从每一个邻点 $u$ 遍历它的所有邻点 $v$，如果 $v$ 也是 $u$ 的邻点（也就是被 $u$ 标记过），那么就找到了一个三元环。关于时间复杂度，考虑把上面两步（从 $x$ 出发的遍历和从 $u$ 出发的便利）分开计算。第一步的时间复杂度是 $O(n+m)$，第二步则比较玄学，是 $O(n\\sqrt{m})$ 一类的（假设 $n,m$ 同阶）。如何计算补图中三角形的数目呢？考虑原图中的所有三点组，这些三点组之间可能有 $0,1,2,3$ 条边。并且式子 $m(n-2)$ 就把所有的一边组计数 $1$ 次、二边组计数 $2$ 次、三边组计数 $3$ 次。在上述找三元环的过程中很容易计算出一边组和三边组的数量，再算出二边组的数量，用总的三点组数减去一、二、三边组的数量就可以得到补图中的三元环数了。这种题……如果不知道算法的话就多多暴力吧。数谁知道这题暴搜能过啊？最短路Greg and Graph所有的删东西都是不好做的，因此只要题目允许，直接离线倒过来做。加点？$n\\le 500$？直接 Floyd 就可以了。如果要加边，似乎是 SPFA？虽然正解似乎是动态树就是了。社交网络$n\\le 100$ 的最短路？直接 Floyd 更新一下方案数。权值变换$f(x)=-\\frac{1}{x-1},\\ f(f(x))=1-\\frac{1}{x}$。好像没有什么希望？再算下去就可以了，$f(f(f(x)))=x$！由于三次就循环了，所以只需要扩充状态，记录当前走的步数模 $3$ 即可。欧拉路和欧拉回路SGU101这道题怎么好像是见过的样子……？如果把骨牌当做点，相同的数字当做边，然后……边数怎么好像很大的样子？而且我们要求的是一条恰好所有点且不重复的路径，这是……哈密顿路径？NPC 啊。这里有更好的方法！把数字当做点，骨牌当做边，就变成欧拉路径了。POI Garbage这里有一个神奇的地方，存在一种方案，使得每一条边都只被操作奇数次，因为考虑两个有交的操作环（桥环），他们的公共边会被操作两次；但是如果我们观察实际操作一次的边，就会发现这些边是两个环的异或，并且恰好形成了一个大环；于是这样的操作可以被替换为“操作一个大环”。DAG经典题求 DAG 上 $1$ 到 $n$ 路径的必经点。考虑路径计数，如果 $1\\rightarrow u$ 的路径数和 $u\\rightarrow n$ 的路径数之积等于 $1\\rightarrow n$ 的路径数，就说明 $u$ 是必经点。菜肴制作求（置换群意义下）逆元的字典序最小的拓扑序。也就是在 $1$ 的位置尽量靠前的前提下，让 $2$ 的位置尽量靠前；……；在 $1,2,\\cdots,k$ 的位置尽量靠前的前提下，让 $k+1$ 的位置尽量靠前；……事实上这里有一个很巧妙的转化：取反图，在反图上跑字典序最大的拓扑序，再反过来就可以了。这怎么证明呢？其实相当有难度。先证明一个小引理：反图的任意拓扑序反过来都是原图的拓扑序。这个根据拓扑序的定义就可以证出来了。下面说明这个算法一定会计算出最优解（证明不会证）。在反图上求解的过程中，如果在当前所有可选点中尽量选择大的，那么可以把小的位置留给小的点，并且可选的点的集合会变大；因此从理解上，这样是最优解。连通性Business这是入门经典的题目。我们肯定不会选择割点，接着讨论每一个点双，如果点双的周围有不小于 $2$ 个割点，那么久不需要选；如果只有 $1$ 个割点，那么就要在连通块内部建一个。特别地，如果全图点双连通，需要选 $2$ 个。也可以从缩点的角度考虑。新年的毒瘤根据树的定义——树是 $n$ 个点、$n-1$ 条边的简单无向连通图；因此只要删除一个点后，图仍满足这个性质，那么这个点就是毒瘤节点。只需要考虑非割点的点，去掉之后边数是否符合条件即可。CF402E Strictly Positive Matrix这题真的很厉害。首先由于我们只关心是不是 $0$，因此我们可以把所有的正数变成 $1$，这样这个矩阵就变成了 $01$ 矩阵。接下来根据讲课内容，我们要把这个矩阵与图论联系起来。图论……矩阵……似乎只有邻接矩阵和基尔霍夫矩阵了。那么邻接矩阵的 $k$ 次幂是什么意思呢？先令 $k=2$。那么 $G^2_{i,j}=\\sum \\limits_{u=1}^{n} G_{i,u}\\times G_{u,j}$，由于只关心 $01$，又可以化为 $G^2_{i,j}=\\bigcup\\limits_{u=1}^{n} G_{i,u}\\and G_{u,j}$。发现了什么？和 Floyd 很像吧。这就表示 $i$ 能否途经 $u$ 到达 $j$！于是问题就明朗了。$G^k_{i,j}$ 表示是否存在长度为 $k$ 的 $i\\rightarrow j$ 路径。因此只要这个图是强连通的，就可以满足要求。由于 $n$ 只有 $2000$，因此每个点搜一遍就好了。另外多提一句，如果不改为 $01$ 矩阵，这个 $G^k$ 又是什么意思呢？邻接矩阵某一位上的数如果大于 $1$，就说明这两点间有重边。而再看 $G^2_{i,j}=\\sum \\limits_{u=1}^{n} G_{i,u}\\times G_{u,j}$，就会发现…… $G^{2}{i,j}$ 表示长度为 $2$ 的 $i\\rightarrow j$ 路径的条数！于是 $G^{k}{i,j}$ 就表示长度为 $k$ 的 $i\\rightarrow j$ 路径的条数。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"https://sweetlemon39.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"CSP 2019 集训 字符串和树","slug":"CSP2019-string-and-tree","date":"2019-11-10T00:00:00.000Z","updated":"2019-11-14T00:00:00.000Z","comments":true,"path":"CSP2019-string-and-tree/","link":"","permalink":"https://sweetlemon39.github.io/CSP2019-string-and-tree/","excerpt":"字符串","text":"字符串哈希 (Hana~!)总之是很容易写，也比较稳的方法了。树哈希？把树的节点排一下序，然后转化为括号序列，最后字符串哈希就好了。Blue Mary的战役$n$ 这么小，当然暴力啦。如何快速比较两个子矩阵是否相等？当然哈希啦。Trie多模匹配非常有用。补退选前两个操作肯定是 Trie，第三个操作呢？在每个 Trie 节点上搞一个 vector 记录这个节点 $\\mathrm{size}$ 为 $t$ 的最早时刻，时空复杂度都可以接受。KMP解释清楚算法的关键是 next 数组的“次优解”意义。字符串周期这个在 KMP 小记 里有详细介绍。抄卡组对于 *，我们怎么处理呢？对于两个都有星号的字符串，只有第一个星号之前和最后一个星号之后的字符串是需要匹配的，因为中间不一样的地方都可以塞进星号里。对于两个没有星号的字符串，直接暴力比较是否完全相同即可。对于一个有星号和一个没有星号的字符串，每两个星号之间的部分必须依次在无星号字符串里匹配。这个使用 KMP 就可以了。Manacher双倍回文求一个字符串最长的形如 $ww^Rww^R$ 的子串，其中 $w^R$ 表示 $w$ 的 reverse。首先要发现一个特点，就是 $ww^Rww^R$ 不是简单的回文串的拼接，它自身也是回文串——事实上这个通过多举例就可以发现，证明也很简单。于是我们假设第二个 $w$ 的位置是 $[x,y]$，那么以 $x-1$ 为中心的回文半径必须覆盖到 $ww^R$，也就（大约）是 $2(y-x)+x$；以 $y$ 为中心的回文串必须覆盖到 $x$。因此大概是一个可以用数据结构优化的东西。树dfs 序第一种是长度为 $n$ 的简单 dfs 序，只在 op 时加入序列。这时所有子树都是连续序列。模板题是 LOJ 144 DFS 序 1、LOJ 145 DFS 序 2。第二种是长度为 $2n$ 的 dfs 序，在 op 时加入正的值，在 ed 时加入负的值，这时节点到祖先的路径也成为了连续序列——序列中无关的点都会正负抵消。[HAOI2015]树上操作看到题是不是就写了树剖？树剖确实是可以做的，但是也可以用长度为 $2n$ 的 dfs 序。这里唯一的问题是，如何进行子树修改操作？这是一段序列，我们需要正的加、负的减。有两种方法。一种是正负分离，搞一个 op 序列和一个 ed 序列，对每个点记录一下它在 op 序列上的位置和在 ed 序列上的位置，加的时候在两个序列里分别加就行了。另一种方法是真的处理这个“正的加、负的减”。考虑这些操作对线段树这个节点的影响。线段树上这个节点只记录了这段区间的和，而这次修改对线段树这段区间和的影响当然是“正的增加量-负的减少量”，也就是 $v\\times \\mathrm{pcnt}-v\\times \\mathrm{ncnt}$，提公因式得到 $v(\\mathrm{pcnt}-\\mathrm{ncnt})$，而 $\\mathrm{pcnt}$ 和 $\\mathrm{ncnt}$ 是建树后就不会再改变的，因此我们只需要记录每个节点所管理区间的正数个数和负数个数的差值，修改时就能正确计算出影响了。树上前缀和与树上差分这里复制树上前缀和与树上差分的原文。树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。树上前缀和树上前缀和——某个节点到根的路径上的每个点的权值和求法：$\\mathrm{dfs}$时带参数传递下去即可用法：$x\\rightarrow y$的权值和点权：$s[x]+s[y]-s[\\mathrm{lca}]-s[\\mathrm{par}(\\mathrm{lca})]$边权： $s[x]+s[y]-2s[\\mathrm{lca}]$树上差分树上差分——某个节点对它到根的路径上的每个点的贡献求法：修改$x\\rightarrow y$上每个点/边的权值时：点权：$d[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=w,\\ d[\\mathrm{par}(\\mathrm{lca})]-=w$边权：$d[x]+=w,\\ d[y]+=w,\\ d[\\mathrm{lca}]-=2w$用法：某个节点的权值即为它子树所有节点的差分和点权和边权我们的树上前缀和与树上差分（还有树链剖分，小声）都是基于点权的。那么如果遇到边权的问题，如何解决呢？当然是把边权分配到点上了啊。由于每个点的父节点是唯一的，因此每个点到父节点的连边是唯一的。那么，我们把边权分配到子节点上，也就是分配到深度较大的端点上，问题就解决了。树上两点距离当然要找 LCA，然后如何求距离呢？可以在倍增的时候边跳边算。但是如果带上修改（每次修改一条边的权值）呢？这就要用到树上前缀和了。设 $d[i]$ 表示从 $i$ 到根的路径长度（“某个节点到根的路径上的每个对象的权值和”），查询的时候 $d[x]+d[y]-2d[\\mathrm{LCA}(x,y)]$ 就可以了。修改边权会且仅会影响到一棵子树里所有点的 $d$，根据长为 $n$ 的 dfs 序的性质，子树里的点是一个连续的区间。区间修改-单点查询，用差分树状数组就可以了。DFS 序 3, 树上差分 1这是 LOJ 的模板。路径加，可以拆成两条树链（树上的点到祖先的路径）的加，就是所谓的“区间加”。如果不用树链剖分，就要使用树上差分，将树链的修改变为端点的单点修改，这样询问一个点的权值就要查看所哟对它有贡献的点。回忆一下，树上差分的定义是“某个节点对它到根的路径上的每个点的贡献”，于是对某个点有贡献的点就是以它为根的子树中的所有点。因此查询单点权值就要变为查询子树和。那么查询子树权值怎么办呢？子树和的子树和？还记得数列差分是如何处理“前缀和的前缀和”的吗？再存一个“$i\\times d_i$”就可以了。这里也是类似的，要维护类似于 $\\mathrm{depth}(x)\\times d_x$ 的东西。DFS 序 4其实这道题和 树上操作 是同一道题……但是数据范围不对！怎么办呢？似乎可以用 $\\pm 1$ DFS 序配合正负分离做到？如果非要用普通 DFS 序呢？修改有两种，一种是单点加，一种是子树加。由于是加法，因此我们可以把两种修改操作分开，查询时分别计算贡献。考虑单点加对查询（树链）的影响，那当然是用树上前缀和（树链型）直接做——单点加、区间查，树状数组就可以处理。考虑子树加对树链的影响。LCA运输计划给定树上的 $m$ 对点，把某一条树边的权值改为 $0$，使得这 $m$ 对点距离的最大值最小。由于是“最大值最小”，为了方便，我们采用二分答案——二分一个答案，表示“是否可以使所有点对之间的距离都不大于 $\\mathrm{ans}$”，满足可二分性。接下来的问题就是如何在 $O(n+m)$ 时间内判定了。由于只能删除一条边，这个问题事实上比较简单。考虑每一对距离超过了 $\\mathrm{ans}$ 的点（假设这样的点有 $t$ 对），它们之间的路径上必须有一条边被操作，并且这一条边，否则这对点的距离不变，不可能满足要求。假设距离最大的点的距离是 $d$，那么删除的边的权值至少是 $d-\\mathrm{ans}$。对于每一对点，我们可以给这一对点路径上的所有边都打上标记，表示删除这些边会影响这一对点的距离。最后要删除的边一定影响到所有 $t$ 对点，且权值至少为 $d-\\mathrm{ans}$。于是我们再扫描一下所有边，查看是否存在这样的边即可。问题是，怎么打标记呢？这是一个路径加、加完毕后查询的操作，因此可以用树上差分解决。巡逻只加一条边时，树变成基环树，环上的边只需要走一次，因此把这一条边连在直径上即可。加两条边时，会形成两个简单环，只在一个环上的边只需走一次，其余边要走两次。因此在只加一条边的基环树的基础上找直径，把原来的环上每一条边的权值设为 $-1$，表示选了这条边要把原来省下的费用还回去。最小生成树货车运输最大瓶颈路 + 树上查询。免费道路比较神奇的题目。首先判断是否无解，求最小生成树和最大生成树，如果最小生成树中 $0$ 边少于 $k$ 条或最大生成树中 $0$ 边多于 $k$ 条，就一定无解。否则考虑从最小生成树加一条 $1$ 边、删一条 $0$ 边，一定能逐渐减少 $0$ 边数量、增加 $1$ 边数量，从而达到 $0$ 边恰好是 $k$ 条的状态。（结论：一个图的两个生成树，一定可以通过一系列连续的“删边-加边”操作相互变换得到，变换过程中任意边数为 $n-1$ 的时刻都得到一个生成树。）然而我们不能一条一条边地替换。现在的方法是，把最大生成树中的所有 $0$ 边加入，再把其余的边排序做最小生成树，先加 $0$ 边直到 $0$ 边达到 $k$ 条，接下来只加 $1$ 边，加到连通为止。这就相当于把最大生成树中的一些 $1$ 边自动替换成了 $0$ 边，因此是一定可以求出解的。这题应该是介绍了生成树之间的变换吧。次小生成树在最小生成树上换边，从小到大加入非树边，把非树边所在环上最大的一条边替换掉即可。最小生成树计数求 $n$ 个点的图的不同的最小生成树的数量，$n\\le 100$。这道题非常好地阐述了最小生成树的性质。在 Kruscal 过程中，如果把边按照权值分成若干块，块内所有边权值相等，那么无论块内边的顺序如何，跑完某一块后，图的连通性总是一定的，这一块被选的边的数量也是相同的。因此不同块的选边是独立的，我们只需要每一块枚举一下即可。如果没有原题中的限制，同权边很多怎么办呢？可以用矩阵树定理计算。","categories":[{"name":"即时笔记","slug":"即时笔记","permalink":"https://sweetlemon39.github.io/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://sweetlemon39.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"字符串","permalink":"https://sweetlemon39.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树","slug":"树","permalink":"https://sweetlemon39.github.io/tags/%E6%A0%91/"}]},{"title":"奇闻记录","slug":"adventure-record","date":"2019-04-09T00:00:00.000Z","updated":"2019-04-09T00:00:00.000Z","comments":true,"path":"adventure-record/","link":"","permalink":"https://sweetlemon39.github.io/adventure-record/","excerpt":"准备省选了，没想到还遇到这样的坑……开个贴记录一下神坑。","text":"准备省选了，没想到还遇到这样的坑……开个贴记录一下神坑。std::sort的比较函数要求高在重载sort的比较函数时，一定要注意，若a==b，则cmp(a,b)一定不能返回true，否则会引发段错误。因此，在写莫队的奇偶排序时，必须写(bel[lhs.l]&amp;1)?(lhs.r&lt;rhs.r):(lhs.r&gt;rhs.r)，而不能写(bel[lhs.l]&amp;1)^(lhs.r&lt;rhs.r)。upd: 这个问题在两个多月后又重现了……莫队RE多半就是这个原因了啊。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"奇闻","slug":"奇闻","permalink":"https://sweetlemon39.github.io/tags/%E5%A5%87%E9%97%BB/"}]},{"title":"蒟蒻诗","slug":"juruo-poem","date":"2018-11-01T00:00:00.000Z","updated":"2018-11-01T00:00:00.000Z","comments":true,"path":"juruo-poem/","link":"","permalink":"https://sweetlemon39.github.io/juruo-poem/","excerpt":"爆零复爆零，蒟蒻当屏写。不闻键盘声，惟闻蒟叹息。","text":"爆零复爆零，蒟蒻当屏写。不闻键盘声，惟闻蒟叹息。问蒟何所思，问蒟何所忆。蒟亦无所思，蒟亦无所忆。昨夜见模拟，哆啦大点兵，试题十二卷，卷卷有神题。神题无样例，数据无范围，愿为打暴力，从此来骗分。T1 搞搜索，T2 跑循环，T3 弄枚举，T4 输随机。旦开编辑器，暮得二十行，不闻哆啦催促声，但闻评测状态响 WA WA。旦输万能头，暮至 STL，不闻哆啦催促声，但闻毕爷数据鸣啾啾。万里赴 OJ，测试度若飞。红气传金柝，蓝光照铁衣。神犇百题死，蒟蒻十年归。归来见哆啦，哆啦坐明堂。保送十二校，赏赐百千强。哆啦问所欲，蒟蒻不用上清华，愿驰千里足，送儿还机房。神犇闻蒟来，出房相扶将；大佬闻蒟来，当户理红妆；巨神闻蒟来，磨笔霍霍写 AK。开我机房门，坐我宿舍床，删我战时板，写我旧时题。当机打游戏，对书帖金牌。出门看学长，学长皆惊忙：同行十二年，不知蒟蒻能 AK。正解空间炸，暴力代码奇；程序评测跑，安能辨我是暴力？","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"蒟蒻","slug":"蒟蒻","permalink":"https://sweetlemon39.github.io/tags/%E8%92%9F%E8%92%BB/"}]},{"title":"曾经的离别","slug":"retirement-speech","date":"2018-04-01T00:00:00.000Z","updated":"2018-07-08T00:00:00.000Z","comments":true,"path":"retirement-speech/","link":"","permalink":"https://sweetlemon39.github.io/retirement-speech/","excerpt":"若洛谷是一条优美的山谷，百花盛开，姹紫嫣红，百鸟齐鸣，悦耳动听，我愿永远徜徉在山谷里，享受美好的Coding life，像其他世界的朋友们一样，永远微笑，把手伸向碧蓝的天空……","text":"若洛谷是一条优美的山谷，百花盛开，姹紫嫣红，百鸟齐鸣，悦耳动听，我愿永远徜徉在山谷里，享受美好的Coding life，像其他世界的朋友们一样，永远微笑，把手伸向碧蓝的天空……而现在，我要暂时离去，希望这美丽的山谷永远印在我的脑海里，刻在我的心上。明年六月，愿我们重逢！Your sincerely,Sweetlemon","categories":[{"name":"随笔","slug":"随笔","permalink":"https://sweetlemon39.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"退役","slug":"退役","permalink":"https://sweetlemon39.github.io/tags/%E9%80%80%E5%BD%B9/"}]},{"title":"那个世界的你，比这个世界的我，更重要……","slug":"you-are-more-important","date":"2018-01-07T00:00:00.000Z","updated":"2018-01-07T00:00:00.000Z","comments":true,"path":"you-are-more-important/","link":"","permalink":"https://sweetlemon39.github.io/you-are-more-important/","excerpt":"序幕不知什么时候，感觉自己好像已经来到了另一个世界中呢~","text":"序幕不知什么时候，感觉自己好像已经来到了另一个世界中呢~绪端梦里，朦胧的是你的身影；早晨，湛蓝的是你的天空；黄昏，灿烂的是你的晚霞；深夜，轻笑的是你的明月。每个世界都有许多相似之处，或许，正是那个世界的你来到了我身边吧！眼前的一切，与梦中重合……走在城市中央，房屋高耸；望向宁静远方，山峦连绵；凝视深邃夜空，繁星闪耀。身边的一切，与梦中重合……我在奔跑，你也在奔跑；我在改变，你也在改变；我在寻找，你也在寻找。幸运的我们那个世界很美好，你很幸运。你幸运，你是善良的，总能平和对待身边的一切；你幸运，你是坚毅的，从不畏惧任何困难与挫折；你幸运，你是乐观的，恒以微笑欣赏自己和伙伴。你幸运，你有一群并肩奋斗的挚友，你珍惜爱。这个世界也很美好，我同样很幸运。我幸运，我拥有一个健康的身体，能够欣赏眼前的多彩（即使不是特别清晰），能够聆听耳边的妙音，能够充满活力地奔跑。我幸运，我生活在一个美好的家庭，不需要为生存而忧愁，能够让我拥有良好（至少是较好吧）的品格，能够让我看到梦想和未来。我幸运，我生活在一个安全的环境，没有突如其来的灾难，同伴们可以和谐共处，我心中充满爱。我幸运，我生活在一个强大的祖国，我能够坦然地面对历史，没有沉重的负担，我能够自豪地看待现实，没有恐惧和慌张，我能够充满希望地憧憬未来。这个世界，不，一切世界，至少在这个时代，没有不幸，只有幸运和另一种幸运。假如生活欺骗了你，这一定是个善意的谎言。如果你遇到困难，如果我遇到困难，笑笑吧；你会给我力量，我也会给你力量。与你相遇你和我，生活在不同的世界里，也许如异面直线，永远不会相交，也许却处处都是你的投影。每当我获得赞美，每当我遇到困难，或喜或悲，想想那个世界的你，我的这些又算得了什么呢？你依旧在那里，笑着，等着我。是的，那个世界的你，比这个世界的我，更重要……而我呢？我会努力奋斗，我会坚强奔跑，我会追逐梦想，在这个世界上留下灿烂的印迹；到了那时，只要你一笑，我便满足了。在你身边你，在身边，微笑地看着我；我，在路上，等着你的笑容。","categories":[{"name":"穿透世界边缘的呐喊","slug":"穿透世界边缘的呐喊","permalink":"https://sweetlemon39.github.io/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/"}],"tags":[{"name":"世界间绪论","slug":"世界间绪论","permalink":"https://sweetlemon39.github.io/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E7%BB%AA%E8%AE%BA/"}]},{"title":"《你的名字。》影评——初见的时候","slug":"your-name-review","date":"2017-02-19T00:00:00.000Z","updated":"2018-01-07T00:00:00.000Z","comments":true,"path":"your-name-review/","link":"","permalink":"https://sweetlemon39.github.io/your-name-review/","excerpt":"原题：好片，推荐！仔细揣摩人物形象和故事情节原发布时间：2017-02-19 10:59:01原文链接：君名影评原文","text":"原题：好片，推荐！仔细揣摩人物形象和故事情节原发布时间：2017-02-19 10:59:01原文链接：君名影评原文归档注释：这是我近一年前的心血。一年前，在我还不认识你的时候，你来看我了吧！珍惜我们初见的时候。小标题为归档时所加。序·我与君名我看一些电影，看完总是会意犹未尽，非常羡慕电影中的主人公。比如看《2012》，就想像着自己也是驾驶诺亚方舟的一人；看《火星救援》，就想玩火箭发射游戏；这回，我便十分欣赏电影中主人公的纯洁情感(我在故意避开某个词，因为我觉得，用它来叙述不符合影片主调)……开学前看的电影，看完总有点“陶醉”，前天早上看完后晚上又看了一部分，昨天早上终于看完了第二遍。每一次看完，总觉得，生活真美好！但又有了不知何处而来的忧郁。昨天晚上，躺在床上，想着，如果交换的事情发生在我身上，会怎样？我是不是不够勇敢、不够坚强……终于困难地入睡了。然而，今天凌晨4:00，我又醒了。一醒来，满脑子都是君名里的事。看着那城市里无尽的夜，无法重新睡着，便反复回想电影里的情节和人物。终于熬到早上(中间无数次,恐惧袭来)，打开电脑，有感而发，于是有了这篇影评。看着这部电影时，我真的没有哭。可是回想着情节，竟有眼泪流出。这部电影在我心中久久不去，不给五星真的不可能。原来，你是这样先分析一下人物形象吧。泷是一名普通中学生。他其实:很可爱(也许不是通常的意思,我指的是令人、使人喜欢,特别是当我看到他和三叶在暮色中(实在想不起那个专有名词了)相遇时,他因为身体接触(具体略)而道歉的场景,还有他对着给他便当的司机的车鞠躬的场景)；很纯洁(我看到他(她?)说,”我这样对她不太好吧”,便以为他真的不会这么做了,可惜他还是忍不住…唉,不希望这样的事情反复发生啊~这点也许只是我对他的期盼罢了…)；很勇敢(他在雷雨中上山,描画着地图,当时我就很怕他会被雷击,但我想他不怕;他来到彼岸(underworld),进入(用词也许不妥)神体,想要用三叶的齿酿酒救三叶;还有最后,那一声”Hey”,讲笑,如果没有这一点,我们要寄刀片了(其实我有点笑不出来,沉浸……))；很坚毅(为了一个梦,为了拯救梦中的你,不放弃任何希望)；很勤奋(在电车上背英语……)；很帅气(呃,这个是真的,但是没有什么意义是吧~)。综上所述，我做不到。但是，他确实可以激励我！三叶也是一名普通中学生。她其实：很坚强(受着种种不公的待遇,被无数次嘲笑,却能忍着;在摔倒时,看了看手心,即使不知道梦中的你的名字,但是,不会放弃)；情感丰富(她帮泷追奥寺,想到他们能见面,”他真幸运啊”,却默默流泪;到东京去找2013年的泷,却不被那时的泷认出,下车那一刻真感人!不过这是一个时间的无限循环,如果泷没有绳结,就不能和三叶会面,这解释不通的,只能说是缘分了!)；很坚贞(没想到其他合适的词,语文白学了;当然,这是指她长达8年的等待和8年的泪水…想想都心酸,假设人均寿命80岁,那8年可是生命的十分之一啊!)很漂亮(呃,这个也是真的,但还是没有什么意义是呵?)综上所述，我做不到。但是，她确实也可以激励我！(此处注:做不到是指优良品质,不是别的,这里没有矛盾。)两人的共同特点,都深爱,都敢爱!爱，是影片的主题。爱能穿越一切,时间、空间、甚至两者……关于名字“名字”是影片的线索，政治课本上说过，名字是区分人和人的文字符号，是人格的标志。可是，我们可能都有疑问:为什么泷和三叶在相遇后都忘记了对方的名字呢?为什么泷只写了“我喜欢你”却没有写上自己的名字呢？前一个问题，我的倾向是，由于进入了underworld，要想回到人世就必须留下自己最重要的东西，在此时，他们心中最重要的(重要的、不想忘记的、不能忘记的)就是对方的名字了，因此无疑会失去。这印证了两人对彼此的爱之深，在此处染上了一层悲情色彩，十分令人感动。后一个问题，我认为，也许泷已经知道，名字是无法留住的。他要帮助三叶树立信心，拯救三叶，就必须抓住这个机会，表白自己心中的情感。这一点也在后来三叶摔倒后毅然爬起得到印证。如果写的只是名字，她或许没有这么充满希望。当然，从艺术角度来讲，这当然是要一波三折，牵动观者心弦。关于相遇也许整部影片，最感人的莫过于暮色相遇和三叶的奋斗了。错过。等待。从细节总能看出，他们两人虽然don’t remember,can’t remember(忘记了,没能记住)对方的名字，但是，他们都没有忘记对方！开头他们的流泪(当在等待的5/8年中)，5年后穿着西装的泷仍然看了看右手，还有那一次又一次的电车上目光相遇……还有最后再楼梯上重逢的那一刻。两人同时问对方，“你的名字是……”，同时镜头抬高，摄向蔚蓝的天空；片名再次出现，片尾曲响起。这里是片末点题，虽然也许能猜得到，但是还是收获了出人意料的感人效果。相隔那么多年，终于……影片没有继续下去，我想足够了。也许接下去会有更甜蜜的内容，也是我们所期盼的，但是，在这里戛然而止，恰到好处，更引起了我的无尽遐想。Time Fliers的时间影片的时间线很乱。这一方面由于这里涉及到众多穿越时空的内容，另一方面又是由于这样更能娓娓道来，让情感由浅入深，渐渐推向高潮。如果你没有看懂，建议可以看网上一些朋友们整理的时间线，并反复看影片，多暂停(虽然这样情感效果不好,但是可以增强理性效果)，相信你会明白的。文化背景影片当中提到了不少日本的传统文化。看完影片后有不少人购买了这些周边，当然我不反对(尽管我没有计划买)，这是自己对影片中主人公喜爱的自然流露，但是，我们如何对待自己的传统文化？引人深思。影片的背景音乐很不错，无论是歌曲还是纯音乐，对气氛的渲染、情感高潮的形成帮助很大。另外推荐一首Minecraft歌曲《Find the Pieces》，也是讲寻找的故事的，很感人，感兴趣可以去B站看看，它的歌词简直可以套进君名里。再提我与君名整个人简直迷乱，也许这就是传说中的“毒”吧。从前总觉得这种影片不值得一看，春节时说要去看电影，还特意避开这部；一个同学说这里面有些关于时空的内容，我便感兴趣看了，没想到如此震撼。理性的东西没能吸引到我，但是很明显，我的感情被深深影响了。唉，真不可貌相啊！看来，我真的欠一张电影票。这样，可不就无法弥补了吗？影评思路很乱。原谅我罢，我的心也很乱啊！这就是“此中有真意，欲辨已忘言”吧。你来了，告诉我……最后，谈谈我的体会。一是，很多时候要大胆，错过的机会，很有可能就不会再来了(指结尾)。我甚至想出了一个悲剧式结局，两人在楼梯错过了，当天晚上做了梦，在梦中忆起对方的面容，惊问：“你的名字是？！”却得不到回答，只剩眼泪……二是，珍惜生活！珍惜现在！我们生活的城市/乡村至少现在还存在着，也许在我们心中还是有纯真的感情，那么，珍惜吧！——谨以此影评送给开学几小时前的自己。愿生活美好。最后的补充P.S. 本来挺想PS一下电影的海报的，可是看了之后再也没有了这念头。P.P.S 很犹豫是否要让父母知道我看了这部影片。因为确实有感欲发，却又担心。一是内容、情感，二是某些身体接触情节。P.P.P.S 真的是非常激动了，刚刚去Word一看，飙了两千五百多字。唉，心中有梦，诉说吧！但愿我还能够坚持自己，过自己的生活。跋·君名与我解决一下正文中的一些问题吧，毕竟近一年前的文章了……上述对人物形象的分析显得很粗拙，毕竟是缺乏讨论的，很多地方有待商榷。还有，我与父母一同观看了这部影片，他们似乎不为所动，但是，或许这已经唤醒了他们年少时的梦呢？真的很怀念那种初见的感觉啊！","categories":[{"name":"穿透世界边缘的呐喊","slug":"穿透世界边缘的呐喊","permalink":"https://sweetlemon39.github.io/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/"}],"tags":[{"name":"你的名字","slug":"你的名字","permalink":"https://sweetlemon39.github.io/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/"},{"name":"世界间评论","slug":"世界间评论","permalink":"https://sweetlemon39.github.io/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E8%AF%84%E8%AE%BA/"}]}]}