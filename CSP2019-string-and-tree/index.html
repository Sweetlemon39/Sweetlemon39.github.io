<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.4.0"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>CSP 2019 集训 字符串和树 - Sweetlemon 的异世界</title><meta name="keywords" content="笔记,字符串,树"><meta name="description" content=" 字符串"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4.0.1/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">Sweetlemon 的异世界</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-home fa-fw"></i> 主页</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="一直在寻找着你"></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-home fa-fw"></i> 主页</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/CSP2019-string-and-tree/">CSP 2019 集训 字符串和树</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://sweetlemon39.github.io/" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"><p>Sweetlemon</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><p>即时笔记</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于：2019年11月10日</p></a></div><div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-11-14T00:00:00+00:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于：2019年11月14日</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><a id="more"></a><h3 id="哈希-hana~"><a class="markdownIt-Anchor" href="#哈希-hana~"></a> 哈希 (Hana~!)</h3><p>总之是很容易写，也比较稳的方法了。</p><p>树哈希？把树的节点排一下序，然后转化为括号序列，最后字符串哈希就好了。</p><h4 id="blue-mary的战役"><a class="markdownIt-Anchor" href="#blue-mary的战役"></a> Blue Mary的战役</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span> 这么小，当然暴力啦。</p><p>如何快速比较两个子矩阵是否相等？当然哈希啦。</p><h3 id="trie"><a class="markdownIt-Anchor" href="#trie"></a> Trie</h3><p>多模匹配非常有用。</p><h4 id="补退选"><a class="markdownIt-Anchor" href="#补退选"></a> 补退选</h4><p>前两个操作肯定是 Trie，第三个操作呢？</p><p>在每个 Trie 节点上搞一个 <code>vector</code> 记录这个节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">\mathrm{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66786em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">s</span><span class="mord mathrm">i</span><span class="mord mathrm">z</span><span class="mord mathrm">e</span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathdefault">t</span></span></span></span> 的最早时刻，时空复杂度都可以接受。</p><h3 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h3><p>解释清楚算法的关键是 <code>next</code> 数组的“次优解”意义。</p><h4 id="字符串周期"><a class="markdownIt-Anchor" href="#字符串周期"></a> 字符串周期</h4><p>这个在 <a href="https://www.luogu.org/blog/Sweetlemon/kmp-note" target="_blank" rel="noopener">KMP 小记</a> 里有详细介绍。</p><h4 id="抄卡组"><a class="markdownIt-Anchor" href="#抄卡组"></a> 抄卡组</h4><p>对于 <code>*</code>，我们怎么处理呢？</p><p>对于两个都有星号的字符串，只有第一个星号之前和最后一个星号之后的字符串是需要匹配的，因为中间不一样的地方都可以塞进星号里。</p><p>对于两个没有星号的字符串，直接暴力比较是否完全相同即可。</p><p>对于一个有星号和一个没有星号的字符串，每两个星号之间的部分必须依次在无星号字符串里匹配。这个使用 KMP 就可以了。</p><h3 id="manacher"><a class="markdownIt-Anchor" href="#manacher"></a> Manacher</h3><h4 id="双倍回文"><a class="markdownIt-Anchor" href="#双倍回文"></a> 双倍回文</h4><p>求一个字符串最长的形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><msup><mi>w</mi><mi>R</mi></msup><mi>w</mi><msup><mi>w</mi><mi>R</mi></msup></mrow><annotation encoding="application/x-tex">ww^Rww^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span></span></span></span> 的子串，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mi>R</mi></msup></mrow><annotation encoding="application/x-tex">w^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span></span></span></span> 的 reverse。</p><p>首先要发现一个特点，就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><msup><mi>w</mi><mi>R</mi></msup><mi>w</mi><msup><mi>w</mi><mi>R</mi></msup></mrow><annotation encoding="application/x-tex">ww^Rww^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span></span></span></span> 不是简单的回文串的拼接，它自身也是回文串——事实上这个通过多举例就可以发现，证明也很简单。</p><p>于是我们假设第二个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span></span></span></span> 的位置是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span></span></span></span>，那么以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 为中心的回文半径必须覆盖到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><msup><mi>w</mi><mi>R</mi></msup></mrow><annotation encoding="application/x-tex">ww^R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.00773em">R</span></span></span></span></span></span></span></span></span></span></span>，也就（大约）是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">2(y-x)+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>；以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span></span></span></span> 为中心的回文串必须覆盖到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>。因此大概是一个可以用数据结构优化的东西。</p><h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2><h3 id="dfs-序"><a class="markdownIt-Anchor" href="#dfs-序"></a> dfs 序</h3><p>第一种是长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span> 的简单 dfs 序，只在 op 时加入序列。这时所有子树都是连续序列。模板题是 <a href="https://loj.ac/problem/144" target="_blank" rel="noopener">LOJ 144 DFS 序 1</a>、<a href="https://loj.ac/problem/145" target="_blank" rel="noopener">LOJ 145 DFS 序 2</a>。</p><p>第二种是长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 的 dfs 序，在 op 时加入正的值，在 ed 时加入负的值，这时节点到祖先的路径也成为了连续序列——序列中无关的点都会正负抵消。</p><h4 id="haoi2015树上操作"><a class="markdownIt-Anchor" href="#haoi2015树上操作"></a> [HAOI2015]树上操作</h4><p>看到题是不是就写了树剖？</p><p>树剖确实是可以做的，但是也可以用长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span> 的 dfs 序。</p><p>这里唯一的问题是，如何进行子树修改操作？</p><p>这是一段序列，我们需要正的加、负的减。</p><p>有两种方法。一种是正负分离，搞一个 op 序列和一个 ed 序列，对每个点记录一下它在 op 序列上的位置和在 ed 序列上的位置，加的时候在两个序列里分别加就行了。</p><p>另一种方法是真的处理这个“正的加、负的减”。考虑这些操作对线段树这个节点的影响。线段树上这个节点只记录了这段区间的和，而这次修改对线段树这段区间和的影响当然是“正的增加量-负的减少量”，也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>×</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mo>−</mo><mi>v</mi><mo>×</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">v\times \mathrm{pcnt}-v\times \mathrm{ncnt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathdefault" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">n</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span></span></span></span>，提公因式得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mo>−</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(\mathrm{pcnt}-\mathrm{ncnt})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">n</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span><span class="mclose">)</span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{pcnt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{ncnt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">n</span><span class="mord mathrm">c</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span></span></span></span></span> 是建树后就不会再改变的，因此我们只需要记录每个节点所管理区间的正数个数和负数个数的差值，修改时就能正确计算出影响了。</p><h3 id="树上前缀和与树上差分"><a class="markdownIt-Anchor" href="#树上前缀和与树上差分"></a> 树上前缀和与树上差分</h3><p>这里复制<a href="https://www.luogu.org/blog/Sweetlemon/s-and-d-on-a-tree" target="_blank" rel="noopener">树上前缀和与树上差分</a>的原文。</p><blockquote><p>树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。</p><h5 id="树上前缀和"><a class="markdownIt-Anchor" href="#树上前缀和"></a> 树上前缀和</h5><p>树上前缀和——某个节点到根的路径上的每个点的权值和</p><p>求法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{dfs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">s</span></span></span></span></span>时带参数传递下去即可</p><p>用法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span></span></span></span>的权值和</p><ol><li><p>点权：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[x]+s[y]-s[\mathrm{lca}]-s[\mathrm{par}(\mathrm{lca})]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p></li><li><p>边权： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mn>2</mn><mi>s</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[x]+s[y]-2s[\mathrm{lca}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">]</span></span></span></span></p></li></ol><h5 id="树上差分"><a class="markdownIt-Anchor" href="#树上差分"></a> 树上差分</h5><p>树上差分——某个节点对它到根的路径上的每个点的贡献</p><p>求法：修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span></span></span></span>上每个点/边的权值时：</p><ol><li><p>点权：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>w</mi><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>w</mi><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">]</mo><mo>−</mo><mo>=</mo><mi>w</mi><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>−</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">d[x]+=w,\ d[y]+=w,\ d[\mathrm{lca}]-=w,\ d[\mathrm{par}(\mathrm{lca})]-=w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">)</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span></span></span></span></p></li><li><p>边权：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>w</mi><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>w</mi><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">]</mo><mo>−</mo><mo>=</mo><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">d[x]+=w,\ d[y]+=w,\ d[\mathrm{lca}]-=2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">c</span><span class="mord mathrm">a</span></span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.02691em">w</span></span></span></span></p></li></ol><p>用法：某个节点的权值即为它子树所有节点的差分和</p><h5 id="点权和边权"><a class="markdownIt-Anchor" href="#点权和边权"></a> 点权和边权</h5><p>我们的树上前缀和与树上差分（还有树链剖分，小声）都是基于点权的。那么如果遇到边权的问题，如何解决呢？</p><p>当然是把边权分配到点上了啊。由于每个点的父节点是唯一的，因此每个点到父节点的连边是唯一的。那么，我们把边权分配到子节点上，也就是分配到深度较大的端点上，问题就解决了。</p></blockquote><h4 id="树上两点距离"><a class="markdownIt-Anchor" href="#树上两点距离"></a> 树上两点距离</h4><p>当然要找 LCA，然后如何求距离呢？</p><p>可以在倍增的时候边跳边算。</p><p>但是如果带上修改（每次修改一条边的权值）呢？</p><p>这就要用到树上前缀和了。设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathdefault">i</span></span></span></span> 到根的路径长度（“某个节点到根的路径上的每个对象的权值和”），查询的时候 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mn>2</mn><mi>d</mi><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">A</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[x]+d[y]-2d[\mathrm{LCA}(x,y)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">L</span><span class="mord mathrm">C</span><span class="mord mathrm">A</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> 就可以了。修改边权会且仅会影响到一棵子树里所有点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">d</span></span></span></span>，根据长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span> 的 dfs 序的性质，子树里的点是一个连续的区间。区间修改-单点查询，用差分树状数组就可以了。</p><h4 id="dfs-序-3-树上差分-1"><a class="markdownIt-Anchor" href="#dfs-序-3-树上差分-1"></a> DFS 序 3, 树上差分 1</h4><p>这是 <a href="https://loj.ac/problem/146" target="_blank" rel="noopener">LOJ 的模板</a>。</p><p>路径加，可以拆成两条树链（树上的点到祖先的路径）的加，就是所谓的“区间加”。如果不用树链剖分，就要使用树上差分，将树链的修改变为端点的单点修改，这样询问一个点的权值就要查看所哟对它有贡献的点。回忆一下，树上差分的定义是“某个节点对它到根的路径上的每个点的贡献”，于是对某个点有贡献的点就是以它为根的子树中的所有点。因此查询单点权值就要变为查询子树和。</p><p>那么查询子树权值怎么办呢？子树和的子树和？</p><p>还记得数列差分是如何处理“前缀和的前缀和”的吗？再存一个“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>×</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">i\times d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.74285em;vertical-align:-.08333em"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>”就可以了。这里也是类似的，要维护类似于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>×</mo><msub><mi>d</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{depth}(x)\times d_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">p</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的东西。</p><h4 id="dfs-序-4"><a class="markdownIt-Anchor" href="#dfs-序-4"></a> DFS 序 4</h4><p>其实这道题和 树上操作 是同一道题……</p><p>但是数据范围不对！</p><p>怎么办呢？</p><p>似乎可以用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">±</span><span class="mord">1</span></span></span></span> DFS 序配合正负分离做到？</p><p>如果非要用普通 DFS 序呢？</p><p>修改有两种，一种是单点加，一种是子树加。由于是加法，因此我们可以把两种修改操作分开，查询时分别计算贡献。</p><p>考虑单点加对查询（树链）的影响，那当然是用树上前缀和（树链型）直接做——单点加、区间查，树状数组就可以处理。</p><p>考虑子树加对树链的影响。</p><h3 id="lca"><a class="markdownIt-Anchor" href="#lca"></a> LCA</h3><h4 id="运输计划"><a class="markdownIt-Anchor" href="#运输计划"></a> 运输计划</h4><p>给定树上的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">m</span></span></span></span> 对点，把某一条树边的权值改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>，使得这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">m</span></span></span></span> 对点距离的最大值最小。</p><p>由于是“最大值最小”，为了方便，我们采用二分答案——二分一个答案，表示“是否可以使所有点对之间的距离都不大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">s</span></span></span></span></span>”，满足可二分性。</p><p>接下来的问题就是如何在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 时间内判定了。由于只能删除一条边，这个问题事实上比较简单。考虑每一对距离超过了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">s</span></span></span></span></span> 的点（假设这样的点有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathdefault">t</span></span></span></span> 对），它们之间的路径上必须有一条边被操作，并且这一条边，否则这对点的距离不变，不可能满足要求。假设距离最大的点的距离是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">d</span></span></span></span>，那么删除的边的权值至少是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>−</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow></mrow><annotation encoding="application/x-tex">d-\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">s</span></span></span></span></span>。</p><p>对于每一对点，我们可以给这一对点路径上的所有边都打上标记，表示删除这些边会影响这一对点的距离。最后要删除的边一定影响到所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathdefault">t</span></span></span></span> 对点，且权值至少为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>−</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow></mrow><annotation encoding="application/x-tex">d-\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">s</span></span></span></span></span>。于是我们再扫描一下所有边，查看是否存在这样的边即可。</p><p>问题是，怎么打标记呢？这是一个路径加、加完毕后查询的操作，因此可以用树上差分解决。</p><h4 id="巡逻"><a class="markdownIt-Anchor" href="#巡逻"></a> 巡逻</h4><p>只加一条边时，树变成基环树，环上的边只需要走一次，因此把这一条边连在直径上即可。</p><p>加两条边时，会形成两个简单环，只在一个环上的边只需走一次，其余边要走两次。因此在只加一条边的基环树的基础上找直径，把原来的环上每一条边的权值设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，表示选了这条边要把原来省下的费用还回去。</p><h3 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h3><h4 id="货车运输"><a class="markdownIt-Anchor" href="#货车运输"></a> 货车运输</h4><p>最大瓶颈路 + 树上查询。</p><h4 id="免费道路"><a class="markdownIt-Anchor" href="#免费道路"></a> 免费道路</h4><p>比较神奇的题目。</p><p>首先判断是否无解，求最小生成树和最大生成树，如果最小生成树中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span></span></span></span> 条或最大生成树中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边多于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span></span></span></span> 条，就一定无解。否则考虑从最小生成树加一条 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 边、删一条 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边，一定能逐渐减少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边数量、增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 边数量，从而达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边恰好是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span></span></span></span> 条的状态。（结论：一个图的两个生成树，一定可以通过一系列连续的“删边-加边”操作相互变换得到，变换过程中任意边数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的时刻都得到一个生成树。）</p><p>然而我们不能一条一条边地替换。现在的方法是，把最大生成树中的所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边加入，再把其余的边排序做最小生成树，先加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span></span></span></span> 条，接下来只加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 边，加到连通为止。这就相当于把最大生成树中的一些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 边自动替换成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 边，因此是一定可以求出解的。</p><p>这题应该是介绍了生成树之间的变换吧。</p><h4 id="次小生成树"><a class="markdownIt-Anchor" href="#次小生成树"></a> 次小生成树</h4><p>在最小生成树上换边，从小到大加入非树边，把非树边所在环上最大的一条边替换掉即可。</p><h4 id="最小生成树计数"><a class="markdownIt-Anchor" href="#最小生成树计数"></a> 最小生成树计数</h4><p>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span> 个点的图的不同的最小生成树的数量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><p>这道题非常好地阐述了最小生成树的性质。</p><p>在 Kruscal 过程中，如果把边按照权值分成若干块，块内所有边权值相等，那么无论块内边的顺序如何，跑完某一块后，图的连通性总是一定的，这一块被选的边的数量也是相同的。因此不同块的选边是独立的，我们只需要每一块枚举一下即可。</p><p>如果没有原题中的限制，同权边很多怎么办呢？</p><p>可以用矩阵树定理计算。</p><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>本文永久链接是：<a href="https://sweetlemon39.github.io/CSP2019-string-and-tree/">https://sweetlemon39.github.io/CSP2019-string-and-tree/</a></p></blockquote></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>笔记</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>字符串</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%A0%91/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>树</p></a></div></div></section><div class="prev-next"><a class="prev" href="/CSP2019-graph/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>CSP 2019 集训 图论</p><p class="content">图论 NOIP 欢乐 赛 和注意到模意义下有乘法群，因此 nnn 的范围可以放到 mmm。如果直接暴力当然是可以拿到 80 分，但是带个 log⁡1018\log 10^{18}log1018...</p></a><a class="next" href="/s-and-d-on-a-tree/"><p class="title">树上前缀和与树上差分<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">树上前缀和与树上差分都是树链剖分优秀的离线替代品，配合树状数组还可以进一步处理在线的情况。 树上前缀和树上前缀和——某个节点到根的路径上的每个点的权值和求法：dfs\mathrm{dfs}dfs...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"CSP 2019 集训 字符串和树",tools:!0}</script></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"></div><div class="text"><h2>Sweetlemon</h2><p>一枚有趣的 OIer！</p></div><div class="social-wrapper"><a href="mailto:mrj1018@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/mrj1018" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://www.luogu.com.cn/user/25008" class="social fas fa-code flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">博客导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-home fa-fw" aria-hidden="true"></i> 博客主页 </a><a class="flat-box" title="/categories/" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i> 文章分类 </a><a class="flat-box" title="/archives/" href="/archives/" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" id="friends"><i class="fas fa-users fa-fw" aria-hidden="true"></i> 博客友链 </a><a class="flat-box" title="/comments/" href="/comments/" id="comments"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> 留言评论 </a><a class="flat-box" title="/about/" href="/about/" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于博主</a></div></div></section><section class="widget grid shadow desktop mobile"><header><a href="/useful-links/"><i class="fas fa-link fa-fw" aria-hidden="true"></i><span class="name">常用站导航</span></a></header><div class="content"><div class="grid navigation"><a class="flat-box" title="https://oi-wiki.org/" href="https://oi-wiki.org/" rel="external nofollow noopener noreferrer" target="_blank" id="https:oi-wikiorg"><i class="fab fa-wikipedia-w fa-fw" aria-hidden="true"></i> OI Wiki </a><a class="flat-box" title="https://www.luogu.com.cn/" href="https://www.luogu.com.cn/" rel="external nofollow noopener noreferrer" target="_blank" id="https:wwwluogucomcn"><i class="fas fa-code fa-fw" aria-hidden="true"></i> 洛谷 </a><a class="flat-box" title="https://www.codeforces.com/" href="https://www.codeforces.com/" rel="external nofollow noopener noreferrer" target="_blank" id="https:wwwcodeforcescom"><i class="fas fa-code fa-fw" aria-hidden="true"></i> Codeforces </a><a class="flat-box" title="http://uoj.ac/" href="http://uoj.ac/" rel="external nofollow noopener noreferrer" target="_blank" id="http:uojac"><i class="fas fa-code fa-fw" aria-hidden="true"></i> UOJ </a><a class="flat-box" title="https://loj.ac/" href="https://loj.ac/" rel="external nofollow noopener noreferrer" target="_blank" id="https:lojac"><i class="fas fa-code fa-fw" aria-hidden="true"></i> LOJ </a><a class="flat-box" title="http://www.noi.cn/" href="http://www.noi.cn/" rel="external nofollow noopener noreferrer" target="_blank" id="http:wwwnoicn"><i class="fa fa-code fa-fw" aria-hidden="true"></i> CCF NOI</a></div></div></section><section class="widget category shadow desktop"><header><a href="/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/" href="/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/" id="categoriesE58DB3E697B6E7AC94E8AEB0"><div class="name">即时笔记</div><div class="badge">(10)</div></a></li><li><a class="flat-box" title="/categories/%E6%80%BB%E7%BB%93/" href="/categories/%E6%80%BB%E7%BB%93/" id="categoriesE680BBE7BB93"><div class="name">总结</div><div class="badge">(2)</div></a></li><li><a class="flat-box" title="/categories/%E6%96%87%E5%8C%96%E8%AF%BE/" href="/categories/%E6%96%87%E5%8C%96%E8%AF%BE/" id="categoriesE69687E58C96E8AFBE"><div class="name">文化课</div><div class="badge">(3)</div></a></li><li><a class="flat-box" title="/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/" href="/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/" id="categoriesE7A9BFE9808FE4B896E7958CE8BEB9E7BC98E79A84E59190E5968A"><div class="name">穿透世界边缘的呐喊</div><div class="badge">(3)</div></a></li><li><a class="flat-box" title="/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" href="/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" id="categoriesE7AE97E6B395E6B585E8A7A3"><div class="name">算法浅解</div><div class="badge">(10)</div></a></li><li><a class="flat-box" title="/categories/%E9%9A%8F%E7%AC%94/" href="/categories/%E9%9A%8F%E7%AC%94/" id="categoriesE99A8FE7AC94"><div class="name">随笔</div><div class="badge">(5)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop mobile"><header><a href="/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/KMP/" style="font-size:14px;color:#999">KMP</a> <a href="/tags/THUWC/" style="font-size:14px;color:#999">THUWC</a> <a href="/tags/floyd/" style="font-size:14px;color:#999">floyd</a> <a href="/tags/gcd/" style="font-size:14px;color:#999">gcd</a> <a href="/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E7%BB%AA%E8%AE%BA/" style="font-size:14px;color:#999">世界间绪论</a> <a href="/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E8%AF%84%E8%AE%BA/" style="font-size:15.67px;color:#8e8e8e">世界间评论</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size:14px;color:#999">二分图</a> <a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/" style="font-size:14px;color:#999">你的名字</a> <a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size:14px;color:#999">函数</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size:14px;color:#999">前缀和</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size:17.33px;color:#828282">动态规划</a> <a href="/tags/%E5%8D%95%E8%AF%8D/" style="font-size:15.67px;color:#8e8e8e">单词</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size:14px;color:#999">单调队列</a> <a href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" style="font-size:14px;color:#999">后缀数组</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size:20.67px;color:#6c6c6c">图论</a> <a href="/tags/%E5%A4%A7%E7%BA%B2/" style="font-size:14px;color:#999">大纲</a> <a href="/tags/%E5%A5%87%E9%97%BB/" style="font-size:14px;color:#999">奇闻</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:19px;color:#777">字符串</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size:14px;color:#999">差分</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size:14px;color:#999">并查集</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size:14px;color:#999">总结</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size:14px;color:#999">排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size:17.33px;color:#828282">搜索</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size:22.33px;color:#606060">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:19px;color:#777">数据结构</a> <a href="/tags/%E6%96%87%E5%8C%96%E8%AF%BE/" style="font-size:17.33px;color:#828282">文化课</a> <a href="/tags/%E6%A0%91/" style="font-size:15.67px;color:#8e8e8e">树</a> <a href="/tags/%E7%A6%BB%E7%BA%BF/" style="font-size:14px;color:#999">离线</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size:24px;color:#555">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" style="font-size:24px;color:#555">算法浅解</a> <a href="/tags/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/" style="font-size:14px;color:#999">紫罗兰永恒花园</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size:15.67px;color:#8e8e8e">英语</a> <a href="/tags/%E8%92%9F%E8%92%BB/" style="font-size:14px;color:#999">蒟蒻</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size:15.67px;color:#8e8e8e">贪心</a> <a href="/tags/%E9%80%80%E5%BD%B9/" style="font-size:14px;color:#999">退役</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:15.67px;color:#8e8e8e">随笔</a></div></section><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希-hana~"><span class="toc-text">哈希 (Hana~!)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#blue-mary的战役"><span class="toc-text">Blue Mary的战役</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trie"><span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#补退选"><span class="toc-text">补退选</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp"><span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串周期"><span class="toc-text">字符串周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抄卡组"><span class="toc-text">抄卡组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#manacher"><span class="toc-text">Manacher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#双倍回文"><span class="toc-text">双倍回文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs-序"><span class="toc-text">dfs 序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#haoi2015树上操作"><span class="toc-text">[HAOI2015]树上操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树上前缀和与树上差分"><span class="toc-text">树上前缀和与树上差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#树上前缀和"><span class="toc-text">树上前缀和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#树上差分"><span class="toc-text">树上差分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#点权和边权"><span class="toc-text">点权和边权</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树上两点距离"><span class="toc-text">树上两点距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs-序-3-树上差分-1"><span class="toc-text">DFS 序 3, 树上差分 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs-序-4"><span class="toc-text">DFS 序 4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lca"><span class="toc-text">LCA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运输计划"><span class="toc-text">运输计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#巡逻"><span class="toc-text">巡逻</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#货车运输"><span class="toc-text">货车运输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#免费道路"><span class="toc-text">免费道路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#次小生成树"><span class="toc-text">次小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小生成树计数"><span class="toc-text">最小生成树计数</span></a></li></ol></li></ol></div></section></aside><footer class="clearfix"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.7" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="551339691" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="mailto:mrj1018@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/mrj1018" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://www.luogu.com.cn/user/25008" class="social fas fa-code flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div class="copyright"><p>By <a href="https://sweetlemon39.github.io">Sweetlemon</a>, with <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a> theme <a href="https://volantis.js.org/" target="_blank" rel="noopener">volantis</a>.</p></div><div><br></div><div><p><a href="https://icp.gov.moe" target="_blank">萌ICP备 </a><a href="https://icp.gov.moe/?keyword=202039314" target="_blank">202039314号</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var e=["https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/vc_247324.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/violet_259998.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__07.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__06.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__03.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/your_name_233767.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__05.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_183538.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_262935.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__01.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/tianyi_221481.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_289028.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_184531.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/ia_292142.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/vc_184412.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/tianyi_229042.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__02.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_288524.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__04.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/anohana_172855.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_279631.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__08.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_191672.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/violet_261791.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/ia_217561.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_297251.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/voc_261300.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_289023.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__09.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__10.jpg"];!function(e){for(var t=e.length;t--;){var g=Math.floor(Math.random()*t),i=e[g];e[g]=e[t],e[t]=i}}(e),$.backstretch(e,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!0,verify=!0,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"uzT4lXHwcPJOlEGevXF7jqRU-gzGzoHsz",appKey:"vVl1bqbOX0WUiA9WFlFhMxBb",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4.0/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/assets/kutori.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body></html>