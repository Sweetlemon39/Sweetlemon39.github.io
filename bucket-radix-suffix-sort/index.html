<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#1.7.2"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>桶排序、基数排序与后缀排序 - Sweetlemon 的异世界</title><meta name="keywords" content="字符串,算法浅解,排序,后缀数组"><meta name="description" content="最近学后缀数组，需要接触到这些排序方法，于是乎开帖记录。"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script></head><body><div class="cover-wrapper"><cover class="cover post half"><p class="title">Sweetlemon 的异世界</p><p class="subtitle">原来你也在这里啊</p><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="一直在寻找着你的踪迹"></form></div><div class="menu navigation"><ul class="h-list"><li><a class="nav home" href="/" id="home"><i class="fas fa-home fa-fw"></i>&nbsp;主页</a></li><li><a class="nav home" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>&nbsp;分类</a></li><li><a class="nav home" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>&nbsp;归档</a></li><li><a class="nav home" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>&nbsp;关于</a></li></ul></div></cover><header class="l_header nav-blur"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><div class="wrapper"><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/">Sweetlemon 的异世界</a><div class="menu navigation"><ul class="h-list"><li><a class="nav flat-box" href="/" id="home"><i class="fas fa-home fa-fw"></i>&nbsp;主页</a></li><li><a class="nav flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>&nbsp;分类</a></li><li><a class="nav flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>&nbsp;归档</a></li><li><a class="nav flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>&nbsp;关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="一直在寻找着你"></form></div><ul class="switcher h-list"><li class="s-search"><a class="fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li class="s-menu"><a class="fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-sub container container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li class="s-toc"><a class="flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><aside class="menu-phone white-box"><header><nav class="menu navigation"><ul><li><a class="nav flat-box" href="/" id="home"><i class="fas fa-home fa-fw"></i>&nbsp;主页</a></li><li><a class="nav flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>&nbsp;分类</a></li><li><a class="nav flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>&nbsp;归档</a></li><li><a class="nav flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>&nbsp;关于</a></li></ul></nav></header></aside><script>setLoadingBarProgress(40)</script></div><div class="l_body"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/bucket-radix-suffix-sort/">桶排序、基数排序与后缀排序</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://sweetlemon39.github.io/" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"><p>Sweetlemon</p></a></div><div class="new-meta-item category"><a href="/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>算法浅解</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2019年6月25日</p></a></div><div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-25T00:00:00+00:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2019年6月25日</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>最近学后缀数组，需要接触到这些排序方法，于是乎开帖记录。</p><a id="more"></a><h3 id="术语说明"><a class="markdownIt-Anchor" href="#术语说明"></a> 术语说明</h3><p>本文中，“排名”可以粗浅地理解为“不大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素个数称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的排名”。但是，有重复元素的时候，假设小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素个数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">a</span></span></span></span>，不大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素个数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathdefault">b</span></span></span></span>，那么这些重复元素的排名各不相同，且都位于区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>中。</p><p>如，数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1,1,2,3,3,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span></span></span></span>中各元素的排名可以是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">1,2,3,4,5,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span></span></span></span>，当然也可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2,1,3,5,4,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span></span></span></span>等等。</p><p>本文中要大量使用“元素数组”、“排名数组”这样的词汇，请牢记它们的含义：叫做什么数组，里面存的就是什么值。</p><ul><li>“元素数组”指根据排名查元素编号的数组，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi></mrow><mo>:</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi></mrow><mo fence="true">}</mo></mrow><mo>→</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{ele}:\left\{\mathrm{rank}\right\}\rightarrow \left\{\mathrm{id}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mclose delimcenter" style="top:0">}</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span></li><li>“排名数组”指根据元素编号查排名的数组，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">k</mi></mrow><mo>:</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo fence="true">}</mo></mrow><mo>→</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi></mrow><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{rk}:\left\{\mathrm{id}\right\}\rightarrow \left\{\mathrm{ele}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">k</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mclose delimcenter" style="top:0">}</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span></li></ul><p>这两个数组之间是逆映射的关系。</p><p>在桶排序中，还会用到桶数组。桶数组是根据元素值查“这个值的元素有多少个”的数组，做前缀和后就是根据元素值查“不大于这个值的元素有多少个”的数组。通常，我们使用它的后一种含义。</p><ul><li>“桶数组”是根据元素值查“不大于这个值的元素有多少个”的数组，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo fence="true">}</mo></mrow><mo>→</mo><mrow><mo fence="true">{</mo><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi></mrow><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{bucket}:\left\{\mathrm{value}\right\}\rightarrow \left\{\mathrm{rank}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">u</span><span class="mord mathrm">c</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span><span class="mclose delimcenter" style="top:0">}</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span></li></ul><p>熟悉这些映射关系，对于快速写出代码有很大帮助。</p><p>文中还用了 Pascal 的数组区间符号。<code>a[1...3]={1,2,3}</code>表示<code>a[1]=1,a[2]=2,a[3]=3</code>。</p><h3 id="离散化"><a class="markdownIt-Anchor" href="#离散化"></a> 离散化</h3><p>首先我们通过复习离散化方法，熟悉“元素数组”和“排名数组”的意义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN]; <span class="comment">//原始数据</span></span><br><span class="line"><span class="keyword">int</span> ele[MAXN],rk[MAXN]; <span class="comment">//定义见上文</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> lhs,<span class="keyword">const</span> <span class="keyword">int</span> rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    ele[i]=i; <span class="comment">//初始化，假设第i名的元素下标是i</span></span><br><span class="line">sort(ele+<span class="number">1</span>,ele+<span class="number">1</span>+n,cmp); <span class="comment">//排序后，第i名元素的下标是ele[i]</span></span><br><span class="line"><span class="comment">//利用rk和ele的互逆关系求rk</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    rk[ele[i]]=i; <span class="comment">//第i名元素的下标所对应的排名是i</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> lhs,<span class="keyword">const</span> <span class="keyword">int</span> rhs)</span></span>&#123;</span><br><span class="line">    <span class="comment">//利用元素给下标排序</span></span><br><span class="line">    <span class="keyword">return</span> a[lhs]&lt;a[rhs];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行后，<code>rk</code>数组中的值就是离散化目标值。</p><h3 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h3><h4 id="单关键字桶排序"><a class="markdownIt-Anchor" href="#单关键字桶排序"></a> 单关键字桶排序</h4><p>桶排序？这个谁不会啊？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN],bucket[MAXM]; <span class="comment">//原始数据, 桶(桶的定义域是原始数据的值域)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    bucket[a[i]]++;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXM;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucket[i];j++)</span><br><span class="line">        a[++pos]=i;</span><br></pre></td></tr></table></figure><p>但是如何用桶排序求出元素数组和排名数组呢？这里介绍一种简单的办法。</p><p>我们知道，原始的桶数组记录的是“值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素的个数”。如果对桶数组做前缀和，记录的就是“值不大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素个数”——不就是“值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>的元素的（最大）排名”吗？之所以是“最大”，是因为可能有重复元素（参见“术语说明”）。于是，我们可以用这种方法得到元素数组和排名数组。</p><p>下面这段代码对于理解多关键字桶排序比较重要，请认真阅读。如果对代码不太理解，请接着阅读下面的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN],bucket[MAXN],ele[MAXN],rk[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    bucket[a[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]+=bucket[i<span class="number">-1</span>]; <span class="comment">//求前缀和</span></span><br><span class="line"><span class="comment">// 此时bucket数组的意义就是“给值，求最大排名”</span></span><br><span class="line"><span class="comment">// 下面用bucket数组求ele数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)&#123; <span class="comment">// 这个循环是倒序的</span></span><br><span class="line">    <span class="keyword">int</span> trank=bucket[a[i]]; <span class="comment">// 求出i号元素的排名</span></span><br><span class="line">    bucket[a[i]]--; <span class="comment">// 排名trank已经被i占用了，下一个来的元素要用上一个可用的排名</span></span><br><span class="line">    ele[trank]=i; <span class="comment">// 排名为trank的元素编号是i</span></span><br><span class="line">    <span class="comment">// 上面这三条语句通常缩写为</span></span><br><span class="line">    <span class="comment">// ele[ bucket[a[i]]-- ]=i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时, a[ele[1]],a[ele[2]],...,a[ele[n]]就是有序的了</span></span><br><span class="line"><span class="comment">//再利用rk和ele的互逆关系求rk</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    rk[ele[i]]=i; <span class="comment">//第i名元素的下标所对应的排名是i</span></span><br></pre></td></tr></table></figure><p>现在问题来了，为什么这个循环是倒序的呢？也就是说，我们需要搞清楚，排名的“分配原则”是什么。同时我们还要搞懂这行关键代码：<code>ele[ bucket[a[i]]-- ]=i;</code></p><p>首先，如果数组中没有重复元素，那么<code>bucket[a[i]]</code>只会被访问一次，其中的值正是<code>i</code>号元素的真正排名。</p><p>但如果数组中有重复元素呢？举个例子，如果<code>a[1...6]={1,4,3,1,3,2}</code>，那么在求前缀和之前，<code>bucket[1...4]={2,1,2,1}</code>；求前缀和之后，<code>bucket[1...4]={2,3,5,6}</code>。那么，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>的“最大排名”是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>的“最大排名”是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span>。</p><p>我们倒序循环分配排名。首先<code>i=6</code>，<code>ele[ bucket[a[6]]-- ]=6</code>。执行语句时<code>bucket[a[6]]=bucket[2]=3</code>，于是我们得到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>号元素的排名是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>，也就是被赋予了排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>的元素是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>号(<code>ele[3]=6</code>)。根据<code>--</code>运算符的规则，我们把<code>bucket[2]</code>的值减<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，那么执行后<code>bucket[2]=2</code>。这表示，排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>已经被占用了，下一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>的元素只能使用排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>——当然，由于数列中只有一个元素的值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>，因此不存在所谓的“下一个元素”。</p><p>接着<code>i=5</code>，<code>ele[ bucket[a[5]]-- ]=5</code>。<code>bucket[a[5]]=bucket[3]=5</code>，那么这次我们把排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span>赋给<code>a[5]</code>。这时<code>bucket[3]--</code>，表示下一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>的元素只能使用排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>——在这里就表示，靠前的一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>将使用排名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>。</p><p>继续模拟这个过程，最后<code>ele[1...6]={1,4,6,3,5,2}</code>。在模拟的过程中我们发现，<strong>值相同的元素，先者总是得到较大的排名</strong>。就有些像孔融让梨，孔融是把大的梨让出去，先拿到排名的元素是把靠前的排名让给后拿到排名的元素。</p><p>而我们倒序循环，原本靠后的元素将先得到排名，结果就是值相同的元素，原本靠后的，排名也较大（即在排序后的数组里也靠后）。这正满足了“稳定性”的定义——这样它就是“稳定排序”了。</p><p>当然，这么做的意义远不止如此，正是这一操作，为桶排序提供了可扩展性。请看——</p><h4 id="多关键字桶排序"><a class="markdownIt-Anchor" href="#多关键字桶排序"></a> 多关键字桶排序</h4><p>什么叫“多关键字”呢？就有点像中考成绩排序——先按总分等级排序，总分等级相同的再按A+数排序，A+数相同的……概括地说，就是，优先按第一关键字排序，如果第一关键字相同，再按第二关键字排序。</p><p>下面我们只讨论两个关键字的情形；在此基础上，很容易扩展出更多关键字的排序。</p><p>还记得上面讲的“稳定性”吗？我们有一个思路——<strong>先按第二关键字排序，再按第一关键字做稳定排序</strong>。</p><p>为什么先排次要关键字呢？可以这么理解——第一次排序的结果会被第二次排序打乱，因此是次要的。第一次排序只是为了第二次排序在<strong>关键字相同</strong>时，提供原先的相对位置。也就是，第一次排序的功效，体现在了排序前相对位置上。</p><p>那么我们就可以写出多关键字桶排序的代码了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN],b[MAXN];<span class="comment">// a 为主要关键字, b为次要关键字</span></span><br><span class="line"><span class="comment">// ele_b是第一次排序时用的ele数组</span></span><br><span class="line"><span class="keyword">int</span> bucket[MAXN],ele[MAXN],ele_b[MAXN],rk[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    bucket[b[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]+=bucket[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)<span class="comment">// 仍然注意这个循环是倒序的</span></span><br><span class="line">    ele_b[ bucket[b[i]]-- ]=i;</span><br><span class="line"><span class="comment">//现在b[ele_b[1]],b[ele_b[2]],...,b[ele_b[n]]是有序的</span></span><br><span class="line"><span class="comment">//我们下一次桶排序循环的时候,就按照ele_b[n],ele_b[n-1],...,ele_b[1]的顺序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    bucket[a[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXM;i++)</span><br><span class="line">    bucket[i]+=bucket[i<span class="number">-1</span>];<span class="comment">//这三个for循环基本相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)<span class="comment">// 按我们上面说的做！</span></span><br><span class="line">    ele[ bucket[ a[ ele_b[i] ] ]-- ]=ele_b[i];</span><br></pre></td></tr></table></figure><p>整段代码最难理解的应该就是<code>ele[bucket[a[ele_b[i]]]--]=ele_b[i];</code>这一行了。足足四层嵌套，让不少多关键字桶排序和基数排序的初学者望而生畏。下面我们解析它。</p><p>对<code>b</code>做排序的时候，我们已经写过一次三层嵌套了。<code>ele_b[ bucket[b[i]]-- ]=i;</code>，意思是<code>bucket[b[i]]</code>中存着<code>b[i]</code>的排名，那么排名为<code>bucket[b[i]]</code>的元素编号就是<code>i</code>。</p><p>对<code>a</code>做排序的时候，我们不是要按<code>ele_b[n],ele_b[n-1],...,ele_b[1]</code>的顺序做嘛——于是，运用换元法，把<code>ele_b[i]</code>带入原来的<code>i</code>中，不就得到了这一行代码吗？</p><p>于是，双关键字的桶排序就写好了。这也就是<a href="https://www.luogu.org/problemnew/show/T84081" target="_blank" rel="noopener">这道题</a>的解法。</p><h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h3><p>基数排序其实就是多关键字的桶排序。比如，给三位数排序，第一关键字是百位，第二关键字是十位，第三关键字是个位。</p><p>但实际操作中，我们所用的模数不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，而是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>的幂。根据<a href="https://www.luogu.org/problemnew/show/P4604" target="_blank" rel="noopener">挑战</a>这道题的经验，我们取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn><mo stretchy="false">(</mo><msup><mn>2</mn><mn>8</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">256(2^8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为模，把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>位整数（也就是<code>int</code>）分为四个关键字进行排序，分别排序四次就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 255</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN],b[MAXN]; <span class="comment">//a储存原数据, b在排序过程中会发生改变</span></span><br><span class="line"><span class="keyword">int</span> b1[BUSKN],b2[BUSKN],b3[BUSKN],b4[BUSKN]; <span class="comment">//val -&gt; rank, 四次排序的桶</span></span><br><span class="line"><span class="keyword">int</span> e1[MAXN],e2[MAXN],e3[MAXN],e4[MAXN]; <span class="comment">//rank -&gt; ID, 四次排序的ele数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> t=b[i]=a[i];</span><br><span class="line">    b1[t&amp;MASK]++,t&gt;&gt;=<span class="number">8</span>;</span><br><span class="line">    b2[t&amp;MASK]++,t&gt;&gt;=<span class="number">8</span>;</span><br><span class="line">    b3[t&amp;MASK]++,t&gt;&gt;=<span class="number">8</span>;</span><br><span class="line">    b4[t&amp;MASK]++; <span class="comment">//分别加到桶里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MASK;i++)</span><br><span class="line">    b1[i]+=b1[i<span class="number">-1</span>],b2[i]+=b2[i<span class="number">-1</span>],</span><br><span class="line">    b3[i]+=b3[i<span class="number">-1</span>],b4[i]+=b4[i<span class="number">-1</span>]; <span class="comment">//给桶做前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心步骤——赋予排名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">    e1[b1[b[i]&amp;MASK]--]=i,        b[i]&gt;&gt;=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">    e2[b2[b[e1[i]]&amp;MASK]--]=e1[i],b[e1[i]]&gt;&gt;=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">    e3[b3[b[e2[i]]&amp;MASK]--]=e2[i],b[e2[i]]&gt;&gt;=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">    e4[b4[b[e3[i]]&amp;MASK]--]=e3[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    ayano(a[e4[i]],<span class="string">' '</span>); <span class="comment">//按顺序输出整数</span></span><br></pre></td></tr></table></figure><h3 id="后缀排序"><a class="markdownIt-Anchor" href="#后缀排序"></a> 后缀排序</h3><p>给后缀排序是建立后缀数组（Suffix Array）的关键操作。</p><p>字符串<code>s[1...n]</code>的后缀就是指这些子串：<code>s[1...n],s[2...n],s[3...n],...,s[n...n]</code>。按照后缀的起始点，分别把它们编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,3,\cdots,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span></span></span></span>。</p><p>“后缀排序”就是对这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>个后缀（就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>个字符串）进行排序。当然不是真的排序，只是求出元素数组和排名数组罢了。</p><p>在这里重新强调元素数组和排名数组的定义：</p><ul><li>元素数组，此处称作后缀数组或<code>sa</code>数组，表示排名为<code>i</code>的后缀的编号是<code>sa[i]</code></li><li>排名数组，此处称作<code>rank</code>（缩写为<code>rk</code>）数组，表示编号为<code>i</code>的后缀排名为<code>rk[i]</code></li></ul><p>还是那句话，“名副其实”，后缀数组里的东西是后缀（的编号），排名数组里的东西是排名。</p><p>如何给后缀排序呢？最简单的方法当然是直接应用一遍快速排序，时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，足够快了吧。</p><p>可惜的是，这个时间复杂度是错的。由于比较两个字符串是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>而非<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的，快速排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次比较，因此正确的复杂度应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n^2 \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，无法承受。</p><p>那么改成基数排序吧？字符串的排序是按照字典序，也就是以第一个字符为第一关键字、以第二个字符为第二关键字，以此类推。可是这样会有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>个关键字，需要（桶）排序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>次，每次排序的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，合起来达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{O}(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">O</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，依然无法承受。</p><p>做不出来的时候怎么办？看看我们是不是漏条件了啊。</p><p>上面的两种方法可是不仅可以用于后缀排序，还可以用于“给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>个字符串排序”啊。这不就相当于，“后缀”的条件完全没有利用上吗？那怎么可能做得出来啊。</p><p>“后缀”的条件是，这些字符串有很多的公共部分！利用这些公共部分，就能改善我们算法的时间复杂度！</p><p>利用这个条件的方法很多，像后缀树、后缀平衡树、后缀自动机等。当然，我们在这里要介绍的是最简单的一种——倍增法求后缀数组。</p><p>倍增法的主要思想是，“用排名代替具体的元素”。</p><p>我们用字符串<code>&quot;aabaaaab&quot;</code>做例子（这个例子好经典，为什么？因为它是 IOI 2009 国家集训队论文里边的啊~），它的后缀有<code>&quot;b&quot;,&quot;ab&quot;,&quot;aab&quot;,&quot;aaab&quot;,&quot;aaaab&quot;,'baaaab&quot;,&quot;abaaaab&quot;,&quot;aabaaaab&quot;</code>。</p><p>首先，我们把所有的后缀调整成一样长的，也就是（假装）我们在字符串后面补了一些空字符（<code>'\0'</code>，字典序是最小的；下面用<code>0</code>表示）。那么后缀就变成了<code>&quot;b0000000&quot;,&quot;ab000000&quot;,&quot;aab00000&quot;,&quot;aaab0000&quot;,&quot;aaaab000&quot;,'baaaab00&quot;,&quot;abaaaab0&quot;,&quot;aabaaaab&quot;</code>。补这些字符并不影响字典序，因为我们规定，比不出大小时短的字符串较小。</p><p>思考这个问题：某些元素，按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>双关键字排序的排名是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">x</span></span></span></span>，按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>双关键字排序的排名是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span></span></span></span>，那么按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>四关键字排序的排名是否就相当于按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.03588em">y</span><span class="mclose">)</span></span></span></span>双关键字排序的排名呢？（关键字的顺序表示主次顺序。）</p><p>思考后可以发现，答案是肯定的。</p><p>那么，我们就把这个字符串的所有长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>的块进行排序；接着把它所有长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>的块按照组成它的两个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>块的排名（在前面的是主要关键字，在后面的是次要关键字）进行双关键字排序，就可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>块的排名；然后再把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>块按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>块的排名进行双关键字排序，得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>块的排名……直到块的长度不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>为止。此时每一个块都是原串的后缀（因为长度不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span>，因此除了<code>s[1...n]</code>，其余块都一定要越过<code>s[n]</code>补零，也就成了后缀），我们就得到了后缀的排序。</p><p>引用一下集训队论文里的图片——</p><p><img src="https://cdn.luogu.com.cn/upload/pic/61393.png" alt="后缀排序基本过程"></p><p>从图中我们可以看到，每一次排序都是把上次排序的<strong>rank数组作为元素值</strong>，也就是“用排名代替具体的元素”。排序的主要关键字是上一次的<code>rank[i]</code>，次要关键字是上一次的<code>rank[i+w]</code>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">w=2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.02691em">w</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span>。</p><p>从图中我们还可以看到，我们不必实际地去补“0”，只需要在所找的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span>块、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span>块等超出边界的时候直接令他们的原排名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>即可。</p><p>那么，我们就可以实现代码了。</p><p>首先是桶排序部分的代码。我们已经把次要关键字<code>rk[i+w]</code>的<strong>元素数组</strong>制作好并存到了数组<code>tp</code>里，因此相当于次要关键字已经排好序了。注意，<code>sa</code>和<code>tp</code>都是元素数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务: 根据主要关键字的值数组rk和次要关键字的排名数组tp, 计算元素数组sa</span></span><br><span class="line">    <span class="comment">// n是字符串长, m是rk和tp的值域（[1,m]）</span></span><br><span class="line">    <span class="comment">// 各映射的信息: rk: id-&gt;val, tp: rank-&gt;id, bucket: val-&gt;rank, sa: rank-&gt;id</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        bucket[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        bucket[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        bucket[i]+=bucket[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">        sa[ bucket[ rk[ tp[i] ] ]-- ] = tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四重嵌套那一行可能比较难写。一个较为快速的推法是，把映射关系写下来，再根据映射关系写（“量纲分析”）。</p><ol><li>要求出<code>sa</code>，先写<code>sa[ ]=</code></li><li><code>sa</code>的值是<code>id</code>，值是<code>id</code>的只有<code>tp</code>，写下<code>sa[ ]=tp[i]</code></li><li><code>sa</code>的定义域是<code>rank</code>，值域是<code>rank</code>的只有<code>bucket</code>，写下<code>sa[bucket[ ]--]=tp[i]</code>（是<code>bucket</code>，所以伴随着<code>--</code>）</li><li><code>bucket</code>的定义域是<code>val</code>,值域是<code>val</code>的只有<code>rk</code>，写下<code>sa[bucket[rk[ ]]--]=tp[i]</code></li><li><code>rk</code>的定义域是<code>id</code>，值域是<code>id</code>的已知量只有<code>tp</code>，写下<code>sa[bucket[rk[tp[i]]]--]=tp[i]</code>。</li></ol><p>接着再来实现后缀排序的主函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_sort</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//字符串长度为n</span></span><br><span class="line">    <span class="comment">//先做一遍长度为1的块的排序</span></span><br><span class="line">    <span class="comment">//因为是第一遍排序, 所以第一关键字是字符大小</span></span><br><span class="line">    <span class="comment">//第二关键字随意指定一个，那么第二关键字的元素数组可以设为1,2,...,n</span></span><br><span class="line">    <span class="keyword">int</span> m=<span class="string">'z'</span>-<span class="string">'/'</span>; <span class="comment">//假设字符集是0-9,A-Z,a-z</span></span><br><span class="line">    <span class="comment">//m表示字符集大小,也就是值数组的值域</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="comment">//分别求出第一遍排序的主要关键字 值数组 和次要关键字 元素数组</span></span><br><span class="line">        rk[i]=str[i]-<span class="string">'/'</span>, tp[i]=i; </span><br><span class="line">    bucket_sort(n,m);</span><br><span class="line">    <span class="comment">//下面开始重复排序，也就是倍增过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;w&lt;n &amp;&amp; p&lt;n;w&lt;&lt;=<span class="number">1</span>,m=p)&#123;</span><br><span class="line">        <span class="comment">//w表示上一次排序的块长</span></span><br><span class="line">        <span class="comment">//为进行排序,先制作tp数组</span></span><br><span class="line">        p=<span class="number">0</span>; <span class="comment">//记录排名</span></span><br><span class="line">        <span class="comment">//先处理那些次要关键字已经超过了串的末尾,也就是达到补零位置的块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            tp[++p]=i; <span class="comment">//将“++p”这个排名分配给i这个块</span></span><br><span class="line">            <span class="comment">//这些块的次要关键字都一样,任意指定一些最靠前的排名就好了</span></span><br><span class="line">        <span class="comment">//接着根据上一回排序的“排名”的元素数组，制作本次的元素数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="comment">//取上一回第i名的块,分配排名</span></span><br><span class="line">            <span class="keyword">if</span> (sa[i]&gt;w) <span class="comment">//如果某个块的编号小于w,那么这次就不会作为后继块(sa[i]-w已经小于0了)</span></span><br><span class="line">                tp[++p]=sa[i]-w; <span class="comment">//给sa[i]-w（前驱块的编号）分配++p的排名</span></span><br><span class="line">        <span class="comment">//上述循环顺序进行, 先遍历到的块比较小, 分配靠前的排名</span></span><br><span class="line">        <span class="comment">//现在tp数组制作完成，开始进行排序</span></span><br><span class="line">        bucket_sort(n,m);</span><br><span class="line">        <span class="comment">//现在根据sa数组制作rk数组</span></span><br><span class="line">        swap(rk,tp); <span class="comment">//tp数组已经使用完毕了(排序后就不需要上一次排序的信息了),下面我们用它来储存上一轮的rk数组</span></span><br><span class="line">        rk[sa[<span class="number">1</span>]]=<span class="number">1</span>; <span class="comment">//排名为1的元素所对应的排名是1</span></span><br><span class="line">        p=<span class="number">1</span>; <span class="comment">//此处p的含义是已经分配了的排名</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span> (tp[sa[i]]==tp[sa[i<span class="number">-1</span>]] &amp;&amp; tp[sa[i]+w]==tp[sa[i<span class="number">-1</span>]]+w)</span><br><span class="line">                <span class="comment">//上述两个条件说明, 组成 sa[i]和sa[i-1],即排名为i和i-1的两个元素的两个块完全相同</span></span><br><span class="line">                rk[sa[i]]=p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]]=++p;</span><br><span class="line">        <span class="comment">//到此处,p表示已经分配出的排名种类数；同时也是值数组的值域,因此可以作为下一轮的m值</span></span><br><span class="line">        <span class="comment">//p=n表示已经区分出了n种后缀,后缀排序就完成了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个函数，我们就计算出了<code>sa</code>和<code>rk</code>数组，也就实现了后缀排序。输出<code>sa</code>数组就可以通过<a href="https://www.luogu.org/problemnew/show/P3809" target="_blank" rel="noopener">这道模板题</a>了。</p><p>可能这里的注释还有一些不清楚的地方，但是暂时无法进一步完善了（哭）。如果有什么问题在评论区提吧。</p><p>那么这篇文章就结束了。</p></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;<p>字符串</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;<p>算法浅解</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%8E%92%E5%BA%8F/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;<p>排序</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i>&nbsp;<p>后缀数组</p></a></div></div></section><div class="prev-next"><section class="prev"><span class="art-item-left"><h4><a href="/s-and-d-on-a-tree/" rel="prev" title="树上前缀和与树上差分"><i class="fas fa-chevron-left" aria-hidden="true"></i> 树上前缀和与树上差分</a></h4><h6 class="tags">&nbsp;<a class="tag" href="/tags/%E6%A0%91/"><i class="fas fa-tag" aria-hidden="true"></i> 树</a> <a class="tag" href="/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/"><i class="fas fa-tag" aria-hidden="true"></i> 算法浅解</a> <a class="tag" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"><i class="fas fa-tag" aria-hidden="true"></i> 前缀和</a> <a class="tag" href="/tags/%E5%B7%AE%E5%88%86/"><i class="fas fa-tag" aria-hidden="true"></i> 差分</a></h6></span></section><section class="next"><span class="art-item-right" aria-hidden="true"><h4><a href="/adventure-record/" rel="prev" title="奇闻记录">奇闻记录 <i class="fas fa-chevron-right" aria-hidden="true"></i></a></h4><h6 class="tags"><a class="tag" href="/tags/%E5%A5%87%E9%97%BB/"><i class="fas fa-tag" aria-hidden="true"></i> 奇闻</a>&nbsp;</h6></span></section></div></section></article><article class="post white-box comments"><section class="article typo"><h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
  });</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>window.subData={title:"桶排序、基数排序与后缀排序",tools:!0}</script></div><aside class="l_side"><section class="widget blogger widget-blur desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/mrj1018/OI/lemon.png"></div><div class="text"><h2>Sweetlemon</h2><p>一枚有趣的 OIer！</p></div><div class="social-wrapper"><a href="mailto:mrj1018@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/mrj1018" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://www.luogu.com.cn/user/25008" class="social fas fa-code flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid widget-blur desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">博客导航</span></header><div class="content"><ul class="grid navigation"><li><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-home fa-fw" aria-hidden="true"></i> 博客主页</a></li><li><a class="flat-box" title="/categories/" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i> 文章分类</a></li><li><a class="flat-box" title="/archives/" href="/archives/" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档</a></li><li><a class="flat-box" title="/friends/" href="/friends/" id="friends"><i class="fas fa-users fa-fw" aria-hidden="true"></i> 博客友链</a></li><li><a class="flat-box" title="/comments/" href="/comments/" id="comments"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> 留言评论</a></li><li><a class="flat-box" title="/about/" href="/about/" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于博主</a></li></ul></div></section><section class="widget grid widget-blur desktop mobile"><header><a href="/useful-links/"><i class="fas fa-link fa-fw" aria-hidden="true"></i><span class="name">常用站导航</span></a></header><div class="content"><ul class="grid navigation"><li><a class="flat-box" title="https://oi-wiki.org/" href="https://oi-wiki.org/" rel="external nofollow noopener noreferrer" target="_blank" id="https:oi-wiki.org"><i class="fab fa-wikipedia-w fa-fw" aria-hidden="true"></i> OI Wiki</a></li><li><a class="flat-box" title="https://www.luogu.com.cn/" href="https://www.luogu.com.cn/" rel="external nofollow noopener noreferrer" target="_blank" id="https:www.luogu.com.cn"><i class="fas fa-code fa-fw" aria-hidden="true"></i> 洛谷</a></li><li><a class="flat-box" title="https://www.codeforces.com/" href="https://www.codeforces.com/" rel="external nofollow noopener noreferrer" target="_blank" id="https:www.codeforces.com"><i class="fas fa-code fa-fw" aria-hidden="true"></i> Codeforces</a></li><li><a class="flat-box" title="http://uoj.ac/" href="http://uoj.ac/" rel="external nofollow noopener noreferrer" target="_blank" id="http:uoj.ac"><i class="fas fa-code fa-fw" aria-hidden="true"></i> UOJ</a></li><li><a class="flat-box" title="https://loj.ac/" href="https://loj.ac/" rel="external nofollow noopener noreferrer" target="_blank" id="https:loj.ac"><i class="fas fa-code fa-fw" aria-hidden="true"></i> LOJ</a></li><li><a class="flat-box" title="http://www.noi.cn/" href="http://www.noi.cn/" rel="external nofollow noopener noreferrer" target="_blank" id="http:www.noi.cn"><i class="fa fa-code fa-fw" aria-hidden="true"></i> CCF NOI</a></li></ul></div></section><section class="widget category widget-blur desktop"><header><a href="/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/" href="/categories/%E5%8D%B3%E6%97%B6%E7%AC%94%E8%AE%B0/" id="categoriesE58DB3E697B6E7AC94E8AEB0"><div class="name">即时笔记</div><div class="badge">(10)</div></a></li><li><a class="flat-box" title="/categories/%E6%80%BB%E7%BB%93/" href="/categories/%E6%80%BB%E7%BB%93/" id="categoriesE680BBE7BB93"><div class="name">总结</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/" href="/categories/%E7%A9%BF%E9%80%8F%E4%B8%96%E7%95%8C%E8%BE%B9%E7%BC%98%E7%9A%84%E5%91%90%E5%96%8A/" id="categoriesE7A9BFE9808FE4B896E7958CE8BEB9E7BC98E79A84E59190E5968A"><div class="name">穿透世界边缘的呐喊</div><div class="badge">(3)</div></a></li><li><a class="flat-box" title="/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" href="/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" id="categoriesE7AE97E6B395E6B585E8A7A3"><div class="name">算法浅解</div><div class="badge">(10)</div></a></li><li><a class="flat-box" title="/categories/%E9%9A%8F%E7%AC%94/" href="/categories/%E9%9A%8F%E7%AC%94/" id="categoriesE99A8FE7AC94"><div class="name">随笔</div><div class="badge">(5)</div></a></li></ul></div></section><section class="widget tagcloud widget-blur desktop"><header><a href="/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/KMP/" style="font-size:14px;color:#999">KMP</a> <a href="/tags/THUWC/" style="font-size:14px;color:#999">THUWC</a> <a href="/tags/floyd/" style="font-size:14px;color:#999">floyd</a> <a href="/tags/gcd/" style="font-size:14px;color:#999">gcd</a> <a href="/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E7%BB%AA%E8%AE%BA/" style="font-size:14px;color:#999">世界间绪论</a> <a href="/tags/%E4%B8%96%E7%95%8C%E9%97%B4%E8%AF%84%E8%AE%BA/" style="font-size:16px;color:#8b8b8b">世界间评论</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size:14px;color:#999">二分图</a> <a href="/tags/%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/" style="font-size:14px;color:#999">你的名字</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size:14px;color:#999">前缀和</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size:18px;color:#7e7e7e">动态规划</a> <a href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size:14px;color:#999">单调队列</a> <a href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" style="font-size:14px;color:#999">后缀数组</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size:22px;color:#636363">图论</a> <a href="/tags/%E5%A4%A7%E7%BA%B2/" style="font-size:14px;color:#999">大纲</a> <a href="/tags/%E5%A5%87%E9%97%BB/" style="font-size:14px;color:#999">奇闻</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:20px;color:#707070">字符串</a> <a href="/tags/%E5%B7%AE%E5%88%86/" style="font-size:14px;color:#999">差分</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size:14px;color:#999">排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size:18px;color:#7e7e7e">搜索</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size:22px;color:#636363">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:18px;color:#7e7e7e">数据结构</a> <a href="/tags/%E6%A0%91/" style="font-size:16px;color:#8b8b8b">树</a> <a href="/tags/%E7%A6%BB%E7%BA%BF/" style="font-size:14px;color:#999">离线</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size:24px;color:#555">笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%B5%85%E8%A7%A3/" style="font-size:24px;color:#555">算法浅解</a> <a href="/tags/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/" style="font-size:14px;color:#999">紫罗兰永恒花园</a> <a href="/tags/%E8%92%9F%E8%92%BB/" style="font-size:14px;color:#999">蒟蒻</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size:14px;color:#999">贪心</a> <a href="/tags/%E9%80%80%E5%BD%B9/" style="font-size:14px;color:#999">退役</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16px;color:#8b8b8b">随笔</a></div></section><section class="widget toc-wrapper widget-blur desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#术语说明"><span class="toc-text">术语说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散化"><span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序"><span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单关键字桶排序"><span class="toc-text">单关键字桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多关键字桶排序"><span class="toc-text">多关键字桶排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后缀排序"><span class="toc-text">后缀排序</span></a></li></ol></div></section></aside><footer class="clearfix"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.7" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="551339691" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="mailto:mrj1018@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/mrj1018" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://www.luogu.com.cn/user/25008" class="social fas fa-code flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div class="copyright"><p><a href="https://sweetlemon39.github.io">By Sweetlemon</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script async src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script async src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js" async></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script src="//cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var e=["https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/vc_247324.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/violet_259998.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__07.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__06.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__03.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/your_name_233767.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__05.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_183538.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_262935.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__01.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/tianyi_221481.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_289028.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_184531.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/ia_292142.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/vc_184412.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/tianyi_229042.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__02.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_288524.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__04.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/anohana_172855.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/miku_279631.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/sukasuka__08.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/kagerou_191672.jpg","https://cdn.jsdelivr.net/gh/Sweetlemon39/Sweetlemon39.github.io@dev/images/bg/violet_261791.jpg"];!function(e){for(var t=e.length;t--;){var g=Math.floor(Math.random()*t),i=e[g];e[g]=e[t],e[t]=i}}(e),$.backstretch(e,{duration:"20000",fade:"2500"})})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"uzT4lXHwcPJOlEGevXF7jqRU-gzGzoHsz",appKey:"vVl1bqbOX0WUiA9WFlFhMxBb",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@1.7.2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script></body></html>